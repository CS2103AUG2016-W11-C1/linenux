# A0135788M
###### \DeveloperGuide.md
``` md
## Design

#### Architecture

<img src="images/developerGuide/mvc.png"/>

Linenux follows the Model-View-Controller (MVC) pattern which is made up of 3 main components.

1. **Model** is where Linenux's data objects are stored. It is independent from the view and controller.
2. **View** is the window that our user sees and interacts with. It updates whenever there are changes to the model.
3. **Controller** is the decision maker and the glue between model and view.

#### Model Component

<img src="images/developerGuide/model.png">

##### *Schedule and State class*

The **Schedule** class stores the data of **Task** and **Reminder** instances in-memory. To facillitate the `undo` command, we introduce an intermediary class known as **State**. A **State** object represents the state of the **Schedule** class at a point in time. A new **State** object is added to the **Schedule** class whenever a task or reminder is created, updated or deleted. Thus, to `undo` a command, we can simply discard the most recent **State**.

To properly capture the above behaviour, we have made **State**, **Task** and **Reminder** classes immutable. An immutable object is an object whose state cannot be modified after it is created. This means that any modification to a **Task** or **Reminder** object will cause a new **State** object to be added. This is why any methods that mutate the data should do so via the **Schedule** class. This follows the Momento Pattern as it provides the **Schedule** class with the ability to restore itself to its previous state.

Specifically, we have exposed three mutation methods:

1. `addTask`
2. `updateTask`
3. `deleteTask`

*Notable APIs:* [`Schedule.java`](https://github.com/CS2103AUG2016-W11-C1/main/blob/master/src/main/java/linenux/model/Schedule.java)

| Return type  | Method and Description                                                                                      |
| ------------ | ------------------------------------------------------------------------------------------------------------|
| void         | `addTask(Task task)`: Adds the task into the schedule.                                                      |
| void         | `updateTask(Task originalTask, Task newTask)`: Updates the original task in the schedule with the new task. |
| void         | `deleteTask(Task task)`: Deletes the task from the schedule.                                                |
| State        | `getMostRecentState()`: Returns the most recent state of schedule.                                          |
| void         | `addState(State)`: Adds a new state into the list of states.                                                |

```
###### \DeveloperGuide.md
``` md
##### *Command Interface*

**Command** interface defines the necessary methods that **CommandManager** requires to allocate the correct command based on the user input. This follows the Command Pattern as the client, in this case the **CommandManager** class can treat each command type as a black box, calling the four methods in the table below whenever there is a user input.

*Notable APIs:* [`Command.java`](https://github.com/CS2103AUG2016-W11-C1/main/blob/master/src/main/java/linenux/command/Command.java)

| Return type   | Method and Description                                                                                           |
| --------------| -----------------------------------------------------------------------------------------------------------------|
| Boolean       | `respondTo(String userInput)`: checks if command responds to userInput.                                          |
| CommandResult | `execute(String userInput)`: executes the command.                                                               |
| Boolean       | `isAwaitingUserResponse()`: checks if the command is awaiting for a response from the user.                      |
| CommandResult | `processUserResponse(String userInput)`: carries out user response.                                              |

```
###### \DeveloperGuide.md
``` md
##### *GenericParser Class*

For complex commands that requires searching and mutating the data, we have abstracted the parsing implementation so that commands that have the format `command KEYWORDS flag1/value1 flag2/value2` can use the **GenericParser** class. It separates the user input into the keywords, and the flags and their respective values are put into a hash table with the flags as keys.

```
###### \DeveloperGuide.md
``` md
## Testing

Tests can be found in the `./src/test/java` folder. 

#### In Eclipse

* To run all tests, right click on the `src/test/java` folder in the package explorer and choose `Run as` > `JUnit Test`.
* To run a subset of tests, you can right click on a test package, test class or a test in the package explorer and choose `Run as` > `JUnit Test`.

#### Using Gradle

* To run all tests, run `gradle test` command in the terminal.

#### Types of Test

##### *Unit Tests*

Example: [`TodayWithTimeParserTest.java`](https://github.com/CS2103AUG2016-W11-C1/main/blob/e850198163971412ddcde7c2da6cbcaf416f77a5/src/test/java/linenux/time/parser/TodayWithTimeParserTest.java)

The **TodayWithTimeParser** class is chosen to be a unit of test. It is considered unit test as the unit
does not interact with other parts of the code. This is achieved by injecting mocked dependencies. In this case,
**TodayWithTimeParser** needs to determine the current time. A mocked **Clock** object is injected and will always return the same
time.

##### *Integration Tests*

Example: [`AddCommandTest.java`](https://github.com/CS2103AUG2016-W11-C1/main/blob/e850198163971412ddcde7c2da6cbcaf416f77a5/src/test/java/linenux/command/AddCommandTest.java#L127-L142)

The `execute_validEvent_taskAdded` test ensures that the **AddCommand**, **Schedule**, **State**, and **Task** classes work in tandem
and produce the expected changes in response to a user input.

Example: [`AutoCompleteTest.java`](https://github.com/CS2103AUG2016-W11-C1/main/blob/e850198163971412ddcde7c2da6cbcaf416f77a5/src/test/java/linenux/gui/AutoCompleteTest.java)

The **AutoCompleteTest** ensures that the **CommandBoxController**, **AutoCompleter**, and **TernarySearchTree** integrates well. This
is done by simulating an actual user interaction and ensure that the expected suggestion show up in the command box.

```
###### \DeveloperGuide.md
``` md
## Appendices

#### Appendix A : User Stories

Priorities: High (must have) - `* * *`, Medium (nice to have)  - `* *`,  Low (unlikely to have) - `*`

|Priority | As a ...  | I want to ...                             | So that I can ...                                                                                           |
|-------- | :-------- | :---------------------------------------  | :-----------------------------------------------------------------------------------------------------------|
|`* * *`  | user      | see usage instructions                    | have a reference on how to use the App in the event that I do not know the commands or have forgotten them. |
|`* * *`  | user      | add a new task                            |                                                                                                             |
|`* * *`  | user      | edit a task                               | update the deadlines or other details regarding the task.                                                   |
|`* * *`  | user      | delete a task                             | remove tasks that I no longer need.                                                                         |
|`* * *`  | user      | view a task                               | check the details of the task.                                                                              |
|`* * *`  | user      | filter list of tasks shown                | see only tasks that are of interest.                                                                        |
|`* * *`  | user      | mark a task as done                       | indicate that a task is done so that it doesn't show up as a to-do.                                         |
|`* * *`  | user      | list tasks by day or deadlines            | plan ahead.                                                                                                 |
|`* * *`  | user      | undo previous commands                    | correct any erroneous actions.                                                                              |
|`* *`    | user      | rename a tag                              | update the tags that are used for tasks.                                                                    |
|`* *`    | user      | set reminders for tasks                   | make preperations before their stipulated deadlines.                                                        |
|`* *`    | user      | edit a reminder                           | update the details regarding the reminder.                                                                  |
|`* *`    | user      | find free time slots                      | make appointments with others.                                                                              |
|`* *`    | user      | create personalized alias for commands    | effectively use the commands available.                                                                     |
|`* *`    | user      | save the storage file into another folder | choose my preferred storage location.
|`*`      | user      | have a day/week/month view                | more easily digest the information.                                                                         |
|`*`      | user      | print the schedule for the day/week/month | have a hard copy of my schedule.                                                                            |
|`*`      | user      | sync with Google Calendar                 | have the option to view on any devices with access to the Internet.                                         |
|`*`      | user      | see syntax highlighting                   | more easily discern special keywords and commands.                                                          |
|`*`      | user      | see push notifications                    | be constantly reminded without having to open the App.                                                      |
|`*`      | user      | have a mini-window mode                   | the application does not take up the whole screen.                                                          |
|`*`      | user      | have multiple language support            | choose my preferred working language.                                                                       |

```
###### \DeveloperGuide.md
``` md
##### *Use Case 5: Renaming a tag*

*MSS*

1. User requests to rename a tag.
2. Linenux searches for tasks with tags matching the tag name exactly.
3. Linenux manages to find tasks with that tag and replaces it with the new tag. 
4. Linenux displays success message. <br>
Use Case ends.  
  
*Extensions*

1a. User omits compulsory fields.
> 1a1. Linenux displays error message indicating missing fields. <br>
  Use Case ends.

1b. User types in invalid formats for the fields.
> 1b1. Linenux displays error message indicating invalid formats for the fields. <br>
  Use Case ends.

3a. No task in schedule has tag with that specific name.
> 3a1. Linenux shows error message to indicate no tasks with that tag found. <br>
  Use Case ends.  
  
##### *Use Case 6: Marking a task as done*

*MSS*

1. User requests to mark a task as done.
2. Linenux searches for tasks with names containing the keywords.
3. Only one task with that keyword is found and Linenux marks that task as done. 
4. Linenux displays success message. <br>
Use Case ends.
  
*Extensions*

3a. No task in schedule has name with keywords.
> 3a1. Linenux shows error message to indicate no task found. <br>
  Use Case ends.

3b. Multiple tasks are found and user selects valid index. 
> 3b1. Linenux displays the list of tasks with index containing keywords. <br>
  3b2. User selects valid index. <br>
  3b3. Linenux marks that task as done. <br>
  3b4. Linenux displays success message. <br>
  Use Case ends. 
  
3c. Multiple tasks are found and user selects invalid index. 
> 3c1. Linenux displays the list of tasks with index containing keywords. <br>
  3c2. User selects invalid index. <br>
  3c3. Linenux displays error message to indicate invalid index. <br>
  Use Case resumes at step 3c1.   
  
3d. Multiple tasks are found and user selects cancel. 
> 3d1. Linenux displays the list of tasks with index containing keywords. <br>
  3d2. User types cancel. <br>
  3d3. Linenux does not mark any tasks as done. <br>
  Use Case ends.     
  
```
###### \DeveloperGuide.md
``` md
##### *Use Case 14: Viewing details around a task*

*MSS*

1. User requests to view details around a task.
2. Linenux searches for tasks with names containing the keywords.
3. Only one task with that keyword is found and Linenux views that task. <br>
Use Case ends.
  
*Extensions*

3a. No task in schedule has name with keywords.
> 3a1. Linenux shows error message to indicate no task found. <br>
  Use Case ends.

3b. Multiple tasks are found and user selects valid index. 
> 3b1. Linenux displays the list of tasks with index containing keywords. <br>
  3b2. User selects valid index. <br>
  3b3. Linenux views that task. <br>
  Use Case ends. 
  
3c. Multiple tasks are found and user selects invalid index. 
> 3c1. Linenux displays the list of tasks with index containing keywords. <br>
  3c2. User selects invalid index. <br>
  3c3. Linenux displays error message to indicate invalid index. <br>
  Use Case resumes at step 3c1.   
  
3d. Multiple tasks are found and user selects cancel. 
> 3d1. Linenux displays the list of tasks with index containing keywords. <br>
  3d2. User types cancel. <br>
  3d3. Linenux does not view any task. <br>
  Use Case ends.     

##### *Use Case 15: Finding a free timeslot*

*MSS*

1. User requests when he/she is free in a given time range.
2. Linenux computes the result based on events and shows the user when he/she is free. <br>
Use Case ends.    

*Extensions*

1a. User omits compulsory fields.
> 1a1. Linenux displays error message indicating missing fields. <br>
  Use Case ends.

1b. User types in invalid formats for the fields.
> 1b1. Linenux displays error message indicating invalid formats for the fields. <br>
  Use Case ends.

```
