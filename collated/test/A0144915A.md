# A0144915A
###### /java/linenux/command/AddCommandTest.java
``` java
/**
 * JUnit test for add command.
 */
public class AddCommandTest {
    private Schedule schedule;
    private AddCommand addCommand;

    @Before
    public void setupAddCommand() {
        this.schedule = new Schedule();
        this.addCommand = new AddCommand(this.schedule);
    }

    /**
     * Test that respondTo detects various versions of the commands. It should return true even if
     * the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputStartingWithAdd_trueReturned() {
        assertTrue(this.addCommand.respondTo("add"));
        assertTrue(this.addCommand.respondTo("add #/"));
        assertTrue(this.addCommand.respondTo("add #/category"));
        assertTrue(this.addCommand.respondTo("add #/category #/"));
        assertTrue(this.addCommand.respondTo("add #/category #/tag"));

        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial #/category"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial #/category #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial #/category #/tag"));

        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 #/category"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 #/category #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 #/category #/tag"));

        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial et/2016-01-01"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial et/2016-01-01 #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial et/2016-01-01 #/category"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial et/2016-01-01 #/category #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial et/2016-01-01 #/category #/tag"));

        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 et/2016-01-01"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 et/2016-01-01 #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 et/2016-01-01 #/category"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 et/2016-01-01 #/category #/"));
        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st/2016-01-01 et/2016-01-01 #/category #/tag"));

        assertTrue(this.addCommand.respondTo("add CS2103T Tutorial st2016-01-01 et2016-01-01 #category #tag"));
    }

    /**
     * Test that respondTo is case-insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.addCommand.respondTo("AdD CS2103T Tutorial"));
    }

    /**
     * Test that respondTo will return false for commands not related to add tasks.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.addCommand.respondTo("halp"));
    }

    /**
     * Test that executing the add task command will correctly add new to-do to the schedule.
     */
    @Test
    public void execute_validTodo_taskAdded() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand.execute("add CS2103T Tutorial"));

        // The new task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        assertEquals("CS2103T Tutorial", addedTask.getTaskName());

        // The new task should not have start time
        assertNull(addedTask.getStartTime());

        // The new task should not have end time
        assertNull(addedTask.getEndTime());
    }

    /**
     * Test that executing the add task command will correctly add new deadline to the schedule.
     */
    @Test
    public void execute_validDeadline_taskAdded() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand.execute("add CS2103T Tutorial et/2016-01-01 5.00PM"));

        // The new deadline has the correct name, start time, and end time
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertNull(addedTask.getStartTime());
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), addedTask.getEndTime());
    }

    /**
     * Test that executing the add task command will correctly add new event to the schedule.
     */
    @Test
    public void execute_validEvent_taskAdded() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand.execute("add CS2103T Tutorial st/2016-01-01 5.00PM et/2016-01-02 5.00PM"));

        // The new event has the correct name, start time, and end time
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), addedTask.getStartTime());
        assertEquals(LocalDateTime.of(2016, 1, 2, 17, 0), addedTask.getEndTime());
    }

    /**
     * Test that executing the add task command will correctly add a tagged Todo
     * with a single tag to schedule.
     */
    @Test
    public void execute_validTodoWithTag_taskAdded() {
        this.schedule.clear();
        assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("add CS2103T Tutorial #/tag1 tag2"));

        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(0);

        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertEquals(1, addedTask.getTags().size());
        assertEquals("tag1 tag2", addedTask.getTags().get(0));
    }

    /**
     * Test that executing the add task command will correctly add a tagged Todo
     * with multiple tags to schedule.
     */
    @Test
    public void execute_validTodoWithMultipleTags_taskAdded() {
        this.schedule.clear();
        assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("add CS2103T Tutorial #/tag1 tag2 #/tag3"));

        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(0);

        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertEquals(2, addedTask.getTags().size());
        assertEquals("tag1 tag2", addedTask.getTags().get(0));
        assertEquals("tag3", addedTask.getTags().get(1));
    }

    /**
     * Test that executing the add task command will ignore repeating tags.
     *
     */
    @Test
    public void execute_validTodoWithRepeatedTags_taskAdded() {
        this.schedule.clear();
        assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("add CS2103T Tutorial #/tag #/tag"));

        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(0);

        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertEquals(1, addedTask.getTags().size());
        assertEquals("tag", addedTask.getTags().get(0));
    }

    /**
     * Test that order of times do not matter.
     */
    @Test
    public void execute_shuffleEventFlags_taskAdded() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand
                        .execute("add CS2103T Tutorial #/tag 1 et/2016-01-02 5.00PM #/tag 2 st/2016-01-01 5.00PM"));

        // The new event has the correct name, start time, and end time
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        ArrayList<String> tagList = addedTask.getTags();

        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), addedTask.getStartTime());
        assertEquals(LocalDateTime.of(2016, 1, 2, 17, 0), addedTask.getEndTime());

        assertEquals(2, tagList.size());
        assertEquals("tag 1", tagList.get(0));
        assertEquals("tag 2", tagList.get(1));
    }

    /**
     * Test that executing an add task command should return the correct result.
     */
    @Test
    public void execute_validTodo_commandResultReturned() {
        CommandResult result = this.addCommand.execute("add CS2103T Tutorial");
        assertEquals("Added CS2103T Tutorial", result.getFeedback());
    }

    /**
     * Test that adding a new deadline should return the correct result.
     */
    @Test
    public void execute_validDeadline_commandResultReturned() {
        CommandResult result = this.addCommand.execute("add CS2103T Tutorial et/2016-01-01 5.00PM");
        assertEquals("Added CS2103T Tutorial (Due 2016-01-01 5.00PM)", result.getFeedback());
    }

    /**
     * Test that adding a new event should return the correct result.
     */
    @Test
    public void execute_validEvent_commandResultReturned() {
        CommandResult result = this.addCommand.execute("add CS2103T Tutorial st/2016-01-01 5.00PM et/2016-01-02 5.00PM");
        assertEquals("Added CS2103T Tutorial (2016-01-01 5.00PM - 2016-01-02 5.00PM)", result.getFeedback());
    }

    /**
     * Test that adding a new Todo with a single tag returns the correct result
     * message.
     *
     */
    @Test
    public void execute_validTodoWithTag_commandResultReturned() {
        CommandResult result = this.addCommand.execute("add CS2103T Tutorial #/tag1 tag2");
        assertEquals("Added CS2103T Tutorial [Tags: \"tag1 tag2\" ]", result.getFeedback());
    }

    /**
     * Test the result when running without a task name
     *
     */
    @Test
    public void execute_noTaskName_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test the result when the task name consists of only empty spaces.
     */
    @Test
    public void execute_emptyTaskName_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add             "));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test that task name cannot be empty.
     */
    @Test
    public void execute_noTaskNameWithFlag_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add st/2016-01-01 5:00PM"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test that task name cannot be empty.
     */
    @Test
    public void execute_deadlineWithoutTaskName_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add et/2016-01-01 5:00PM"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    @Test
    public void execute_tagWithoutTaskName_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add #/tag1 tag2"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test that invalid time formats are not accepted.
     */
    @Test
    public void execute_invalidStartTimeFormat_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello st/yesterday et/2016-12-31 11:59PM"));

        assertEquals("Cannot parse \"yesterday\".", result.getFeedback());
    }

    /**
     * Test that invalid time formats are not accepted.
     */
    @Test
    public void execute_invalidEndTimeFormat_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello et/tomorrow"));

        assertEquals("Cannot parse \"tomorrow\".", result.getFeedback());
    }

    /**
     * Test that adding tag with empty spaces in category will return an error.
     */
    @Test
    public void execute_emptyTag_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello #/      "));

        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test that no tasks are created with start time only.
     *
     */
    @Test
    public void execute_startTimeWithoutEndTime_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello st/2016-01-01 5.00PM"));

        assertEquals("Cannot create task with start time but without end time.", result.getFeedback());
    }

    /**
     * Test that end time cannot be before start time.
     */
    @Test
    public void execute_endTimeBeforeStartTime_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello st/2016-01-02 5.00PM et/2016-01-01 5.00PM"));

        assertEquals("End time cannot come before start time.", result.getFeedback());
    }

    /**
     * Test that duplicate to-do is not added
     */
    @Test
    public void execute_duplicatedTodo_commandResultReturned() {
        this.schedule.addTask(new Task("todo"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add todo"));
        assertEquals("todo already exists in the schedule!", result.getFeedback());
    }

    /**
     * Test that duplicate deadline is not added
     */
    @Test
    public void execute_duplicatedDeadline_commandResultReturned() {
        this.schedule.addTask(new Task("deadline", LocalDateTime.of(2016, 1, 1, 17, 0)));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add deadline et/2016-01-01 5.00PM"));
        assertEquals("deadline (Due 2016-01-01 5.00PM) already exists in the schedule!", result.getFeedback());
    }

    /**
     * Test that duplicate event is not added
     */
    @Test
    public void execute_duplicatedEvent_commandResultReturned() {
        this.schedule
                .addTask(new Task("event", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2017, 1, 1, 17, 0)));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add event st/2016-01-01 5.00PM et/2017-01-01 5.00PM"));
        assertEquals("event (2016-01-01 5.00PM - 2017-01-01 5.00PM) already exists in the schedule!",
                result.getFeedback());
    }

    /**
     * Test that similar to-do is added
     */
    @Test
    public void execute_similarTodo_taskAdded() {
        this.schedule.addTask(new Task("todo", LocalDateTime.of(2016, 1, 1, 17, 0)));
        this.schedule
                .addTask(new Task("todo", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2017, 1, 1, 17, 0)));
        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("add todo"));
        assertEquals("Added todo", result.getFeedback());
    }

    /**
     * Test that similar deadline is added
     */
    @Test
    public void execute_similarDeadline_taskAdded() {
        this.schedule.addTask(new Task("deadline"));
        this.schedule.addTask(new Task("deadline", LocalDateTime.of(2019, 1, 1, 17, 0)));
        this.schedule.addTask(
                new Task("deadline", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2017, 1, 1, 17, 0)));

        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("add deadline et/2017-01-01 5.00PM"));
        assertEquals("Added deadline (Due 2017-01-01 5.00PM)", result.getFeedback());

        CommandResult result2 = assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("add deadline et/2016-01-01 5.00PM"));
        assertEquals("Added deadline (Due 2016-01-01 5.00PM)", result2.getFeedback());
    }

    /**
     * Test that similar event is added
     */
    @Test
    public void execute_similarEvent_taskAdded() {
        this.schedule.addTask(new Task("event"));
        this.schedule.addTask(
                new Task("event", LocalDateTime.of(2016, 1, 1, 17, 0)));

        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("add event st/2016-01-01 5.00PM et/2017-01-01 5.00PM"));
        assertEquals("Added event (2016-01-01 5.00PM - 2017-01-01 5.00PM)", result.getFeedback());
    }


    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + this.addCommand.getCommandFormat() + "\n\n" + Command.CALLOUTS;
    }
}
```
###### /java/linenux/command/FileCommandsTest.java
``` java
abstract public class FileCommandsTest {
    protected Path tempDir;
    protected ScheduleStorage storage;
    protected Config config;
    protected ControlUnit controlUnit;

    @Before
    public void setupTestEnvironment() throws Exception {
        this.tempDir = Files.createTempDirectory("tmp").toAbsolutePath();
        this.storage = new MockStorage();
        this.config = new MockConfig();
        this.controlUnit = new ControlUnit(this.storage, this.config, null);
    }

    protected static class MockStorage implements ScheduleStorage {
        @Override
        public Schedule loadScheduleFromFile() {
            return new Schedule();
        }

        @Override
        public void saveScheduleToFile(Schedule schedule) {
        }

        @Override
        public boolean hasScheduleFile() {
            return true;
        }
    }

    protected static class MockConfig implements Config {
        private String scheduleFilePath = "existingPath";

        @Override
        public String getVersionNo() {
            return "test";
        }

        @Override
        public String getScheduleFilePath() {
            return this.scheduleFilePath;
        }

        @Override
        public void setScheduleFilePath(String path) {
            this.scheduleFilePath = path;
        }

        @Override
        public boolean hasConfigFile() {
            return true;
        }

        @Override
        public Collection<String> getAliases(String triggerWords) {
            return null;
        }

        @Override
        public void setAliases(String triggerWord, Collection<String> aliases) {

        }
    }
}
```
###### /java/linenux/command/FreeTimeCommandTest.java
``` java
public class FreeTimeCommandTest {
    FreeTimeCommand command;

    @Before
    public void setupCommand() {
        Schedule schedule = new Schedule();
        Task event1 = new Task("Event 1", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2016, 1, 1, 19, 0));
        Task event2 = new Task("Event 2", LocalDateTime.of(2016, 1, 1, 21, 0), LocalDateTime.of(2016, 1, 1, 23, 0));
        schedule.addTask(event1);
        schedule.addTask(event2);

        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));

        this.command = new FreeTimeCommand(schedule, clock);
    }

    @Test
    public void respondTo_commandThatStartsWithFreetime_trueReturned() {
        assertTrue(this.command.respondTo("freetime"));
        assertTrue(this.command.respondTo("   freetime   "));
        assertTrue(this.command.respondTo("freetime et/2016-01-01 5.00PM"));
        assertTrue(this.command.respondTo("freetime st/2016-01-01 5.00PM et/2016-01-02 5.00PM"));
    }

    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.command.respondTo("FrEetime"));
    }

    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.command.respondTo("freetimeee"));
        assertFalse(this.command.respondTo("facetime"));
    }

    @Test
    public void execute_validInput_commandResultReturned() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 3.00PM et/2016-01-01 11.59PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 3.00PM - 2016-01-01 5.00PM\n" +
                " - 2016-01-01 7.00PM - 2016-01-01 9.00PM\n" +
                " - 2016-01-01 11.00PM - 2016-01-01 11.59PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_noStartTime_nowAssumed() {
        CommandResult result = this.command.execute("freetime et/2016-01-01 11.59PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 3.24PM - 2016-01-01 5.00PM\n" +
                " - 2016-01-01 7.00PM - 2016-01-01 9.00PM\n" +
                " - 2016-01-01 11.00PM - 2016-01-01 11.59PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_invalidTime_commandResultReturned() {
        CommandResult result = this.command.execute("freetime et/Jan 1, 16 2359");
        String expectedResult = "Cannot parse \"Jan 1, 16 2359\".";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/tomorrow et/2016-01-01 11.59PM");
        expectedResult = "Cannot parse \"tomorrow\".";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_endTimeBeforeStartTime_commandResultReturned() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 5.00PM et/2016-01-01 4.45PM");
        String expectedResult = "End time must be after start time.";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime et/2016-01-01 3.00PM");
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_noFreetimeAtTheBeginning_commandResultReturned() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 5.00PM et/2016-01-01 8.00PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 7.00PM - 2016-01-01 8.00PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_noFreetimeAtTheEnd_commandResultReturned() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 3.00PM et/2016-01-01 7.00PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 3.00PM - 2016-01-01 5.00PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_noEndTime_commandResultReturned() {
        CommandResult result = this.command.execute("freetime");
        String expectedResult = "End time must be specified.";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/2016-01-01 5.00PM");
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_noFreetime_commandResultReturned() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 5.00PM et/2016-01-01 7.00PM");
        String expectedResult = "You don't have any free time in that period.";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void execute_queryRangeIntersectsWithEvent_commandResultReturned() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 6.00PM et/2016-01-01 8.00PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 7.00PM - 2016-01-01 8.00PM\n";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/2016-01-01 4.00PM et/2016-01-01 6.00PM");
        expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 4.00PM - 2016-01-01 5.00PM\n";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/2016-01-01 5.30PM et/2016-01-01 6.30PM");
        expectedResult = "You don't have any free time in that period.";
        assertEquals(expectedResult, result.getFeedback());
    }
}
```
###### /java/linenux/command/InvalidCommandTest.java
``` java
/**
 * JUnit test for invalid command.
 */
public class InvalidCommandTest {
    private ControlUnit controlUnit;
    private Command invalidCommand;

    @Before
    public void setupInvalidCommand() {
        CommandManager manager = new CommandManager();
        manager.addCommand(new ListCommand());
        manager.addCommand(new ExitCommand());

        this.controlUnit = new ControlUnit(new MockStorage(), new MockConfig(), manager);

        this.invalidCommand = new InvalidCommand(this.controlUnit);

        manager.setCatchAllCommand(this.invalidCommand);
    }

    /**
     * Test correct response with suggestions.
     */
    @Test
    public void execute_withArgument_commandResultWithSuggestion() {
        CommandResult result = this.invalidCommand.execute("eit");
        assertEquals("Invalid command. Did you mean exit?", result.getFeedback());
    }

    @Test
    public void execute_yes_commandResultWithSuggestion() {
        CommandResult result = this.controlUnit.execute("yes");
        assertEquals("Invalid command. Did you mean list?", result.getFeedback());
    }

    @Test
    public void execute_followUpWithYes_suggestionExecuted() {
        CommandResult result = this.controlUnit.execute("ls");
        assertEquals("Invalid command. Did you mean list?", result.getFeedback());
        result = this.controlUnit.execute("yes");
        assertEquals("list", result.getFeedback());
        result = this.controlUnit.execute("yes");
        assertEquals("Invalid command. Did you mean list?", result.getFeedback());
    }

    @Test
    public void execute_noFollowUp_suggestionDiscarded() {
        this.controlUnit.execute("ls");
        CommandResult result = this.controlUnit.execute("exit");
        assertEquals("exit", result.getFeedback());
        result = this.controlUnit.execute("yes");
        assertEquals("Invalid command. Did you mean list?", result.getFeedback());
    }

    /**
     * Test correct response without any suggestions.
     */
    @Test
    public void execute_noSuggestion_commandResultReturned() {
        this.invalidCommand = new InvalidCommand(new ControlUnit(new MockStorage(), new MockConfig(), new CommandManager()));
        CommandResult result = this.invalidCommand.execute("eit");
        assertEquals("Invalid command.", result.getFeedback());
    }

    private static class BaseMockCommand extends AbstractCommand {
        @Override
        public String getTriggerWord() {
            return null;
        }

        @Override
        public String getDescription() {
            return null;
        }

        @Override
        public String getCommandFormat() {
            return null;
        }

        @Override
        public CommandResult execute(String input) {
            return this::getTriggerWord;
        }
    }

    private static class ListCommand extends BaseMockCommand {
        public ListCommand() {
            this.TRIGGER_WORDS.add("list");
        }

        @Override
        public String getTriggerWord() {
            return "list";
        }
    }

    private static class ExitCommand extends BaseMockCommand {
        public ExitCommand() {
            this.TRIGGER_WORDS.add("exit");
        }

        @Override
        public String getTriggerWord() {
            return "exit";
        }
    }

    private static class MockStorage implements ScheduleStorage {
        @Override
        public Schedule loadScheduleFromFile() {
            return new Schedule();
        }

        @Override
        public void saveScheduleToFile(Schedule schedule) {
        }

        @Override
        public boolean hasScheduleFile() {
            return true;
        }
    }

    private static class MockConfig implements Config {
        @Override
        public String getVersionNo() {
            return "fakeVersion";
        }

        @Override
        public String getScheduleFilePath() {
            return "fakepath";
        }

        @Override
        public void setScheduleFilePath(String path){
        }

        @Override
        public boolean hasConfigFile() {
            return true;
        }

        @Override
        public Collection<String> getAliases(String triggerWord) {
            return null;
        }

        @Override
        public void setAliases(String triggerWord, Collection<String> aliases) {
        }
    }
}
```
###### /java/linenux/command/LoadCommandTest.java
``` java
public class LoadCommandTest extends FileCommandsTest {
    private LoadCommand loadCommand;

    @Before
    @Override
    public void setupTestEnvironment() throws Exception {
        super.setupTestEnvironment();
        this.loadCommand = new LoadCommand(this.controlUnit, this.tempDir);
    }
    @Test
    public void execute_existentAndReadableRelativePath_scheduleLoaded() throws Exception {
        String target = this.tempDir.resolve("hello.xml").toString();
        new FileOutputStream(target).close();

        CommandResult result = this.loadCommand.execute("load hello.xml");
        String expectedFeedback = "Loaded from " + target;
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals(target, this.config.getScheduleFilePath());
    }

    @Test
    public void execute_existentAndReadableAbsolutePath_scheduleLoaded() throws Exception {
        String target = this.tempDir.resolve("hello.xml").toString();
        new FileOutputStream(target).close();

        CommandResult result = this.loadCommand.execute("load " + target);
        String expectedFeedback = "Loaded from " + target;
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals(target, this.config.getScheduleFilePath());
    }

    @Test
    public void execute_pathDoesNotExist_commandResultReturned() {
        String target = this.tempDir.resolve("404.xml").toString();

        CommandResult result = this.loadCommand.execute("load 404.xml");
        String expectedFeedback = target + " does not exist.";
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
    }

    @Test
    public void execute_fileExistsButNotReadable_commandResultReturned() throws Exception {
        String target = this.tempDir.resolve("hello.xml").toString();
        File f = new File(target);
        new FileOutputStream(f).close();
        boolean updated = f.setReadable(false);
        if (!updated) { // Windows does not support this.
            return;
        }

        CommandResult result = this.loadCommand.execute("load hello.xml");
        String expectedFeedback = target + " is not readable.";
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
    }

    @Test
    public void execute_pathIsNotAFile_commandResultReturned() {
        String target = this.tempDir.resolve("hello.xml").toString();
        File f = new File(target);
        f.mkdirs();

        CommandResult result = this.loadCommand.execute("load hello.xml");
        String expectedFeedback = target + " is not a file.";
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
    }

    @Test
    public void execute_invalidArgument_commandResultReturned() {
        CommandResult result = this.loadCommand.execute("load");
        String expectedFeedback = "Invalid arguments.\n\n" +
                "load PATH\n\n" +
                "* Non-compulsory fields are in square brackets.\n" +
                "* Arguments are case insensitive.";
        assertEquals(expectedFeedback, result.getFeedback());
    }
}
```
###### /java/linenux/command/SaveCommandTest.java
``` java
public class SaveCommandTest extends FileCommandsTest {
    private SaveCommand saveCommand;

    @Before
    @Override
    public void setupTestEnvironment() throws Exception {
        super.setupTestEnvironment();
        this.saveCommand = new SaveCommand(this.controlUnit, this.tempDir);
    }

    @Test
    public void execute_writableAbsolutePath_scheduleSaved() throws Exception {
        Path anotherTempDir = Files.createTempDirectory("tmp").toAbsolutePath();
        Path targetPath = anotherTempDir.resolve("schedule.xml");
        String target = targetPath.toString();

        CommandResult result = this.saveCommand.execute("save " + target);
        String expectedResult = "Saved to " + target;
        assertEquals(expectedResult, result.getFeedback());
        assertEquals(target, this.config.getScheduleFilePath());
    }

    @Test
    public void execute_writableRelativePath_scheduleSaved() {
        CommandResult result = this.saveCommand.execute("save hello.xml");
        String expectedPath = this.tempDir.resolve("hello.xml").toString();
        String expectedResult = "Saved to " + expectedPath;
        assertEquals(expectedResult, result.getFeedback());
        assertEquals(expectedPath, this.config.getScheduleFilePath());
    }

    @Test
    public void execute_existingFile() throws Exception {
        String target = this.tempDir.resolve("hello.xml").toString();
        new FileOutputStream(target).close();
        CommandResult result = this.saveCommand.execute("save hello.xml");
        String expectedResult = target + " already exists.\n" +
                "Do you want to overwrite it? (yes/no)";
        assertEquals(expectedResult, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
        assertTrue(this.saveCommand.isAwaitingUserResponse());

        result = this.saveCommand.processUserResponse("bla");
        expectedResult = "I don't understand that. Do you want to overwrite " + target + "? (yes/no)";
        assertEquals(expectedResult, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
        assertTrue(this.saveCommand.isAwaitingUserResponse());

        result = this.saveCommand.processUserResponse("no");
        expectedResult = "OK! Not overwriting " + target;
        assertEquals(expectedResult, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
        assertFalse(this.saveCommand.isAwaitingUserResponse());

        this.saveCommand.execute("save hello.xml");
        assertTrue(this.saveCommand.isAwaitingUserResponse());
        result = this.saveCommand.processUserResponse("yes");
        expectedResult = "Saved to " + target;
        assertEquals(expectedResult, result.getFeedback());
        assertEquals(target, this.config.getScheduleFilePath());
        assertFalse(this.saveCommand.isAwaitingUserResponse());
    }

    @Test
    public void execute_nonWritableFile_commandResultReturn() throws Exception {
        String target = this.tempDir.resolve("notWritable.xml").toString();
        File f = new File(target);
        new FileOutputStream(f).close();
        f.setWritable(false);

        CommandResult result = this.saveCommand.execute("save notWritable.xml");
        String expectedFeedback = target + " already exists.\n" +
                "Do you want to overwrite it? (yes/no)";
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());

        result = this.saveCommand.processUserResponse("yes");
        expectedFeedback = "Cannot save to " + target;
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
    }

    @Test
    public void execute_parentIsNotWritable_commandResultReturned() {
        File f = new File(this.tempDir.toString());
        boolean updated = f.setWritable(false); // Windows does not support this.
        if (!updated) {
            return;
        }

        CommandResult result = this.saveCommand.execute("save notWritable.xml");
        String expectedPath = this.tempDir.resolve("notWritable.xml").toString();
        String expectedFeedback = "Cannot save to " + expectedPath;
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals("existingPath", this.config.getScheduleFilePath());
    }

    @Test
    public void execute_parentDirectoryNonExistent_missingDirectoryCreated() {
        CommandResult result = this.saveCommand.execute("save subdir/schedule.xml");

        Path parent = this.tempDir.resolve("subdir");
        File parentFile = new File(parent.toString());
        assertTrue(parentFile.exists());
        assertTrue(parentFile.isDirectory());

        Path target = parent.resolve("schedule.xml");
        File targetFile = new File(target.toString());
        assertTrue(targetFile.exists());
        assertTrue(targetFile.isFile());

        String expectedPath = target.toString();
        String expectedFeedback = "Saved to " + expectedPath;
        assertEquals(expectedFeedback, result.getFeedback());
        assertEquals(expectedPath, this.config.getScheduleFilePath());
    }

    @Test
    public void execute_invalidArgument_commandResultReturned() {
        CommandResult result = this.saveCommand.execute("save");
        String expectedFeedback = "Invalid arguments.\n\n" +
                "save PATH\n\n" +
                "* Non-compulsory fields are in square brackets.\n" +
                "* Arguments are case insensitive.";
        assertEquals(expectedFeedback, result.getFeedback());
    }

}
```
###### /java/linenux/command/UnaliasCommandTest.java
``` java
public class UnaliasCommandTest {
    private Schedule schedule;
    private AddCommand addCommand;
    private DeleteCommand deleteCommand;
    private UnaliasCommand unaliasCommand;

    @Before
    public void setupCommands() {
        this.schedule = new Schedule();
        this.addCommand = new AddCommand(this.schedule);
        this.deleteCommand = new DeleteCommand(this.schedule);
        this.unaliasCommand = new UnaliasCommand(ArrayListUtil.fromArray(new Command[] {this.addCommand, this.deleteCommand}));

        this.addCommand.setAlias("a");
    }

    @Test
    public void respondTo_inputThatBeginsWithUnalias_trueReturned() {
        assertTrue(this.unaliasCommand.respondTo("unalias"));
        assertTrue(this.unaliasCommand.respondTo("unalias bla"));
        assertTrue(this.unaliasCommand.respondTo("unalias foo bar"));
        assertTrue(this.unaliasCommand.respondTo("uNaLiaS"));
    }

    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.unaliasCommand.respondTo("notalias"));
        assertFalse(this.unaliasCommand.respondTo("aunalias"));
        assertFalse(this.unaliasCommand.respondTo("unaliasa"));
    }

    @Test
    public void execute_validInput_aliasRemoved() {
        assertTrue(this.addCommand.respondTo("a"));
        CommandResult result = this.unaliasCommand.execute("unalias a");
        String expectedResult = "\"a\" is removed as an alias.";
        assertEquals(expectedResult, result.getFeedback());
        assertFalse(this.addCommand.respondTo("a"));
    }

    @Test
    public void execute_nonExistentAlias_commandResultReturned() {
        CommandResult result = this.unaliasCommand.execute("unalias b");
        String expectedResult = "\"b\" is not an alias.";
        assertEquals(expectedResult, result.getFeedback());
        assertTrue(this.addCommand.respondTo("a"));
        assertTrue(this.addCommand.respondTo("add"));
    }

    @Test
    public void execute_defaultCommand_commandResultReturned() {
        CommandResult result = this.unaliasCommand.execute("unalias delete");
        String expectedResult = "\"delete\" cannot be removed as an alias.";
        assertEquals(expectedResult, result.getFeedback());
    }
}
```
###### /java/linenux/gui/AddTaskTest.java
``` java
public class AddTaskTest extends GuiTest {
    @Test
    public void add_addTodo_todoAddedToTodosList() {
        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());

        robot.clickOn("#textField");
        robot.write("add hello\n");

        verifyThat("#todosList", hasItems(1));
        verifyThat("#todosList", hasCellTitle("hello"));
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());
    }

    @Test
    public void done_markTodoAsDone_todoRemovedFromTodosList() {
        robot.clickOn("#textField");
        robot.write("add hello\n");
        robot.write("add world\n");

        verifyThat("#todosList", hasItems(2));
        verifyThat("#todosList", hasCellTitle("hello"));
        verifyThat("#todosList", hasCellTitle("world"));

        robot.write("done hello\n");

        verifyThat("#todosList", hasItems(1));
        verifyThat("#todosList", hasCellTitle("world"));
    }

    @Test
    public void add_addDeadline_deadlineAddedToDeadlinesList() {
        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());

        robot.clickOn("#textField");
        robot.write("add deadline et/2016-01-01 5.00PM\n");

        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", hasItems(1));

        verifyThat("#deadlinesList", hasCellTitle("deadline"));
        verifyThat("#deadlinesList", hasCellTime("Due 01 Jan 2016 5.00PM"));

        verifyThat("#eventsList", isEmpty());
    }

    @Test
    public void done_markDeadlineAsDone_deadlineRemovedFromDeadlinesList() {
        robot.clickOn("#textField");
        robot.write("add deadline et/2016-01-01 5.00PM\n");
        robot.write("add another et/2016-02-01 5.00PM\n");

        verifyThat("#deadlinesList", hasItems(2));

        robot.write("done deadline\n");

        verifyThat("#deadlinesList", hasItems(1));

        verifyThat("#deadlinesList", hasCellTitle("another"));
    }

    @Test
    public void add_addEvent_eventAddedToEventsList() {
        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());

        robot.clickOn("#textField");
        robot.write("add event st/2016-01-01 5.00PM et/2016-01-01 7.00PM\n");

        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", hasItems(1));

        verifyThat("#eventsList", hasCellTitle("event"));
        verifyThat("#eventsList", hasCellTime("From 01 Jan 2016 5.00PM to 01 Jan 2016 7.00PM"));
    }
}
```
###### /java/linenux/gui/CommandBoxCaretPosition.java
``` java
public class CommandBoxCaretPosition extends GuiTest {
    @Test
    public void leftAndRightKey_moveCaretAndModifyText() {
        robot.clickOn("#textField");
        robot.write("add hello");

        for (int i = 0; i < 5; i++) {
            robot.pressAndRelease(KeyCode.LEFT);
        }

        robot.write("b");

        verifyThat("#textField", textFieldHasText("add bhello"));

        for (int i = 0; i < 5; i++) {
            robot.pressAndRelease(KeyCode.RIGHT);
        }

        robot.write("c");

        verifyThat("#textField", textFieldHasText("add bhelloc"));
    }

    @Test
    public void upKey_pressUpKeyAndModifyText() {
        robot.clickOn("#textField");
        robot.write("add hello\n");
        robot.pressAndRelease(KeyCode.UP);
        robot.write("ooo");
        verifyThat("#textField", textFieldHasText("add helloooo"));
    }

    @Test
    public void downKey_browseCommandHistoryAndModifyText() {
        robot.clickOn("#textField");
        robot.write("add hello\n");
        robot.write("add world\n");
        robot.pressAndRelease(KeyCode.UP);
        robot.pressAndRelease(KeyCode.UP);
        robot.pressAndRelease(KeyCode.DOWN);
        robot.write("ddd");
        verifyThat("#textField", textFieldHasText("add worldddd"));
    }

    @Test
    public void autoComplete_tabOnCommandWord_commandWordSuggested() {
        robot.clickOn("#textField");
        robot.write("a");
        robot.pressAndRelease(KeyCode.TAB);
        robot.write(" hello");
        verifyThat("#textField", textFieldHasText("add hello"));
    }
}
```
###### /java/linenux/gui/CommandHistoryTest.java
``` java
public class CommandHistoryTest extends GuiTest {
    @Test
    public void commandHistory_browseCommandHistory_commandHistoryShown() {
        robot.write("add hello\n");
        robot.write("add world\n");

        robot.pressAndRelease(KeyCode.UP);
        verifyThat("#textField", textFieldHasText("add world"));

        robot.pressAndRelease(KeyCode.UP);
        verifyThat("#textField", textFieldHasText("add hello"));

        robot.pressAndRelease(KeyCode.DOWN);
        robot.sleep(1);
        verifyThat("#textField", textFieldHasText("add world"));

        robot.pressAndRelease(KeyCode.DOWN);
        robot.sleep(1);
        verifyThat("#textField", textFieldHasText(""));
    }
}
```
###### /java/linenux/gui/GuiTest.java
``` java
public abstract class GuiTest {
    protected BetterRobot robot;
    private Path tempDir;

    @Before
    public void setupGuiTest() throws Exception {
        tempDir = Files.createTempDirectory("tmp");

        FxToolkit.registerPrimaryStage();
        FxToolkit.setupApplication(() -> {
            String version = "v0.0";
            String configPath = tempDir.resolve("config.json").toString();
            String schedulePath = tempDir.resolve("schedule.xml").toString();
            return new TestMain(version, configPath, schedulePath);
        });
        FxToolkit.showStage();
        this.robot = new BetterRobot();
    }

    @After
    public void teardownSetup() {
        tempDir.resolve("config.json").toFile().delete();
        tempDir.resolve("schedule.xml").toFile().delete();
        tempDir.toFile().delete();
    }

    public static class TestMain extends Main {
        public static void main(String args) {
            launch(args);
        }

        public TestMain(String ver, String configFilePath, String scheduleFilePath) {
            super();
            this.config = new JsonConfig(ver, configFilePath, scheduleFilePath);
        }
    }
}
```
###### /java/linenux/helpers/Assert.java
``` java
/**
 * More assertions to make life (testing) easier.
 *
 * Most of these assertions can be overloaded to deal with different data types.
 */
public class Assert {
    /**
     * Assert that an integer value (supplied by {@code supplier}) does not change after performing
     * the {@code action}.
     * @param supplier Supplies the integer value to test.
     * @param action The action to perform.
     * @param <R> The return type of {@code action}.
     * @return The return value of {@code action}. This is useful to test the return value of {@code action}.
     */
    public static <R> R assertNoChange(IntSupplier supplier, Supplier<R> action) {
        return assertChangeBy(supplier, 0, action);
    }

    /**
     * Assert that an integer value (supplied by {@code supplier}) changes by {@code delta} after performing
     * the {@code action}. In other words, the final value should be the initial value + {@code delta}.
     * @param supplier Supplies the integer value to test.
     * @param delta The expected change.
     * @param action The action to perform.
     * @param <R> The return type of {@code action}.
     * @return The return value of {@code action}.
     */
    public static <R> R assertChangeBy(IntSupplier supplier, int delta, Supplier<R> action) {
        int before = supplier.getAsInt();
        R output = action.get();
        int after = supplier.getAsInt();
        assertEquals(before + delta, after);
        return output;
    }
}
```
###### /java/linenux/helpers/BetterRobot.java
``` java
public class BetterRobot extends FxRobot {
    public void pressAndRelease(KeyCode key) {
        this.press(key);
        this.release(key);
    }
}
```
###### /java/linenux/helpers/GuiMatchers.java
``` java
/**
 * Class to check if information is displayed correctly.
 */
public class GuiMatchers {

    /**
     * Checks if list contains task with correct title.
     * @param title
     * @return
     */
    public static Matcher<Node> hasCellTitle(String title) {
        return typeSafeMatcher(ListView.class, title, node -> listHasCellTitle(node, title));
    }

    /**
     * Checks if list contains task with correct time.
     * @param time
     * @return
     */
    //@@A0135788M
    public static Matcher<Node> hasCellTime(String time) {
        return typeSafeMatcher(ListView.class, time, node -> listHasCellTime(node, time));
    }

    /**
     * Check if ListView node has the specified title.
     *
     * @param node
     *            The node to check.
     * @param title
     *            The specified title.
     * @return True if the node has the specified title, false otherwise.
     */
    private static boolean listHasCellTitle(ListView node, String title) {
        NodeFinder finder = FxAssert.assertContext().getNodeFinder();
        NodeQuery query = finder.from(node);
        return query.lookup(".list-cell")
                .<Cell>match(cell -> {
                    if (cell.isEmpty() || cell.getItem() == null) {
                        return false;
                    } else {
                        Task todo = (Task) cell.getItem();
                        return todo.getTaskName().equals(title);
                    }
                })
                .tryQuery()
                .isPresent();
    }

    /**
     * Check if the ListView node has the specified time.
     *
     * @param node
     *            The node to check.
     * @param time
     *            The specified time.
     * @return True if the node has the specified time, false otherwise.
     */
    private static boolean listHasCellTime(ListView node, String time) {
        NodeFinder finder = FxAssert.assertContext().getNodeFinder();
        NodeQuery query = finder.from(node);
        return query.lookup(".list-cell")
                .<Cell>match(cell -> {
                    if (cell.isEmpty() || cell.getItem() == null) {
                        return false;
                    } else {
                        Task task = (Task) cell.getItem();
                        if (task.isDeadline()) {
                            String result = "Due " + LocalDateTimeUtil.toString(task.getEndTime());
                            return result.equals(time);
                        } else if (task.isEvent()) {
                            String result = "From " + LocalDateTimeUtil.toString(task.getStartTime()) + " to "
                                    + LocalDateTimeUtil.toString(task.getEndTime());
                            return result.equals(time);
                        }
                        return false;
                    }
                })
                .tryQuery()
                .isPresent();
    }

    /**
     * Returns the current selected {@code Node}.
     *
     * @return
     */
    public static Matcher<Node> isFocused() {
        return baseMatcher("is focused", node -> node.focusedProperty().get());
    }

    /**
     * Returns the node with the specified text.
     *
     * @param text
     *            The specified text.
     * @return
     */
    public static Matcher<Node> textFieldHasText(String text) {
        return typeSafeMatcher(TextField.class, text, node -> node.getText().equals(text));
    }
}
```
###### /java/linenux/time/parser/ISODateWithTimeParserTest.java
``` java
/**
 * JUnit test for ISODateWithTime time format.
 */
public class ISODateWithTimeParserTest {
    TimeParser parser;

    @Before
    public void setupParser() {
        this.parser = new ISODateWithTimeParser();
    }

    /**
     * Test that parser responds to valid format.
     */
    @Test
    public void respondTo_validInputFormat_trueReturned() {
        assertTrue(this.parser.respondTo("2016-10-01 2.05PM"));
    }

    /**
     * Test that parser responds to lowercase am and pm.
     */
    @Test
    public void respondTo_lowerCaseAmPm_trueReturned() {
        assertTrue(this.parser.respondTo("2016-10-01 2.05am"));
        assertTrue(this.parser.respondTo("2016-10-01 2.05pm"));
    }

    /**
     * Test that parser responds to invalid format.
     */
    @Test
    public void respondTo_invalidInputFormat_falseReturned() {
        assertFalse(this.parser.respondTo("Jan 1, 2016 2:05PM"));
        assertFalse(this.parser.respondTo("yesterday"));
        assertFalse(this.parser.respondTo("2:05PM"));
        assertFalse(this.parser.respondTo("2016-01-01"));
        assertFalse(this.parser.respondTo("2016-01-01 14:00"));
    }

    /**
     * Test that parser parses correctly for uppercase AM.
     */
    @Test
    public void parse_upperCaseAm_parsedDateMatchesExpected() {
        LocalDateTime dateTime = this.parser.parse("2016-10-01 9.23AM");
        LocalDateTime expectedDateTime = LocalDateTime.of(2016, 10, 01, 9, 23);
        assertEquals(expectedDateTime, dateTime);
    }

    /**
     * Test that parser parses correctly for uppercase PM.
     */
    @Test
    public void parse_upperCasePm_parsedDateMatchesExpected() {
        LocalDateTime dateTime = this.parser.parse("2016-10-01 2.05PM");
        LocalDateTime expectedDateTime = LocalDateTime.of(2016, 10, 01, 14, 5);
        assertEquals(expectedDateTime, dateTime);
    }

    /**
     * Test that parser parses correctly for lowercase AM.
     */
    @Test
    public void parse_lowerCaseAm_parsedDateMatchesExpected() {
        LocalDateTime dateTime = this.parser.parse("2016-10-01 9.23am");
        LocalDateTime expectedDateTime = LocalDateTime.of(2016, 10, 01, 9, 23);
        assertEquals(expectedDateTime, dateTime);
    }

    /**
     * Test that parser parses correctly for lowercase PM.
     */
    @Test
    public void parse_lowerCasePm_parsedDateMatchesExpected() {
        LocalDateTime dateTime = this.parser.parse("2016-10-01 9.23pm");
        LocalDateTime expectedDateTime = LocalDateTime.of(2016, 10, 01, 21, 23);
        assertEquals(expectedDateTime, dateTime);
    }
}
```
###### /java/linenux/util/ArrayListUtilTest.java
``` java
public class ArrayListUtilTest {
    ArrayList<String> list;
    @Before
    public void setupList() {
        this.list = ArrayListUtil.fromArray(new String[] {"1", "2", "3"});
    }

    @Test
    public void fromArray_arrayAsInitialValue_returnedArrayListMatchesInputArray() {
        assertEquals("1", this.list.get(0));
        assertEquals("2", this.list.get(1));
        assertEquals("3", this.list.get(2));
    }

    @Test
    public void map_modifyValues_expectedValuesInReturnedList() {
        ArrayList<String> mapped = ArrayListUtil.map(x -> x + " bla", this.list);

        assertEquals("1 bla", mapped.get(0));
        assertEquals("2 bla", mapped.get(1));
        assertEquals("3 bla", mapped.get(2));
    }

    @Test
    public void mapWithIndex_modifyValuesAndAttachIndex_expectedIndexedValuesInReturnedList() {
        ArrayList<Integer> numbers = ArrayListUtil.fromArray(new Integer[] {0, 0, 0});
        ArrayList<Integer> mapped = ArrayListUtil.mapWithIndex((x, i) -> x + i, numbers);

        assertEquals(3, mapped.size());
        assertEquals(0, (int)mapped.get(0));
        assertEquals(1, (int)mapped.get(1));
        assertEquals(2, (int)mapped.get(2));
    }

    @Test
    public void filter_filterListByValue_filteredListReturned() {
        ArrayList<String> filtered = ArrayListUtil.filter(x -> x.equals("2"), this.list);

        assertEquals(1, filtered.size());
        assertEquals("2", filtered.get(0));
    }

    @Test
    public void foldr_compressListToSingleString_concatenatedListValuesReturnedAsString() {
        String output = ArrayListUtil.foldr(String::concat, "", this.list);
        assertEquals("123", output);
    }

    @Test
    public void reverse_reverseOrderOfListElements_reversedListReturned() {
        ArrayList<String> strings = ArrayListUtil.reverse(this.list);
        assertEquals("3", strings.get(0));
        assertEquals("2", strings.get(1));
        assertEquals("1", strings.get(2));
    }

    @Test
    public void unique_repeatedValuesInList_listWithUniqueValuesReturned() {
        ArrayList<Integer> numbers = ArrayListUtil.fromArray(new Integer[]{1, 2, 2, 1, 3, 1, 3, 2});
        ArrayList<Integer> uniqueNumbers = ArrayListUtil.unique(numbers);
        assertEquals(3, uniqueNumbers.size());
    }

    public void fromSingleton_listCreatedFromSingleValue() {
        ArrayList<String> strings = ArrayListUtil.fromSingleton("hello");
        assertEquals(1, strings.size());
        assertEquals("hello", strings.get(0));
    }
}
```
###### /java/linenux/util/ChainableArrayListUtil.java
``` java
public class ChainableArrayListUtil {
    @Test
    public void initialise_arrayAsInitialValue_returnedArrayListMatchesInputArray() {
        ArrayList<String> str = new ArrayListUtil.ChainableArrayListUtil<String>(new String[] {"1", "2", "3"}).value();
        assertEquals(3, str.size());
        assertEquals("1", str.get(0));
        assertEquals("2", str.get(1));
        assertEquals("3", str.get(2));
    }

    @Test
    public void fromArray_ArrayListAsInitialValue_outputMatchesInput() {
        ArrayList<String> list = ArrayListUtil.fromArray(new String[] {"1", "2", "3"});
        ArrayList<String> output = new ArrayListUtil.ChainableArrayListUtil<String>(list).value();
        assertEquals(list, output);
    }

    @Test
    public void map_modifyValues_expectedValuesInReturnedList() {
        ArrayList<String> list = new ArrayListUtil.ChainableArrayListUtil<String>(new String[] {"1", "2", "3"})
                .map(x -> x + " bla")
                .value();
        assertEquals("1 bla", list.get(0));
        assertEquals("2 bla", list.get(1));
        assertEquals("3 bla", list.get(2));
    }

    @Test
    public void mapWithIndex_modifyValuesAndAttachIndex_expectedIndexedValuesInReturnedList() {
        ArrayList<Integer> list = new ArrayListUtil.ChainableArrayListUtil<>(new Integer[] {0, 0, 0})
                .mapWithIndex((x, i) -> x + i)
                .value();
        assertEquals(3, list.size());
        assertEquals(0, (int)list.get(0));
        assertEquals(1, (int)list.get(1));
        assertEquals(2, (int)list.get(2));
    }

    @Test
    public void filter_filterListByValue_filteredListReturned() {
        ArrayList<String> list = new ArrayListUtil.ChainableArrayListUtil<String>(new String[] {"1", "2", "3"})
                .filter(x -> x.equals("2"))
                .value();
        assertEquals(1, list.size());
        assertEquals("2", list.get(0));
    }

    @Test
    public void sort_numericalSorting_numericallySortedListReturned() {
        ArrayList<Integer> numbers = ArrayListUtil.fromArray(new Integer[] {3, 2, 4, 1});
        ArrayList<Integer> sortedNumbers = new ArrayListUtil.ChainableArrayListUtil<>(numbers)
                .sort((a, b) -> a - b)
                .value();
        assertEquals(4, sortedNumbers.size());
        assertEquals(1, (int)sortedNumbers.get(0));
        assertEquals(2, (int)sortedNumbers.get(1));
        assertEquals(3, (int)sortedNumbers.get(2));
        assertEquals(4, (int)sortedNumbers.get(3));
    }

    @Test
    public void sortyBy_stringLengthSorting_listSortedByStringLengthReturned() {
        ArrayList<String> strings = ArrayListUtil.fromArray(new String[] {"apple", "bla", "walala"});
        ArrayList<String> sortedStrings = new ArrayListUtil.ChainableArrayListUtil<>(strings)
                .sortBy(String::length)
                .value();
        assertEquals(3, sortedStrings.size());
        assertEquals("bla", sortedStrings.get(0));
        assertEquals("apple", sortedStrings.get(1));
        assertEquals("walala", sortedStrings.get(2));
    }

    @Test
    public void foldr_compressListToSingleString_concatenatedListValuesReturnedAsString() {
        String output = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"1", "2", "3"})
                .foldr(String::concat, "");
        assertEquals("123", output);
    }

    @Test
    public void foldr_listAsInitialValue_chainableArrayListUtilReturned() {
        ArrayList<String> strings = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"1", "2", "3"})
                .foldr((x, xs) -> {
                    xs.add(x);
                    return xs;
                }, new ArrayList<String>())
                .value();

        assertEquals(3, strings.size());
        assertEquals("3", strings.get(0));
        assertEquals("2", strings.get(1));
        assertEquals("1", strings.get(2));
    }

    @Test
    public void reverse_reverseOrderOfListElements_reversedListReturned() {
        ArrayList<String> strings = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"1", "2", "3"})
                .reverse()
                .value();

        assertEquals(3, strings.size());
        assertEquals("3", strings.get(0));
        assertEquals("2", strings.get(1));
        assertEquals("1", strings.get(2));
    }
}
```
###### /java/linenux/util/EitherTest.java
``` java
public class EitherTest {
    @Test
    public void getLeft_eitherWithLeftValue_expectedValueReturned() {
        Either<Integer, String> either = Either.left(1);
        assertTrue(either.isLeft());
        assertFalse(either.isRight());
        assertEquals(1, (int)either.getLeft());
    }

    @Test
    public void getRight_eitherWithRightValue_expectedValueReturned() {
        Either<Integer, String> either = Either.right("hello");
        assertFalse(either.isLeft());
        assertTrue(either.isRight());
        assertEquals("hello", either.getRight());
    }

    @Test(expected=NoSuchElementException.class)
    public void getLeft_noLeftValue_noSuchElementExceptionThrown() {
        Either.right("hello").getLeft();
    }

    @Test(expected=NoSuchElementException.class)
    public void getRight_noRightValue_noSuchElementExceptionThrown() {
        Either.left("hello").getRight();
    }

    @Test
    public void bind_bindLeftValueToLeft_leftValueModifiedAndBoundToLeft() {
        Either<Integer, Integer> either = Either.left(1);
        Either<Integer, Integer> result = either.bind(i -> Either.left(i + 1));

        assertTrue(result.isLeft());
        assertEquals(2, (int)result.getLeft());
    }

    @Test
    public void bind_bindLeftValueToRight_leftValueModifiedAndBoundToRight() {
        Either<Integer, Integer> either = Either.left(1);
        Either<Integer, Integer> result = either.bind(i -> Either.right(i + 1));

        assertTrue(result.isRight());
        assertEquals(2, (int)result.getRight());
    }

    private class MockLambda implements Function<Integer, Either<Integer, Integer>> {
        private boolean executed = false;

        @Override
        public Either<Integer, Integer> apply(Integer integer) {
            this.executed = true;
            return Either.left(integer + 1);
        }

        public boolean isExecuted() {
            return this.executed;
        }
    }

    @Test
    public void bind_bindRightValueToRight_rightValueModifiedAndBoundToRight() {
        MockLambda fn = new MockLambda();
        Either<Integer, Integer> either = Either.right(1);
        Either<Integer, Integer> result = either.bind(fn);

        assertFalse(fn.isExecuted());
        assertTrue(result.isRight());
        assertEquals(1, (int)result.getRight());
    }
}
```
###### /java/linenux/util/LocalDateTimeUtilTest.java
``` java
public class LocalDateTimeUtilTest {
    private LocalDateTime first, second;

    @Before
    public void setupLocalDateTimes() {
        this.first = LocalDateTime.of(2016, 1, 1, 0, 0);
        this.second = LocalDateTime.of(2016, 1, 1, 0, 1);
    }

    @Test
    public void min_earlierAndLaterTime_earlierTimeReturned() {
        assertEquals(first, LocalDateTimeUtil.min(first, first));
        assertEquals(first, LocalDateTimeUtil.min(first, second));
        assertEquals(first, LocalDateTimeUtil.min(second, first));
    }

    @Test
    public void max_earlierAndLaterTime_laterTimeReturned() {
        assertEquals(first, LocalDateTimeUtil.max(first, first));
        assertEquals(second, LocalDateTimeUtil.max(first, second));
        assertEquals(second, LocalDateTimeUtil.max(second, first));
    }
}
```
###### /java/linenux/util/StringsSimilarityTest.java
``` java
public class StringsSimilarityTest {
    @Test
    public void compute_twoStrings_levenshteinDistanceReturned() {
        assertEquals(5, StringsSimilarity.compute("kitten", "sitting"));
        assertEquals(0, StringsSimilarity.compute("hello", "hello"));
    }
}
```
###### /java/linenux/util/ThrowableUtilTest.java
``` java
public class ThrowableUtilTest {
    @Test
    public void getStackTrace_traceFilesGiven_outputMatchesExpectedString() {
        Throwable throwable = new Throwable("hello");
        StackTraceElement line1 = new StackTraceElement("this class", "this method", "this file", 1);
        StackTraceElement line2 = new StackTraceElement("that class", "that method", "that file", 2);
        throwable.setStackTrace(new StackTraceElement[] {line1, line2});
        String trace = ThrowableUtil.getStackTrace(throwable);

        String expectedPattern = "^java\\.lang\\.Throwable: hello\\r?\\n" +
                "\\tat this class\\.this method\\(this file:1\\)\\r?\\n" +
                "\\tat that class\\.that method\\(that file:2\\)\\r?\\n$";
        assertTrue(trace.matches(expectedPattern));
    }
}
```
