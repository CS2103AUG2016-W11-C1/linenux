# A0144915A
###### /java/linenux/command/AddCommandTest.java
``` java
public class AddCommandTest {
    private Schedule schedule;
    private AddCommand addCommand;

    @Before
    public void setupAddCommand() {
        this.schedule = new Schedule();
        this.addCommand = new AddCommand(this.schedule);
    }

```
###### /java/linenux/command/AddCommandTest.java
``` java
    /**
     * Test that respondTo is case-insensitive.
     */
    @Test
    public void testCaseInsensitiveAddTaskCommand() {
        assertTrue(this.addCommand.respondTo("AdD CS2103T Tutorial"));
    }

    /**
     * Test that respondTo will return false for commands not related to add tasks.
     */
    @Test
    public void testNotRespondToOtherCommands() {
        assertFalse(this.addCommand.respondTo("halp"));
    }

    /**
     * Test that executing the add task command will correctly add new to-do to the schedule.
     */
    @Test
    public void testExecuteAddTodo() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand.execute("add CS2103T Tutorial"));

        // The new task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        assertEquals("CS2103T Tutorial", addedTask.getTaskName());

        // The new task should not have start time
        assertNull(addedTask.getStartTime());

        // The new task should not have end time
        assertNull(addedTask.getEndTime());
    }

    /**
     * Test that executing the add task command will correctly add new deadline to the schedule.
     */
    @Test
    public void testExecuteAddDeadline() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand.execute("add CS2103T Tutorial et/2016-01-01 5:00PM"));

        // The new deadline has the correct name, start time, and end time
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertNull(addedTask.getStartTime());
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), addedTask.getEndTime());
    }

    /**
     * Test that executing the add task command will correctly add new event to the schedule.
     */
    @Test
    public void testExecuteAddEvent() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand.execute("add CS2103T Tutorial st/2016-01-01 5:00PM et/2016-01-02 5:00PM"));

        // The new event has the correct name, start time, and end time
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), addedTask.getStartTime());
        assertEquals(LocalDateTime.of(2016, 1, 2, 17, 0), addedTask.getEndTime());
    }

```
###### /java/linenux/command/AddCommandTest.java
``` java
    /**
     * Test that order of times do not matter.
     */
    @Test
    public void testExecuteAddTaggedEventIgnoringOrderOfTimes() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
                1,
                () -> this.addCommand
                        .execute("add CS2103T Tutorial #/tag 1 et/2016-01-02 5:00PM #/tag 2 st/2016-01-01 5:00PM"));

        // The new event has the correct name, start time, and end time
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task addedTask = tasks.get(tasks.size() - 1);
        ArrayList<String> tagList = addedTask.getTags();

        assertEquals("CS2103T Tutorial", addedTask.getTaskName());
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), addedTask.getStartTime());
        assertEquals(LocalDateTime.of(2016, 1, 2, 17, 0), addedTask.getEndTime());

        assertEquals(2, tagList.size());
        assertEquals("tag 1", tagList.get(0));
        assertEquals("tag 2", tagList.get(1));
    }

    /**
     * Test that executing an add task command should return the correct result.
     */
    @Test
    public void testExecuteAddCommandResult() {
        CommandResult result = this.addCommand.execute("add CS2103T Tutorial");
        assertEquals("Added CS2103T Tutorial", result.getFeedback());
    }

    /**
     * Test that adding a new deadline should return the correct result.
     */
    @Test
    public void testExecuteAddDeadlineResult() {
        CommandResult result = this.addCommand.execute("add CS2103T Tutorial et/2016-01-01 5:00PM");
        assertEquals("Added CS2103T Tutorial (Due 2016-01-01 5:00PM)", result.getFeedback());
    }

    /**
     * Test that adding a new event should return the correct result.
     */
    @Test
    public void testExecuteAddEventResult() {
        CommandResult result = this.addCommand.execute("add CS2103T Tutorial st/2016-01-01 5:00PM et/2016-01-02 5:00PM");
        assertEquals("Added CS2103T Tutorial (2016-01-01 5:00PM - 2016-01-02 5:00PM)", result.getFeedback());
    }

```
###### /java/linenux/command/AddCommandTest.java
``` java
    /**
     * Test the result when running without a task name
     *
     */
    @Test
    public void testMissingTaskNameCommandResult() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test the result when the task name consists of only empty spaces.
     */
    @Test
    public void testTaskNameIsEmptyCommandResult() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add             "));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test that task name cannot be empty.
     */
    @Test
    public void testStartTimeWithoutTaskName() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add st/2016-01-01 5:00PM"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test that task name cannot be empty.
     */
    @Test
    public void testEndTimeWithoutTaskName() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add et/2016-01-01 5:00PM"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

```
###### /java/linenux/command/AddCommandTest.java
``` java
    @Test
    public void testInvalidStartTime() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello st/yesterday et/2016-12-31 11:59PM"));

        assertEquals("Cannot parse \"yesterday\".", result.getFeedback());
    }

    /**
     * Test that invalid time formats are not accepted.
     */
    @Test
    public void testInvalidEndTime() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello et/tomorrow"));

        assertEquals("Cannot parse \"tomorrow\".", result.getFeedback());
    }

```
###### /java/linenux/command/AddCommandTest.java
``` java
    /**
     * Test that no tasks are created with start time only.
     *
     */
    @Test
    public void testStartTimeWithoutEndTime() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello st/2016-01-01 5:00PM"));

        assertEquals("Cannot create task with start time but without end time.", result.getFeedback());
    }

```
###### /java/linenux/command/AddCommandTest.java
``` java
    /**
     * Test that end time cannot be before start time.
     */
    @Test
    public void testEndTimeBeforeStartTime() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.addCommand.execute("add hello st/2016-01-02 5:00PM et/2016-01-01 5:00PM"));

        assertEquals("End time cannot come before start time.", result.getFeedback());
    }

```
###### /java/linenux/command/AliasCommandTest.java
``` java
    @Before
    public void setupAliasCommand() {
        this.schedule = new Schedule();
        this.addCommand = new AddCommand(this.schedule);
        this.deleteCommand = new DeleteCommand(this.schedule);
        this.aliasCommand = new AliasCommand(ArrayListUtil.fromArray(new Command[] {this.addCommand, this.deleteCommand}));
    }

```
###### /java/linenux/command/AliasCommandTest.java
``` java
    /**
     * Test alias creates an alias.
     */
    @Test
    public void testAliasFunctionality() {
        this.aliasCommand.execute("alias add addi");
        assertChangeBy(() -> this.schedule.getTaskList().size(), 1,
                () -> this.addCommand.execute("addi CS2103T Tutorial #/tag1 tag2"));
    }

    /**
     * Ensure that aliases can only be used once.
     */
    @Test
    public void testReusedAlias() {
        this.aliasCommand.execute("alias add addi");
        assertTrue(this.addCommand.respondTo("addi"));
        CommandResult result = this.aliasCommand.execute("alias add addi");
        String expectedFeedback = "\"addi\" is used for another command.";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    @Test
    public void testSecondCommandInList() {
        this.aliasCommand.execute("alias delete d");
        assertTrue(this.deleteCommand.respondTo("d"));
    }
}
```
###### /java/linenux/command/DeleteCommandTest.java
``` java
    @Before
    public void setupDeleteCommand() {
        this.schedule = new Schedule();
        this.deleteCommand = new DeleteCommand(this.schedule);
    }

    private void setupMultipleHelloTasksAndExecuteAmbiguousCommand() {
        this.schedule.addTask(new Task("hello world"));
        this.schedule.addTask(new Task("say hello"));
        this.deleteCommand.execute("delete hello");
    }

```
###### /java/linenux/command/DeleteCommandTest.java
``` java
    /**
     * Test that the delete command is case insensitive.
     */
    @Test
    public void testCaseInsensitiveRespondToDeleteCommand() {
        assertTrue(this.deleteCommand.respondTo("dElEte hello"));
    }

    /**
     * Test that respondTo will return false for commands not related to delete tasks.
     */
    @Test
    public void testDoesNotRespondToOtherCommands() {
        assertFalse(this.deleteCommand.respondTo("walala"));
    }

```
###### /java/linenux/command/DeleteCommandTest.java
``` java
    /**
     * Test the feedback when no match is found.
     */
    @Test
    public void testCommandResultWhenNoMatchFound() {
        this.schedule.addTask(new Task("flkasdjfaklsdfjaldf"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.execute("delete that nasty todo"));
        assertEquals("Cannot find task names with \"that nasty todo\".", result.getFeedback());
    }

```
###### /java/linenux/command/DeleteCommandTest.java
``` java
    /**
     * Test the feedback when only one match is found.
     */
    @Test
    public void testCommandResultWhenOnlyOneMatchFound() {
        this.schedule.addTask(new Task("hello"));
        this.schedule.addTask(new Task("i can' type"));
        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().size(),
                -1,
                () -> this.deleteCommand.execute("delete hello"));
        assertEquals("Deleted \"hello\".", result.getFeedback());
    }

    /**
     * Test the feedback when multiple matches are found.
     */
    @Test
    public void testCommandResultWhenMultipleMatchesFound() {
        this.schedule.addTask(new Task("hello world"));
        this.schedule.addTask(new Task("say hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.execute("delete hello"));
        assertEquals("Which one? (1-2)\n1. hello world\n2. say hello", result.getFeedback());
    }

    /**
     * Test the command is awaiting user response when multiple matches are found.
     */
    @Test
    public void testAwaitingUserResponse() {
        assertFalse(this.deleteCommand.awaitingUserResponse());
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        assertTrue(this.deleteCommand.awaitingUserResponse());
    }

    /**
     * Test that cancel works properly.
     */
    @Test
    public void testUserResponseCancel() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.userResponse("cancel"));
        assertEquals("OK! Not deleting anything.", result.getFeedback());
        assertFalse(this.deleteCommand.awaitingUserResponse());
    }

    /**
     * Test that task is deleted if user selects a valid index.
     */
    @Test
    public void testUserResponseValidIndex() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().size(),
                -1,
                () -> this.deleteCommand.userResponse("1"));
        assertEquals("Deleted \"hello world\".", result.getFeedback());
        assertFalse(this.deleteCommand.awaitingUserResponse());
    }

    /**
     * Test that task is not deleted if user selects an invalid index.
     */
    @Test
    public void testUserResponseInvalidIndex() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.userResponse("0"));
        String expectedResponse = "That's not a valid index. Enter a number between 1 and 2:\n" +
                "1. hello world\n2. say hello";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.deleteCommand.awaitingUserResponse());
    }

    /**
     * Test that task is not deleted if user types an invalid response.
     */
    @Test
    public void testUserResponseInvalidResponse() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.userResponse("roses are red"));
        String expectedResponse = "I don't understand \"roses are red\".\n" +
                "Enter a number to indicate which task to delete.\n1. hello world\n2. say hello";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.deleteCommand.awaitingUserResponse());
    }

```
###### /java/linenux/command/DoneCommandTest.java
``` java
    @Test
    public void testSearchOnlyUndoneTasks() {
        this.schedule.addTask(new Task("hello"));
        this.schedule.addTask(new Task("hello").markAsDone());

        CommandResult result = this.doneCommand.execute("done hello");
        String expectedResponse = "\"hello\" is marked as done.";

        assertEquals(expectedResponse, result.getFeedback());
    }
}
```
###### /java/linenux/command/EditReminderCommandTest.java
``` java
    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + this.editReminderCommand.getCommandFormat() + "\n\n" + Command.CALLOUTS;
    }

```
###### /java/linenux/command/EditReminderCommandTest.java
``` java
    /**
     * Test that respondTo is case-insensitive.
     */
    @Test
    public void testCaseInsensitiveEditTaskCommand() {
        assertTrue(this.editReminderCommand.respondTo("EdITr reminder n/note t/2016-01-01 5:00PM"));
    }

    /**
     * Test that respondTo will return false for commands not related to edit reminder.
     */
    @Test
    public void testNotRespondToOtherCommands() {
        assertFalse(this.editReminderCommand.respondTo("halp"));
    }

```
###### /java/linenux/command/FreeTimeCommandTest.java
``` java
public class FreeTimeCommandTest {
    FreeTimeCommand command;

    @Before
    public void setupCommand() {
        Schedule schedule = new Schedule();
        Task event1 = new Task("Event 1", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2016, 1, 1, 19, 0));
        Task event2 = new Task("Event 2", LocalDateTime.of(2016, 1, 1, 21, 0), LocalDateTime.of(2016, 1, 1, 23, 0));
        schedule.addTask(event1);
        schedule.addTask(event2);

        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));

        this.command = new FreeTimeCommand(schedule, clock);
    }

    @Test
    public void testRespondToFreetimeCommand() {
        assertTrue(this.command.respondTo("freetime"));
        assertTrue(this.command.respondTo("   freetime   "));
        assertTrue(this.command.respondTo("freetime et/2016-01-01 5:00PM"));
        assertTrue(this.command.respondTo("freetime st/2016-01-01 5:00PM et/2016-01-02 5:00PM"));
    }

    @Test
    public void testRespondToCaseInsensitivity() {
        assertTrue(this.command.respondTo("FrEetime"));
    }

    @Test
    public void testDoesNotRespondToOtherCommands() {
        assertFalse(this.command.respondTo("freetimeee"));
        assertFalse(this.command.respondTo("facetime"));
    }

    @Test
    public void testExecuteWithStartTime() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 3:00PM et/2016-01-01 11:59PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 3:00PM - 2016-01-01 5:00PM\n" +
                " - 2016-01-01 7:00PM - 2016-01-01 9:00PM\n" +
                " - 2016-01-01 11:00PM - 2016-01-01 11:59PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testExecuteWithoutStartTime() {
        CommandResult result = this.command.execute("freetime et/2016-01-01 11:59PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 3:24PM - 2016-01-01 5:00PM\n" +
                " - 2016-01-01 7:00PM - 2016-01-01 9:00PM\n" +
                " - 2016-01-01 11:00PM - 2016-01-01 11:59PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testExecuteWithInvalidTime() {
        CommandResult result = this.command.execute("freetime et/Jan 1, 16 2359");
        String expectedResult = "Cannot parse \"Jan 1, 16 2359\".";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/tomorrow et/2016-01-01 11:59PM");
        expectedResult = "Cannot parse \"tomorrow\".";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testEndTimeBeforeStartTime() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 5:00PM et/2016-01-01 4:45PM");
        String expectedResult = "End time must be after start time.";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime et/2016-01-01 3:00PM");
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testTrivialFirstEmptySlot() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 5:00PM et/2016-01-01 8:00PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 7:00PM - 2016-01-01 8:00PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testTrivialLastEmptySlot() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 3:00PM et/2016-01-01 7:00PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 3:00PM - 2016-01-01 5:00PM\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testEndTimeNotSpecified() {
        CommandResult result = this.command.execute("freetime");
        String expectedResult = "End time must be specified.";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/2016-01-01 5:00PM");
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testNoFreeTime() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 5:00PM et/2016-01-01 7:00PM");
        String expectedResult = "You are free at the following time slots:\n";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void testQueryRangeIntersectWithEvent() {
        CommandResult result = this.command.execute("freetime st/2016-01-01 6:00PM et/2016-01-01 8:00PM");
        String expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 7:00PM - 2016-01-01 8:00PM\n";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/2016-01-01 4:00PM et/2016-01-01 6:00PM");
        expectedResult = "You are free at the following time slots:\n" +
                " - 2016-01-01 4:00PM - 2016-01-01 5:00PM\n";
        assertEquals(expectedResult, result.getFeedback());

        result = this.command.execute("freetime st/2016-01-01 5:30PM et/2016-01-01 6:30PM");
        expectedResult = "You are free at the following time slots:\n";
        assertEquals(expectedResult, result.getFeedback());
    }
}
```
###### /java/linenux/command/InvalidCommandTest.java
``` java
    @Before
    public void setupInvalidCommand() {
        ArrayList<Command> commands = new ArrayList<>();
        commands.add(new ListCommand());
        commands.add(new ExitCommand());
        this.invalidCommand = new InvalidCommand(commands);
    }

    /**
     * Test correct response with suggestions.
     */
    @Test
    public void testResponseWithSuggestion() {
        CommandResult result = this.invalidCommand.execute("eit");
        assertEquals("Invalid command. Did you mean exit?", result.getFeedback());
    }

    /**
     * Test correct response without any suggestions.
     */
    @Test
    public void testResponseWithoutSuggestions() {
        this.invalidCommand = new InvalidCommand(new ArrayList<>());
        CommandResult result = this.invalidCommand.execute("eit");
        assertEquals("Invalid command.", result.getFeedback());
    }

    private static class BaseMockCommand extends AbstractCommand {
        @Override
        public String getTriggerWord() {
            return null;
        }

        @Override
        public String getDescription() {
            return null;
        }

```
###### /java/linenux/command/InvalidCommandTest.java
``` java
        @Override
        public boolean respondTo(String input) {
            return true;
        }

        @Override
        public CommandResult execute(String input) {
            return null;
        }

```
###### /java/linenux/command/InvalidCommandTest.java
``` java
    private static class ListCommand extends BaseMockCommand {
        @Override
        public String getTriggerWord() {
            return "List";
        }
    }

    private static class ExitCommand extends BaseMockCommand {
        @Override
        public String getTriggerWord() {
            return "exit";
        }
    }
}
```
###### /java/linenux/command/ListCommandTest.java
``` java
    @Before
    public void setupListCommand() {
        this.schedule = new Schedule();
        this.listCommand = new ListCommand(this.schedule);
    }

    /**
     * Test list all.
     */
    @Test
    public void testRespondToListWithoutParams() {
        assertTrue(this.listCommand.respondTo("list"));
    }

    /**
     * Test search function in list.
     */
    @Test
    public void testRespondToListWithKeywords() {
        assertTrue(this.listCommand.respondTo("list bla"));
    }

    /**
     * Test that list command is case insenstive.
     */
    @Test
    public void testCaseInsensitiveRespondToList() {
        assertTrue(this.listCommand.respondTo("LiSt"));
    }

    /**
     * Test that list command does not respond to other commands.
     */
    @Test
    public void testDoesNotRespondToOtherCommands() {
        assertFalse(this.listCommand.respondTo("whaddup"));
    }

    /**
     * Test that list without params should display all tasks and reminders
     */
    @Test
    public void testDisplayTheEntireList() {
        this.schedule.addTask(new Task("First Task"));
        this.schedule.addTask(new Task("Second Task"));
        this.schedule.addTask(new Task("Deadline", null, LocalDateTime.of(2016, 1, 1, 17, 0)));
        this.schedule.addTask(new Task("Event", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2016, 1, 1, 18, 0)));

        Task taskWithReminder = new Task("Task with Reminder");
        taskWithReminder = taskWithReminder.addReminder(new Reminder("Reminder", LocalDateTime.of(2016, 2, 1, 17, 0)));
        this.schedule.addTask(taskWithReminder);

        CommandResult result = this.listCommand.execute("list");

        String expectedFeedback = "Reminders:\n"
                + "1. Reminder (On 2016-02-01 5:00PM)";
        assertEquals(expectedFeedback, result.getFeedback());
    }

```
###### /java/linenux/command/parser/GenericParserTest.java
``` java
public class GenericParserTest {
    private GenericParser parser;

    @Before
    public void setupParser() {
        this.parser = new GenericParser();
    }

    @Test
    public void testKeywordsWithoutFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello world");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void testTrimKeywordsWithoutFlags() {
        GenericParser.GenericParserResult result = parser.parse("   hello world    ");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void testKeywordsWithFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/12345");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void testTrimKeywordsWithFlags() {
        GenericParser.GenericParserResult result = parser.parse("  hello world      st/12345");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void testExtractFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/12345");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("12345", flagValues.get(0));
    }

    @Test
    public void testExtractRepeatedFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/12345 st/67890");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(2, flagValues.size());
        assertEquals("12345", flagValues.get(0));
        assertEquals("67890", flagValues.get(1));
    }

    @Test
    public void testRepeatedButSeparatedFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/1 et/2 st/3");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(2, flagValues.size());
        assertEquals("1", flagValues.get(0));
        assertEquals("3", flagValues.get(1));
        flagValues = result.getArguments("et");
        assertEquals(1, flagValues.size());
        assertEquals("2", flagValues.get(0));
    }

    @Test
    public void testNonWordFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello world #/yo #/foo");
        ArrayList<String> flagValues = result.getArguments("#");
        assertEquals(2, flagValues.size());
        assertEquals("yo", flagValues.get(0));
        assertEquals("foo", flagValues.get(1));
    }

    @Test
    public void testMultiwordsFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/Jan 1 et/Jan 2");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("Jan 1", flagValues.get(0));
        flagValues = result.getArguments("et");
        assertEquals(1, flagValues.size());
        assertEquals("Jan 2", flagValues.get(0));
    }

    @Test
    public void testEmptyFlags() {
        GenericParser.GenericParserResult result = parser.parse("hello st/");
        assertEquals("hello", result.getKeywords());
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("", flagValues.get(0));
    }

    @Test
    public void testEmptyFlagFollowBySomething() {
        GenericParser.GenericParserResult result = parser.parse("hello st/  et/12345");
        assertEquals("hello", result.getKeywords());
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("", flagValues.get(0));
        flagValues = result.getArguments("et");
        assertEquals(1, flagValues.size());
        assertEquals("12345", flagValues.get(0));
    }

    @Test
    public void testFlagValueContainsSlash() {
        GenericParser.GenericParserResult result = parser.parse("hello st/2016/01/01");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("2016/01/01", flagValues.get(0));
    }

    @Test
    public void testLastFlagValueWithTrailingSpaces() {
        GenericParser.GenericParserResult result = parser.parse("hello st/12345       ");
        ArrayList<String> flagValue = result.getArguments("st");
        assertEquals(1, flagValue.size());
        assertEquals("12345", flagValue.get(0));
    }

    @Test
    public void testEmptyKeywords() {
        GenericParser.GenericParserResult result = parser.parse("st/12345");
        assertEquals("", result.getKeywords());
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("12345", flagValues.get(0));
    }
}
```
###### /java/linenux/command/RemindCommandTest.java
``` java
    @Before
    public void setupRemindCommand() {
        Task todo = new Task("Todo");
        Task deadline = new Task("Deadline", LocalDateTime.of(2016, 1, 1, 1, 0));
        Task event = new Task("Event", LocalDateTime.of(2016, 1, 1, 1, 0), LocalDateTime.of(2016, 1, 1, 13, 0));

        this.schedule = new Schedule();
        this.schedule.addTask(todo);
        this.schedule.addTask(deadline);
        this.schedule.addTask(event);
        this.remindCommand = new RemindCommand(this.schedule);
    }

```
###### /java/linenux/command/RemindCommandTest.java
``` java
    private int totalNumberOfReminders() {
        return new ArrayListUtil.ChainableArrayListUtil<>(this.schedule.getTaskList())
                .map(Task::getReminders)
                .map(ArrayList::size)
                .foldr(Integer::sum, 0);
    }
}
```
###### /java/linenux/command/TodayCommandTest.java
``` java
public class TodayCommandTest {
    private TodayCommand todayCommand;

    private Schedule schedule;
    private Task todo;
    private Task deadlineToday;
    private Task deadlineTomorrow;
    private Task eventYesterday;
    private Task eventTomorrow;
    private Task eventYesterdayToday;
    private Task eventTodayTomorrow;

    @Before
    public void setupCommand() {
        this.schedule = new Schedule();
        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));
        this.todayCommand = new TodayCommand(this.schedule, clock);

        this.todo = new Task("hello");
        this.deadlineToday = new Task("deadline 1", LocalDateTime.of(2016, 1, 1, 21, 0));
        this.deadlineTomorrow = new Task("deadline 2", LocalDateTime.of(2016, 1, 2, 21, 0));
        this.eventYesterday = new Task("event 1", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2015, 12, 31, 12, 0));
        this.eventTomorrow = new Task("event 2", LocalDateTime.of(2016, 1, 2, 10, 0), LocalDateTime.of(2016, 1, 2, 12, 0));
        this.eventYesterdayToday = new Task("event 3", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2016, 1, 1, 10, 0));
        this.eventTodayTomorrow = new Task("event 4", LocalDateTime.of(2016, 1, 1, 10, 0), LocalDateTime.of(2016, 1, 2, 10, 0));

        this.schedule.addTask(this.todo);
        this.schedule.addTask(this.deadlineToday);
        this.schedule.addTask(this.deadlineTomorrow);
        this.schedule.addTask(this.eventYesterday);
        this.schedule.addTask(this.eventTomorrow);
        this.schedule.addTask(this.eventYesterdayToday);
        this.schedule.addTask(this.eventTodayTomorrow);
    }

    @Test
    public void testRespondTo() {
        assertTrue(this.todayCommand.respondTo("today"));
        assertTrue(this.todayCommand.respondTo("today hello"));
        assertTrue(this.todayCommand.respondTo("toDay"));
    }

    @Test
    public void testNotRespondTo() {
        assertFalse(this.todayCommand.respondTo("atoday"));
        assertFalse(this.todayCommand.respondTo("todaya"));
        assertFalse(this.todayCommand.respondTo("toda"));
    }

    @Test
    public void testExecute() {
        this.todayCommand.execute("today");
        assertTrue(this.schedule.getFilteredTasks().contains(this.todo));
        assertTrue(this.schedule.getFilteredTasks().contains(this.deadlineToday));
        assertFalse(this.schedule.getFilteredTasks().contains(this.deadlineTomorrow));
        assertFalse(this.schedule.getFilteredTasks().contains(this.eventYesterday));
        assertFalse(this.schedule.getFilteredTasks().contains(this.eventTomorrow));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventYesterdayToday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventTodayTomorrow));
    }
}
```
###### /java/linenux/command/TomorrowCommandTest.java
``` java
public class TomorrowCommandTest {
    private TomorrowCommand tomorrowCommand;

    private Schedule schedule;
    private Task todo;
    private Task deadlineToday;
    private Task deadlineTomorrow;
    private Task eventYesterday;
    private Task eventTomorrow;
    private Task eventYesterdayToday;
    private Task eventTodayTomorrow;

    @Before
    public void setupCommand() {
        this.schedule = new Schedule();
        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));
        this.tomorrowCommand = new TomorrowCommand(this.schedule, clock);

        this.todo = new Task("hello");
        this.deadlineToday = new Task("deadline 1", LocalDateTime.of(2016, 1, 1, 21, 0));
        this.deadlineTomorrow = new Task("deadline 2", LocalDateTime.of(2016, 1, 2, 21, 0));
        this.eventYesterday = new Task("event 1", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2015, 12, 31, 12, 0));
        this.eventTomorrow = new Task("event 2", LocalDateTime.of(2016, 1, 2, 10, 0), LocalDateTime.of(2016, 1, 2, 12, 0));
        this.eventYesterdayToday = new Task("event 3", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2016, 1, 1, 10, 0));
        this.eventTodayTomorrow = new Task("event 4", LocalDateTime.of(2016, 1, 1, 10, 0), LocalDateTime.of(2016, 1, 2, 10, 0));

        this.schedule.addTask(this.todo);
        this.schedule.addTask(this.deadlineToday);
        this.schedule.addTask(this.deadlineTomorrow);
        this.schedule.addTask(this.eventYesterday);
        this.schedule.addTask(this.eventTomorrow);
        this.schedule.addTask(this.eventYesterdayToday);
        this.schedule.addTask(this.eventTodayTomorrow);
    }

    @Test
    public void testRespondTo() {
        assertTrue(this.tomorrowCommand.respondTo("tomorrow"));
        assertTrue(this.tomorrowCommand.respondTo("tomorrow bla"));
        assertTrue(this.tomorrowCommand.respondTo("toMorrow"));
    }

    @Test
    public void testNotRespondTo() {
        assertFalse(this.tomorrowCommand.respondTo("tomorrowa"));
        assertFalse(this.tomorrowCommand.respondTo("atomorrow"));
        assertFalse(this.tomorrowCommand.respondTo("tomorro"));
    }

    @Test
    public void testExecute() {
        this.tomorrowCommand.execute("tomorrow");

        assertTrue(this.schedule.getFilteredTasks().contains(this.todo));
        assertFalse(this.schedule.getFilteredTasks().contains(this.deadlineToday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.deadlineTomorrow));
        assertFalse(this.schedule.getFilteredTasks().contains(this.eventYesterday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventTomorrow));
        assertFalse(this.schedule.getFilteredTasks().contains(this.eventYesterdayToday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventTodayTomorrow));
    }
}
```
###### /java/linenux/command/UnaliasCommandTest.java
``` java
public class UnaliasCommandTest {
    private Schedule schedule;
    private AddCommand addCommand;
    private DeleteCommand deleteCommand;
    private UnaliasCommand unaliasCommand;

    @Before
    public void setupCommands() {
        this.schedule = new Schedule();
        this.addCommand = new AddCommand(this.schedule);
        this.deleteCommand = new DeleteCommand(this.schedule);
        this.unaliasCommand = new UnaliasCommand(ArrayListUtil.fromArray(new Command[] {this.addCommand, this.deleteCommand}));

        this.addCommand.setAlias("a");
    }

    @Test
    public void testRespondTo() {
        assertTrue(this.unaliasCommand.respondTo("unalias"));
        assertTrue(this.unaliasCommand.respondTo("unalias bla"));
        assertTrue(this.unaliasCommand.respondTo("unalias foo bar"));
        assertTrue(this.unaliasCommand.respondTo("uNaLiaS"));
    }

    @Test
    public void testNotRespondTo() {
        assertFalse(this.unaliasCommand.respondTo("notalias"));
        assertFalse(this.unaliasCommand.respondTo("aunalias"));
        assertFalse(this.unaliasCommand.respondTo("unaliasa"));
    }

    @Test
    public void testUnaliasingPreviousAlias() {
        assertTrue(this.addCommand.respondTo("a"));
        CommandResult result = this.unaliasCommand.execute("unalias a");
        String expectedResult = "\"a\" is removed as an alias.";
        assertEquals(expectedResult, result.getFeedback());
        assertFalse(this.addCommand.respondTo("a"));
    }

    @Test
    public void testUnaliasingNonExistentAlias() {
        CommandResult result = this.unaliasCommand.execute("unalias b");
        String expectedResult = "\"b\" is not an alias.";
        assertEquals(expectedResult, result.getFeedback());
        assertTrue(this.addCommand.respondTo("a"));
        assertTrue(this.addCommand.respondTo("add"));
    }

    @Test
    public void testUnaliasingDefaultCommand() {
        CommandResult result = this.unaliasCommand.execute("unalias delete");
        String expectedResult = "\"delete\" cannot be removed as an alias.";
        assertEquals(expectedResult, result.getFeedback());
    }
}
```
###### /java/linenux/control/TimeParserManagerTest.java
``` java
/**
 * JUnit test for time parser manager.
 */
public class TimeParserManagerTest {
    /**
     * Test that parses can correctly parse.
     */
    @Test
    public void testCanParse() {
        TimeParser trueParser = new TimeParser() {
            @Override
            public boolean respondTo(String u) {
                return true;
            }

            @Override
            public LocalDateTime parse(String u) {
                return null;
            }
        };

        TimeParser falseParser = new TimeParser() {
            @Override
            public boolean respondTo(String u) {
                return false;
            }

            @Override
            public LocalDateTime parse(String u) {
                return null;
            }
        };

        TimeParserManager manager = new TimeParserManager(falseParser);
        assertFalse(manager.canParse("123123"));

        manager = new TimeParserManager(falseParser, trueParser);
        assertTrue(manager.canParse("1231231"));
    }
}
```
###### /java/linenux/gui/AddTaskTest.java
``` java
public class AddTaskTest extends GuiTest {
    @Test
    public void testAddTodo() {
        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());

        robot.clickOn("#textField");
        robot.write("add hello\n");

        verifyThat("#todosList", hasItems(1));
        verifyThat("#todosList", hasCellLabelled("hello"));
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());
    }

    @Test
    public void testMarkTodoAsDone() {
        robot.clickOn("#textField");
        robot.write("add hello\n");
        robot.write("add world\n");

        verifyThat("#todosList", hasItems(2));
        verifyThat("#todosList", hasCellLabelled("hello"));
        verifyThat("#todosList", hasCellLabelled("world"));

        robot.write("done hello\n");

        verifyThat("#todosList", hasItems(1));
        verifyThat("#todosList", hasCellLabelled("world"));
    }

    @Test
    public void testAddDeadline() {
        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());

        robot.clickOn("#textField");
        robot.write("add deadline et/2016-01-01 5:00PM\n");

        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", hasItems(1));
        verifyThat("#deadlinesList", hasCellLabelled("deadline (Due 2016-01-01 5:00PM)"));
        verifyThat("#eventsList", isEmpty());
    }

    @Test
    public void testMarkDeadlineAsDone() {
        robot.clickOn("#textField");
        robot.write("add deadline et/2016-01-01 5:00PM\n");
        robot.write("add another et/2016-02-01 5:00PM\n");

        verifyThat("#deadlinesList", hasItems(2));

        robot.write("done deadline\n");

        verifyThat("#deadlinesList", hasItems(1));
        verifyThat("#deadlinesList", hasCellLabelled("another (Due 2016-02-01 5:00PM)"));
    }

    @Test
    public void testAddEvent() {
        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", isEmpty());

        robot.clickOn("#textField");
        robot.write("add event st/2016-01-01 5:00PM et/2016-01-01 7:00PM\n");

        verifyThat("#todosList", isEmpty());
        verifyThat("#deadlinesList", isEmpty());
        verifyThat("#eventsList", hasItems(1));
        verifyThat("#eventsList", hasCellLabelled("event (2016-01-01 5:00PM - 2016-01-01 7:00PM)"));
    }
}
```
###### /java/linenux/gui/CommandHistoryTest.java
``` java
public class CommandHistoryTest extends GuiTest {
    @Test
    public void testUpKeyPreviousCommand() {
        robot.write("add hello\n");
        robot.write("add world\n");

        robot.pressAndRelease(KeyCode.UP);
        verifyThat("#textField", textFieldHasText("add world"));

        robot.pressAndRelease(KeyCode.UP);
        verifyThat("#textField", textFieldHasText("add hello"));

        robot.pressAndRelease(KeyCode.DOWN);
        robot.sleep(1);
        verifyThat("#textField", textFieldHasText("add world"));

        robot.pressAndRelease(KeyCode.DOWN);
        robot.sleep(1);
        verifyThat("#textField", textFieldHasText(""));
    }
}
```
###### /java/linenux/gui/DefaultFocusTest.java
``` java
public class DefaultFocusTest extends GuiTest {
    @Test
    public void testCommandBoxDefaultFocus() {
        verifyThat("#textField", isFocused());
    }
}
```
###### /java/linenux/gui/GuiTest.java
``` java
public abstract class GuiTest {
    protected BetterRobot robot;
    private Path tempDir;

    @Before
    public void setup() throws Exception {
        tempDir = Files.createTempDirectory("tmp");

        FxToolkit.registerPrimaryStage();
        FxToolkit.setupApplication(() -> {
            String configPath = tempDir.resolve("config.json").toString();
            String schedulePath = tempDir.resolve("schedule.xml").toString();
            return new TestMain(configPath, schedulePath);
        });
        FxToolkit.showStage();
        this.robot = new BetterRobot();
    }

    @After
    public void teardown() {
        tempDir.resolve("config.json").toFile().delete();
        tempDir.resolve("schedule.xml").toFile().delete();
        tempDir.toFile().delete();
    }

    public static class TestMain extends Main {
        public static void main(String args) {
            launch(args);
        }

        public TestMain(String configFilePath, String scheduleFilePath) {
            super();
            this.config = new Config(configFilePath, scheduleFilePath);
        }
    }
}
```
###### /java/linenux/helpers/Assert.java
``` java
/**
 * More assertions to make life (testing) easier.
 *
 * Most of these assertions can be overloaded to deal with different data types.
 */
public class Assert {
    /**
     * Assert that an integer value (supplied by {@code supplier}) does not change after performing
     * the {@code action}.
     * @param supplier Supplies the integer value to test.
     * @param action The action to perform.
     * @param <R> The return type of {@code action}.
     * @return The return value of {@code action}. This is useful to test the return value of {@code action}.
     */
    public static <R> R assertNoChange(IntSupplier supplier, Supplier<R> action) {
        return assertChangeBy(supplier, 0, action);
    }

    /**
     * Assert that an integer value (supplied by {@code supplier}) changes by {@code delta} after performing
     * the {@code action}. In other words, the final value should be the initial value + {@code delta}.
     * @param supplier Supplies the integer value to test.
     * @param delta The expected change.
     * @param action The action to perform.
     * @param <R> The return type of {@code action}.
     * @return The return value of {@code action}.
     */
    public static <R> R assertChangeBy(IntSupplier supplier, int delta, Supplier<R> action) {
        int before = supplier.getAsInt();
        R output = action.get();
        int after = supplier.getAsInt();
        assertEquals(before + delta, after);
        return output;
    }
}
```
###### /java/linenux/helpers/BetterRobot.java
``` java
public class BetterRobot extends FxRobot {
    public void pressAndRelease(KeyCode key) {
        this.press(key);
        this.release(key);
    }
}
```
###### /java/linenux/helpers/GuiMatchers.java
``` java
public class GuiMatchers {
    public static Matcher<Node> hasCellLabelled(String label) {
        return typeSafeMatcher(ListView.class, label, node -> listHasCellLabelled(node, label));
    }

    private static boolean listHasCellLabelled(ListView node, String label) {
        NodeFinder finder = FxAssert.assertContext().getNodeFinder();
        NodeQuery query = finder.from(node);
        return query.lookup(".list-cell")
                .<Cell>match(cell -> !cell.isEmpty() && cell.getText().equals(label))
                .tryQuery()
                .isPresent();
    }

    public static Matcher<Node> isFocused() {
        return baseMatcher("is focused", node -> node.focusedProperty().get());
    }

    public static Matcher<Node> textFieldHasText(String text) {
        return typeSafeMatcher(TextField.class, text, node -> node.getText().equals(text));
    }
}
```
###### /java/linenux/model/ScheduleTest.java
``` java
    @Before
    public void setupSchedule() {
        this.schedule = new Schedule();
    }

    @Test
    public void testAddTask() {
        int beforeSize = this.schedule.getTaskList().size();
        this.schedule.addTask(new Task("bla"));
        int afterSize = this.schedule.getTaskList().size();

        assertEquals(beforeSize + 1, afterSize);
    }

```
###### /java/linenux/model/ScheduleTest.java
``` java
    @Test
    public void testSearch() {
        String[] keywords = {"hello", "WoRlD"};
        Task match1 = new Task("Say Hello");
        Task match2 = new Task("Around the world");
        Task mismatch = new Task("meh");

        this.schedule.addTask(match1);
        this.schedule.addTask(mismatch);
        this.schedule.addTask(match2);

        ArrayList<Task> tasks = this.schedule.search(keywords);

        assertEquals(2, tasks.size());
    }

```
###### /java/linenux/model/ScheduleTest.java
``` java
    @Test
    public void testDelete() {
        Task task = new Task("bla");
        this.schedule.addTask(task);
        int beforeSize = this.schedule.getTaskList().size();
        this.schedule.deleteTask(task);
        int afterSize = this.schedule.getTaskList().size();

        assertEquals(beforeSize - 1, afterSize);
        assertTrue(this.schedule.getTaskList().indexOf(task) == -1);
    }

```
###### /java/linenux/model/TaskTest.java
``` java
    /**
     * Test that todo task is correctly labeled.
     */
    @Test
    public void testIsTodo() {
        Task task = new Task("bla", null, null, new ArrayList<String>());
        assertTrue(task.isTodo());
        assertFalse(task.isDeadline());
        assertFalse(task.isEvent());
    }

```
###### /java/linenux/model/TaskTest.java
``` java
    /**
     * Test that deadline task is correctly labeled.
     */
    @Test
    public void testIsDeadline() {
        Task task = new Task("bla", null, LocalDateTime.of(2016, 1, 1, 0, 0));
        assertTrue(task.isDeadline());
        assertFalse(task.isTodo());
        assertFalse(task.isEvent());
    }

    /**
     * Test that event task is correctly labeled.
     */
    @Test
    public void testIsEvent() {
        Task task = new Task("bla", LocalDateTime.of(2016, 1, 1, 0, 0), LocalDateTime.of(2016, 1, 1, 0, 0));
        assertTrue(task.isEvent());
        assertFalse(task.isTodo());
        assertFalse(task.isDeadline());
    }

    /**
     * Test that todo task is correctly converted to string.
     */
    @Test
    public void testTodoToString() {
        Task task = new Task("hello", null, null, new ArrayList<String>());
        assertEquals("hello", task.toString());
    }

    /**
     * Test that deadline task is correctly converted to string.
     */
    @Test
    public void testDeadlineToString() {
        Task task = new Task("hello", null, LocalDateTime.of(2016, 1, 1, 17, 0));
        assertEquals("hello (Due 2016-01-01 5:00PM)", task.toString());
    }

    /**
     * Test that event task is correctly converted to string.
     */
    @Test
    public void testEventToString() {
        Task task = new Task("hello", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2016, 1, 2, 17, 0));
        assertEquals("hello (2016-01-01 5:00PM - 2016-01-02 5:00PM)", task.toString());
    }

```
###### /java/linenux/time/parser/ISODateWithTimeParserTest.java
``` java
/**
 * JUnit test for ISODateWithTime time format.
 */
public class ISODateWithTimeParserTest {
    TimeParser parser;

    @Before
    public void setupParser() {
        this.parser = new ISODateWithTimeParser();
    }

    /**
     * Test that parser responds to valid format.
     */
    @Test
    public void testRespondToValidFormat() {
        assertTrue(this.parser.respondTo("2016-10-01 2:05PM"));
    }

    /**
     * Test that parser responds to lowercase am and pm.
     */
    @Test
    public void testRespondToSmallAmPm() {
        assertTrue(this.parser.respondTo("2016-10-01 2:05am"));
    }

    /**
     * Test that parser responds to invalid format.
     */
    @Test
    public void testDoesNotRespondToInValidFormat() {
        assertFalse(this.parser.respondTo("Jan 1, 2016 2:05PM"));
        assertFalse(this.parser.respondTo("yesterday"));
        assertFalse(this.parser.respondTo("2:05PM"));
        assertFalse(this.parser.respondTo("2016-01-01"));
        assertFalse(this.parser.respondTo("2016-01-01 14:00"));
    }

    /**
     * Test that parser parses correctly for uppercase AM.
     */
    @Test
    public void testParseAM() {
        LocalDateTime dateTime = this.parser.parse("2016-10-01 9:23AM");
        LocalDateTime expectedDateTime = LocalDateTime.of(2016, 10, 01, 9, 23);
        assertEquals(expectedDateTime, dateTime);
    }

    /**
     * Test that parser parses correctly for uppercase PM.
     */
    @Test
    public void testParsePM() {
        LocalDateTime dateTime = this.parser.parse("2016-10-01 2:05PM");
        LocalDateTime expectedDateTime = LocalDateTime.of(2016, 10, 01, 14, 5);
        assertEquals(expectedDateTime, dateTime);
    }

    /**
     * Test that parser parses correctly for lowercase AM.
     */
    @Test
    public void testParseSmallAm() {
        LocalDateTime dateTime = this.parser.parse("2016-10-01 9:23am");
        LocalDateTime expectedDateTime = LocalDateTime.of(2016, 10, 01, 9, 23);
        assertEquals(expectedDateTime, dateTime);
    }
}
```
###### /java/linenux/util/ArrayListUtilTest.java
``` java
public class ArrayListUtilTest {
    ArrayList<String> list;
    @Before
    public void setupList() {
        this.list = ArrayListUtil.fromArray(new String[] {"1", "2", "3"});
    }

    @Test
    public void testFromArray() {
        assertEquals("1", this.list.get(0));
        assertEquals("2", this.list.get(1));
        assertEquals("3", this.list.get(2));
    }

    @Test
    public void testMap() {
        ArrayList<String> mapped = ArrayListUtil.map(x -> x + " bla", this.list);

        assertEquals("1 bla", mapped.get(0));
        assertEquals("2 bla", mapped.get(1));
        assertEquals("3 bla", mapped.get(2));
    }

    @Test
    public void testFilter() {
        ArrayList<String> filtered = ArrayListUtil.filter(x -> x.equals("2"), this.list);

        assertEquals(1, filtered.size());
        assertEquals("2", filtered.get(0));
    }

    @Test
    public void testReduce() {
        String output = ArrayListUtil.foldr(String::concat, "", this.list);
        assertEquals("123", output);
    }

    @Test
    public void testReverse() {
        ArrayList<String> strings = ArrayListUtil.reverse(this.list);
        assertEquals("3", strings.get(0));
        assertEquals("2", strings.get(1));
        assertEquals("1", strings.get(2));
    }

    @Test
    public void testUnique() {
        ArrayList<Integer> numbers = ArrayListUtil.fromArray(new Integer[]{1, 2, 2, 1, 3, 1, 3, 2});
        ArrayList<Integer> uniqueNumbers = ArrayListUtil.unique(numbers);
        assertEquals(3, uniqueNumbers.size());
    }

    public void testFromSingleton() {
        ArrayList<String> strings = ArrayListUtil.fromSingleton("hello");
        assertEquals(1, strings.size());
        assertEquals("hello", strings.get(0));
    }
}
```
###### /java/linenux/util/ChainableArrayListUtil.java
``` java
public class ChainableArrayListUtil {
    @Test
    public void testConstructFromArray() {
        ArrayList<String> str = new ArrayListUtil.ChainableArrayListUtil<String>(new String[] {"1", "2", "3"}).value();
        assertEquals(3, str.size());
        assertEquals("1", str.get(0));
        assertEquals("2", str.get(1));
        assertEquals("3", str.get(2));
    }

    @Test
    public void testConstructFromArrayList() {
        ArrayList<String> list = ArrayListUtil.fromArray(new String[] {"1", "2", "3"});
        ArrayList<String> output = new ArrayListUtil.ChainableArrayListUtil<String>(list).value();
        assertEquals(list, output);
    }

    @Test
    public void testMap() {
        ArrayList<String> list = new ArrayListUtil.ChainableArrayListUtil<String>(new String[] {"1", "2", "3"})
                .map(x -> x + " bla")
                .value();
        assertEquals("1 bla", list.get(0));
        assertEquals("2 bla", list.get(1));
        assertEquals("3 bla", list.get(2));
    }

    @Test
    public void testFilter() {
        ArrayList<String> list = new ArrayListUtil.ChainableArrayListUtil<String>(new String[] {"1", "2", "3"})
                .filter(x -> x.equals("2"))
                .value();
        assertEquals(1, list.size());
        assertEquals("2", list.get(0));
    }

    @Test
    public void testSort() {
        ArrayList<Integer> numbers = ArrayListUtil.fromArray(new Integer[] {3, 2, 4, 1});
        ArrayList<Integer> sortedNumbers = new ArrayListUtil.ChainableArrayListUtil<>(numbers)
                .sort((a, b) -> a - b)
                .value();
        assertEquals(4, sortedNumbers.size());
        assertEquals(1, (int)sortedNumbers.get(0));
        assertEquals(2, (int)sortedNumbers.get(1));
        assertEquals(3, (int)sortedNumbers.get(2));
        assertEquals(4, (int)sortedNumbers.get(3));
    }

    @Test
    public void testSortBy() {
        ArrayList<String> strings = ArrayListUtil.fromArray(new String[] {"apple", "bla", "walala"});
        ArrayList<String> sortedStrings = new ArrayListUtil.ChainableArrayListUtil<>(strings)
                .sortBy(String::length)
                .value();
        assertEquals(3, sortedStrings.size());
        assertEquals("bla", sortedStrings.get(0));
        assertEquals("apple", sortedStrings.get(1));
        assertEquals("walala", sortedStrings.get(2));
    }

    @Test
    public void testFoldr() {
        String output = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"1", "2", "3"})
                .foldr(String::concat, "");
        assertEquals("123", output);
    }

    @Test
    public void testSpecialFoldr() {
        ArrayList<String> strings = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"1", "2", "3"})
                .foldr((x, xs) -> {
                    xs.add(x);
                    return xs;
                }, new ArrayList<String>())
                .value();

        assertEquals(3, strings.size());
        assertEquals("3", strings.get(0));
        assertEquals("2", strings.get(1));
        assertEquals("1", strings.get(2));
    }

    @Test
    public void testReverse() {
        ArrayList<String> strings = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"1", "2", "3"})
                .reverse()
                .value();

        assertEquals(3, strings.size());
        assertEquals("3", strings.get(0));
        assertEquals("2", strings.get(1));
        assertEquals("1", strings.get(2));
    }
}
```
###### /java/linenux/util/EitherTest.java
``` java
public class EitherTest {
    @Test
    public void testLeft() {
        Either<Integer, String> either = Either.left(1);
        assertTrue(either.isLeft());
        assertFalse(either.isRight());
        assertEquals(1, (int)either.getLeft());
    }

    @Test
    public void testRight() {
        Either<Integer, String> either = Either.right("hello");
        assertFalse(either.isLeft());
        assertTrue(either.isRight());
        assertEquals("hello", either.getRight());
    }

    @Test(expected=NoSuchElementException.class)
    public void testGetLeftShouldThrow() {
        Either.right("hello").getLeft();
    }

    @Test(expected=NoSuchElementException.class)
    public void testGetRightShouldThrow() {
        Either.left("hello").getRight();
    }

    @Test
    public void testIsLeftBindReturnsLeft() {
        Either<Integer, Integer> either = Either.left(1);
        Either<Integer, Integer> result = either.bind(i -> Either.left(i + 1));

        assertTrue(result.isLeft());
        assertEquals(2, (int)result.getLeft());
    }

    @Test
    public void testIsLeftBindReturnsRight() {
        Either<Integer, Integer> either = Either.left(1);
        Either<Integer, Integer> result = either.bind(i -> Either.right(i + 1));

        assertTrue(result.isRight());
        assertEquals(2, (int)result.getRight());
    }

    private class MockLambda implements Function<Integer, Either<Integer, Integer>> {
        private boolean executed = false;

        @Override
        public Either<Integer, Integer> apply(Integer integer) {
            this.executed = true;
            return Either.left(integer + 1);
        }

        public boolean isExecuted() {
            return this.executed;
        }
    }

    @Test
    public void testIsRightBind() {
        MockLambda fn = new MockLambda();
        Either<Integer, Integer> either = Either.right(1);
        Either<Integer, Integer> result = either.bind(fn);

        assertFalse(fn.isExecuted());
        assertTrue(result.isRight());
        assertEquals(1, (int)result.getRight());
    }
}
```
###### /java/linenux/util/LocalDateTimeUtilTest.java
``` java
public class LocalDateTimeUtilTest {
    private LocalDateTime first, second;

    @Before
    public void setupLocalDateTimes() {
        this.first = LocalDateTime.of(2016, 1, 1, 0, 0);
        this.second = LocalDateTime.of(2016, 1, 1, 0, 1);
    }

    @Test
    public void testMin() {
        assertEquals(first, LocalDateTimeUtil.min(first, first));
        assertEquals(first, LocalDateTimeUtil.min(first, second));
        assertEquals(first, LocalDateTimeUtil.min(second, first));
    }

    @Test
    public void testMax() {
        assertEquals(first, LocalDateTimeUtil.max(first, first));
        assertEquals(second, LocalDateTimeUtil.max(first, second));
        assertEquals(second, LocalDateTimeUtil.max(second, first));
    }
}
```
###### /java/linenux/util/StringsSimilarityTest.java
``` java
public class StringsSimilarityTest {
    @Test
    public void levenshteinDistanceTest() {
        assertEquals(5, StringsSimilarity.compute("kitten", "sitting"));
        assertEquals(0, StringsSimilarity.compute("hello", "hello"));
    }
}
```
###### /java/linenux/util/TimeIntervalTest.java
``` java
public class TimeIntervalTest {
    TimeInterval interval;

    @Before
    public void setupInterval() {
        this.interval = new TimeInterval(LocalDateTime.of(2016, 1, 1, 0, 0), LocalDateTime.of(2016, 12, 31, 23, 59));
    }

    @Test
    public void testInInterval() {
        assertTrue(this.interval.inInterval(LocalDateTime.of(2016, 1, 1, 0, 0)));
        assertTrue(this.interval.inInterval(LocalDateTime.of(2016, 1, 2, 0, 0)));
        assertTrue(this.interval.inInterval(LocalDateTime.of(2016, 12, 31, 23, 59)));
    }

    @Test
    public void testNotInInterval() {
        assertFalse(this.interval.inInterval(LocalDateTime.of(2015, 12, 31, 23, 59)));
        assertFalse(this.interval.inInterval(LocalDateTime.of(2017, 1, 1, 0, 0)));
    }

    @Test
    public void testIsTrivial() {
        LocalDateTime time1 = LocalDateTime.of(2016, 1, 1, 0, 0);
        LocalDateTime time2 = LocalDateTime.of(2016, 1, 1, 0, 0);
        this.interval = new TimeInterval(time1, time2);
        assertTrue(this.interval.isTrivial());
    }

    @Test
    public void testIsNotTrivial() {
        assertFalse(this.interval.isTrivial());
    }
}
```
