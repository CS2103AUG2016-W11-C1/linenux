# A0140702X
###### /java/linenux/command/ClearCommandTest.java
``` java
/**
 * JUnit test for clear command.
 */
public class ClearCommandTest {
    private Schedule schedule;
    private ClearCommand clearCommand;
    private Task task1;
    private Task task2;
    private Task task3;
    private ArrayList<String> tags;

    @Before
    public void setupListCommand() {
        this.schedule = new Schedule();
        this.clearCommand = new ClearCommand(this.schedule);

        this.tags = new ArrayList<>();
        tags.add("hello");

        this.task1 = new Task("Task 1");
        this.task2 = new Task("Task 2");
        this.task3 = new Task("Task 3", tags);

        this.task2 = this.task2.markAsDone();

        this.schedule.addTask(task1);
        this.schedule.addTask(task2);
        this.schedule.addTask(task3);
    }

    /**
     * Test that command responds to the correct format.
     */
    @Test
    public void respondTo_inputThatStartsWithClear_trueReturned() {
        assertTrue(this.clearCommand.respondTo("clear #/hashtag"));
    }

    /**
     * Test that command is case insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.clearCommand.respondTo("ClEaR #/hashtag"));
    }

    /**
     * Test that command does not respond to other commands.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.clearCommand.respondTo("notclear"));
    }

    /**
     * Test the result when there are no tasks to clear.
     */
    @Test
    public void execute_noTasksToClear_commandResultReturned() {
        this.schedule.clear();
        CommandResult result = this.clearCommand.execute("clear");
        assertEquals("There are no done tasks to clear!", result.getFeedback());
    }

    /**
     * Test the result when there are tasks to clear.
     */
    @Test
    public void execute_hasDoneTasks_doneTasksCleared() {
        assertChangeBy(() -> this.schedule.getTaskList().size(),
            -1,
            () -> this.clearCommand.execute("clear"));

        //Ensure that the correct task is cleared
        ArrayList<Task> tasks = this.schedule.getTaskList();
        assertFalse(tasks.contains(this.task2));
    }

    /**
     * Test that command clears the result with hashtag.
     */
    @Test
    public void execute_byHashTag_doneTasksCleared() {
        assertChangeBy(() -> this.schedule.getTaskList().size(), -1, () -> this.clearCommand.execute("clear #/hello"));

        // Ensure that the correct task is cleared
        ArrayList<Task> tasks = this.schedule.getTaskList();
        assertTrue(!tasks.contains(this.task3));
    }
}
```
###### /java/linenux/command/EditReminderCommandTest.java
``` java
/**
 * JUnit test for edit reminder command.
 */
public class EditReminderCommandTest {
    private Schedule schedule;
    private EditReminderCommand editReminderCommand;

    @Before
    public void setupEditrCommand() {
        this.schedule = new Schedule();
        this.editReminderCommand = new EditReminderCommand(this.schedule);
    }

    private void setupMultipleHelloRemindersAndExecuteAmbiguousCommand() {
        Task task = new Task("hello");
        Reminder reminder1 = new Reminder("world", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder reminder2 = new Reminder("hello world", LocalDateTime.of(2017, 1, 1, 17, 0));

        task = task.addReminder(reminder1);
        task = task.addReminder(reminder2);

        this.schedule.addTask(task);
        this.editReminderCommand.execute("editr world n/wat t/2018-01-01 5.00PM");
    }

    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + this.editReminderCommand.getCommandFormat() + "\n\n" + Command.CALLOUTS;
    }

    /**
     * Test that respondTo detects various versions of the commands. It should
     * return true even if the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputThatStartsWithEdits_trueReturned() {
        assertTrue(this.editReminderCommand.respondTo("editr"));
        assertTrue(this.editReminderCommand.respondTo("editr n/note"));
        assertTrue(this.editReminderCommand.respondTo("editr t/2016-01-01 5.00PM"));
        assertTrue(this.editReminderCommand.respondTo("editr n/note t/2016-01-01 5.00PM"));

        assertTrue(this.editReminderCommand.respondTo("editr reminder"));
        assertTrue(this.editReminderCommand.respondTo("editr reminder n/note"));
        assertTrue(this.editReminderCommand.respondTo("editr reminder t/2016-01-01 5.00PM"));
        assertTrue(this.editReminderCommand.respondTo("editr reminder n/note t/2016-01-01 5.00PM"));
    }

    /**
     * Test that respondTo is case-insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.editReminderCommand.respondTo("EdITr reminder n/note t/2016-01-01 5.00PM"));
    }

    /**
     * Test that respondTo will return false for commands not related to edit reminder.
     */
    @Test
    public void respondTo_otherCommand_falseReturned() {
        assertFalse(this.editReminderCommand.respondTo("halp"));
    }

    /**
     * Test that executing the edit reminder command will correctly edit existing
     * reminder in schedule.
     */
    @Test
    public void execute_oneMatch_reminderUpdated() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        this.editReminderCommand.execute("editr reminder n/new reminder t/2017-01-01 5.00PM");

        // The edited reminder has correct note and time
        Task editedTask = this.schedule.getTaskList().get(0);
        Reminder editedReminder = editedTask.getReminders().get(0);
        assertEquals("new reminder", editedReminder.getNote());
        assertEquals(LocalDateTime.of(2017, 01, 01, 17, 0), editedReminder.getTimeOfReminder());
    }

    /**
     * Test that executing the edit reminder command will correctly edit existing
     * reminder in schedule.
     */
    @Test
    public void execute_updateNote_reminderUpdated() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        this.editReminderCommand.execute("editr reminder n/new reminder");

        // The edited reminder has correct note and time
        Task editedTask = this.schedule.getTaskList().get(0);
        Reminder editedReminder = editedTask.getReminders().get(0);
        assertEquals("new reminder", editedReminder.getNote());
        assertEquals(LocalDateTime.of(2016, 01, 01, 17, 0), editedReminder.getTimeOfReminder());
    }

    /**
     * Test that executing the edit reminder command will correctly edit existing
     * reminder in schedule.
     */
    @Test
    public void execute_updateTime_reminderUpdated() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        this.editReminderCommand.execute("editr reminder t/2017-01-01 5.00PM");

        // The edited reminder has correct note and time
        Task editedTask = this.schedule.getTaskList().get(0);
        Reminder editedReminder = editedTask.getReminders().get(0);
        assertEquals("reminder", editedReminder.getNote());
        assertEquals(LocalDateTime.of(2017, 01, 01, 17, 0), editedReminder.getTimeOfReminder());
    }

    @Test
    public void execute_multipleMatches_commandResultReturned() {
        Task task = new Task("hello");
        Reminder reminder1 = new Reminder("world", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder reminder2 = new Reminder("hello world", LocalDateTime.of(2017, 1, 1, 17, 0));

        task.addReminder(reminder1);
        task.addReminder(reminder2);

        this.schedule.addTask(task);

        CommandResult result = this.editReminderCommand.execute("editr world n/new world t/2016-01-01 5:00PM");
        assertEquals("Cannot find reminders with \"world\".", result.getFeedback());
    }

    @Test
    public void isAwaitingUserResponse_multipleMatches_trueReturned() {
        assertFalse(this.editReminderCommand.isAwaitingUserResponse());
        this.setupMultipleHelloRemindersAndExecuteAmbiguousCommand();
        assertTrue(this.editReminderCommand.isAwaitingUserResponse());
    }

    @Test
    public void processUserResponse_cancel_isNotAwaitingUserResponse() {
        this.setupMultipleHelloRemindersAndExecuteAmbiguousCommand();
        CommandResult result = this.editReminderCommand.processUserResponse("cancel");
        assertEquals("OK! Not editing anything.", result.getFeedback());
        assertFalse(this.editReminderCommand.isAwaitingUserResponse());
    }

    @Test
    public void processUserResponse_validIndex_taskUpdated() {
        this.setupMultipleHelloRemindersAndExecuteAmbiguousCommand();
        CommandResult result = this.editReminderCommand.processUserResponse("1");

        Task task = this.schedule.getTaskList().get(0);
        ArrayList<Reminder> reminders = task.getReminders();
        Reminder editedReminder = reminders.get(reminders.size() - 1);

        assertEquals("wat", editedReminder.getNote());
        assertEquals(LocalDateTime.of(2018, 1, 1, 17, 0), editedReminder.getTimeOfReminder());

        String expectedResult = "Edited \"world\".\n" + "New reminder details: wat (On 2018-01-01 5.00PM)";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void processUserInput_invalidIndex_commandResultReturned() {
        this.setupMultipleHelloRemindersAndExecuteAmbiguousCommand();
        CommandResult result = this.editReminderCommand.processUserResponse("3");

        String expectedResult = "That's not a valid index. Enter a number between 1 and 2, or \"cancel\" to cancel the current operation:\n" + "Task: hello\n"
                + "1. world (On 2016-01-01 5.00PM)\n" + "2. hello world (On 2017-01-01 5.00PM)";
        assertEquals(expectedResult, result.getFeedback());
    }

    @Test
    public void processUserInput_invalidInput_commandResultReturned() {
        this.setupMultipleHelloRemindersAndExecuteAmbiguousCommand();
        CommandResult result = this.editReminderCommand.processUserResponse("asd");

        String expectedResult = "I don't understand \"asd\".\nEnter a number to indicate which reminder to edit.\n"
                + "Task: hello\n"
                + "1. world (On 2016-01-01 5.00PM)\n" + "2. hello world (On 2017-01-01 5.00PM)";
        assertEquals(expectedResult, result.getFeedback());
    }

    /**
     * Test that executing the edit reminder command will correctly edit existing
     * reminder in schedule ignoring order of argument.
     */
    @Test
    public void execute_flagsShuffled_taskUpdated() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        this.editReminderCommand.execute("editr reminder t/2017-01-01 5.00PM n/new reminder");

        // The edited reminder has correct note and time
        Task editedTask = this.schedule.getTaskList().get(0);
        Reminder editedReminder = editedTask.getReminders().get(0);
        assertEquals("new reminder", editedReminder.getNote());
        assertEquals(LocalDateTime.of(2017, 01, 01, 17, 0), editedReminder.getTimeOfReminder());
    }

    @Test
    public void execute_invalidTime_commandResultReturned() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        CommandResult result = this.editReminderCommand.execute("editr reminder t/yesterday n/new reminder");

        assertEquals("Cannot parse \"yesterday\".", result.getFeedback());
    }

    @Test
    public void execute_noKeywords_commandResultReturned() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        CommandResult result = this.editReminderCommand.execute("editr t/2016-01-01 5:00PM n/new reminder");

        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    @Test
    public void execute_noFlags_reminderNotUpdated() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        CommandResult result = this.editReminderCommand.execute("editr reminder");

        assertEquals("No changes to be made!", result.getFeedback());
    }

    @Test
    public void execute_noMatch_commandResultReturned() {
        Task task = new Task("hello");
        Reminder reminder = new Reminder("reminder", LocalDateTime.of(2016, 01, 01, 17, 00));
        task = task.addReminder(reminder);
        this.schedule.addTask(task);

        CommandResult result = this.editReminderCommand.execute("editr hello");

        assertEquals("Cannot find reminders with \"hello\".", result.getFeedback());
    }
}
```
###### /java/linenux/command/ExitCommandTest.java
``` java
/**
 * JUnit test for exit command.
 */
public class ExitCommandTest {
    private ExitCommand exitCommand;

    @Rule
    public final ExpectedSystemExit exit = ExpectedSystemExit.none();

    @Before
    public void setupExitCommmand() {
        this.exitCommand = new ExitCommand();
    }

    /**
     * Test that respondTo detects various versions of the commands.
     */
    @Test
    public void respondTo_inputThatStartsWithExit_trueReturned() {
        assertTrue(this.exitCommand.respondTo("exit"));
        assertTrue(this.exitCommand.respondTo("exit    "));
        assertTrue(this.exitCommand.respondTo("exit now"));
    }

    /**
     * Test that respondTo is case-insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.exitCommand.respondTo("ExIt"));
    }

    /**
     * Test that respondTo will return false for commands not related to exit.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.exitCommand.respondTo("add"));
    }

    /**
     * Test that executing an exit command will quit the applications.
     */
    @Test
    public void execute() {
        exit.expectSystemExitWithStatus(0);
        this.exitCommand.execute("exit");
    }
}
```
###### /java/linenux/command/HelpCommandTest.java
``` java
public class HelpCommandTest {
    private HelpCommand helpCommand;
    private AddCommand addCommand;
    private EditCommand editCommand;
    private Schedule schedule;

    @Before
    public void setupHelpCommand() {
        this.schedule = new Schedule();
        this.addCommand = new AddCommand(this.schedule);
        this.editCommand = new EditCommand(this.schedule);
        this.helpCommand = new HelpCommand(
                ArrayListUtil.fromArray(new Command[] { this.addCommand, this.editCommand }));
    }

    /**
     * Test that help responds to the different versions of the command. Should
     * return true even if invalid.
     */
    @Test
    public void respondTo_inputThatStartsWithHelp_trueReturned() {
        assertTrue(this.helpCommand.respondTo("help"));
        assertTrue(this.helpCommand.respondTo("help add"));
        assertTrue(this.helpCommand.respondTo("help edit"));
        assertTrue(this.helpCommand.respondTo("help a a"));
    }

    /**
     * Test that respondTo is case-insensitive
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.helpCommand.respondTo("hElP"));
    }

    /**
     * Test does not respond to other commands
     */
    @Test
    public void respondTo_otherCommand_falseReturned() {
        assertFalse(this.helpCommand.respondTo("wat"));
    }

    /**
     * Test too many arguments given
     */
    @Test
    public void execute_invalidArgument_commandResultReturned() {
        CommandResult result = this.helpCommand.execute("help add 2");
        assertEquals("Too many arguments given. Please only search for one command at a time.", result.getFeedback());
    }

    /**
     * Test suggestion given for invalid command.
     */
    @Test
    public void execute_invalidCommand_suggestionGiven() {
        CommandResult result = this.helpCommand.execute("help addd");
        assertEquals("Invalid command given for help. Did you mean \'add\'?", result.getFeedback());
    }

    /**
     * Test execution of help command without specifying any command.
     */
    @Test
    public void execute_withoutArgument_commandResultReturned() {
        CommandResult result = this.helpCommand.execute("help");
        String addDescription = addCommand.getTriggerWord() + " - \nDescription: " + addCommand.getDescription()
                + "\nFormat: "
                + addCommand.getCommandFormat();
        String editDescription = editCommand.getTriggerWord() + " - \nDescription: " + editCommand.getDescription()
                + "\nFormat: "
                + editCommand.getCommandFormat();

        assertEquals(addDescription + "\n\n" + editDescription + "\n\n" + this.helpCommand.CALLOUTS,
                result.getFeedback());
    }

    /**
     * Test execution of help command with specified command
     */
    @Test
    public void execute_specificCommnad_commandResultReturned() {
        CommandResult result = this.helpCommand.execute("help add");
        String addDescription = addCommand.getTriggerWord() + " - \nDescription: " + addCommand.getDescription()
                + "\nFormat: " + addCommand.getCommandFormat();
        assertEquals(addDescription + "\n\n", result.getFeedback());
    }

    /**
     * Test execution of help command with for command with alias
     */
    @Test
    public void execute_commandAlias_commandResultReturned() {
        this.addCommand.setAlias("a");
        this.addCommand.setAlias("ad");
        this.editCommand.setAlias("e");
        this.editCommand.setAlias("ed");

        CommandResult result = this.helpCommand.execute("help");
        String addDescription = addCommand.getTriggerWord() + ", a, ad - \nDescription: " + addCommand.getDescription()
                + "\nFormat: " + addCommand.getCommandFormat();
        String editDescription = editCommand.getTriggerWord() + ", e, ed - \nDescription: "
                + editCommand.getDescription() + "\nFormat: " + editCommand.getCommandFormat();

        assertEquals(addDescription + "\n\n" + editDescription + "\n\n" + this.helpCommand.CALLOUTS,
                result.getFeedback());
    }
}
```
###### /java/linenux/command/ListCommandTest.java
``` java
/**
 * JUnit test for list command.
 */
public class ListCommandTest {
    private Schedule schedule;
    private ListCommand listCommand;

    @Before
    public void setupListCommand() {
        this.schedule = new Schedule();
        this.listCommand = new ListCommand(this.schedule);
    }

    /**
     * Test list all.
     */
    @Test
    public void respondTo_noArgument_trueReturned() {
        assertTrue(this.listCommand.respondTo("list"));
    }

    /**
     * Test search function in list.
     */
    @Test
    public void respondTo_withArgument_trueReturned() {
        assertTrue(this.listCommand.respondTo("list bla"));
    }

    /**
     * Test that list command is case insenstive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.listCommand.respondTo("LiSt"));
    }

    /**
     * Test that list command response to invalid datetime.
     */
    @Test
    public void execute_invalidTime_commandResultReturned() {
        this.schedule.addTask(new Task("todo"));
        CommandResult result = this.listCommand.execute("list st/not time");
        String expectedResult = "Cannot parse \"not time\".";

        assertEquals(expectedResult, result.getFeedback());
    }

    /**
     * Test that list command response to end time before start time.
     */
    @Test
    public void execute_endTimeBeforeStartTime_commandResultReturned() {
        this.schedule.addTask(new Task("todo"));
        CommandResult result = this.listCommand.execute("list st/2016-01-01 5.00PM et/2015-01-01 5.00PM");
        String expectedResult = "End time cannot come before start time.";

        assertEquals(expectedResult, result.getFeedback());
    }

    /**
     * Test that list command does not respond to other commands.
     */
    @Test
    public void respondTo_otherCommand_falseReturned() {
        assertFalse(this.listCommand.respondTo("whaddup"));
    }

    /**
     * Test that list without params should display all undone tasks and
     * reminders
     */
    @Test
    public void execute_noArgument_allTasksReturned() {
        this.schedule.addTask(new Task("First Task"));
        this.schedule.addTask(new Task("Second Task"));
        this.schedule.addTask(new Task("Deadline", null, LocalDateTime.of(2016, 1, 1, 17, 0)));
        this.schedule.addTask(new Task("Event", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2016, 1, 1, 18, 0)));

        Task taskWithReminder = new Task("Task with Reminder");
        taskWithReminder = taskWithReminder.addReminder(new Reminder("Reminder", LocalDateTime.of(2016, 2, 1, 17, 0)));
        this.schedule.addTask(taskWithReminder);

        CommandResult result = this.listCommand.execute("list");

        String expectedFeedback = "Reminders:\n"
                + "1. Reminder (On 2016-02-01 5.00PM)";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    /**
     * Test that list command displays multiple tasks correctly.
     */
    @Test
    public void execute_withKeywords_tasksMatchingTheKeywordsReturned() {
        Task task1 = new Task("hello");
        Task task2 = new Task("world");
        Task task3 = new Task("hello world");
        this.schedule.addTask(task1);
        this.schedule.addTask(task2);
        this.schedule.addTask(task3);

        this.listCommand.execute("list world");
        assertTrue(
                this.schedule.getFilteredTasks().contains(task2) && this.schedule.getFilteredTasks().contains(task3));
    }

    @Test
    public void execute_noMatch_commandResultReturn() {
        this.schedule.addTask(new Task("hi!"));

        CommandResult result = this.listCommand.execute("list hello");

        String expectedFeedback = "There are no tasks and reminders found based on your given inputs!";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    /**
     * Test that list command displays multiple reminders correctly.
     */
    @Test
    public void execute_keywords_remindersMatchingTheKeywordsReturned() {
        Task hello = new Task("hello");
        hello = hello.addReminder(new Reminder("world domination", LocalDateTime.of(2016, 2, 1, 17, 0)));
        hello = hello.addReminder(new Reminder("is my occupation", LocalDateTime.of(2016, 1, 1, 17, 0)));
        hello = hello.addReminder(new Reminder("hello world", LocalDateTime.of(2016, 3, 1, 17, 0)));
        this.schedule.addTask(hello);

        CommandResult result = this.listCommand.execute("list world");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();
        assertTrue(!filteredTasks.contains(hello));

        String expectedFeedback = "Reminders:\n1. world domination (On 2016-02-01 5.00PM)\n2. hello world (On 2016-03-01 5.00PM)";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    /**
     * Test that list command displays multiple reminders and tasks correctly.
     */
    @Test
    public void execute_keywords_tasksAndRemindersMatchingTheKeywordsReturned() {
        Task hello = new Task("hello");
        hello = hello.addReminder(new Reminder("world domination", LocalDateTime.of(2016, 2, 1, 17, 0)));
        hello = hello.addReminder(new Reminder("is my occupation", LocalDateTime.of(2016, 1, 1, 17, 0)));
        hello = hello.addReminder(new Reminder("hello world", LocalDateTime.of(2016, 3, 1, 17, 0)));
        hello = hello.addReminder(new Reminder("hello darkness", LocalDateTime.of(2016, 4, 1, 17, 0)));
        this.schedule.addTask(hello);

        Task helloWorld = new Task("Hello World");
        helloWorld = helloWorld.addReminder(new Reminder("hello hello", LocalDateTime.of(2016, 1, 1, 17, 0)));
        this.schedule.addTask(helloWorld);

        CommandResult result = this.listCommand.execute("list hello");

        String expectedFeedback = "Reminders:\n" + "1. hello hello (On 2016-01-01 5.00PM)\n"
                + "2. hello world (On 2016-03-01 5.00PM)\n" + "3. hello darkness (On 2016-04-01 5.00PM)";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    /**
     * Test that list command filters by start time
     */
    @Test
    public void execute_startTime_tasksAndRemindersReturned() {
        Task todo = new Task("todo");
        todo = todo.addReminder(new Reminder("todo before", LocalDateTime.of(2015, 1, 1, 17, 0)));
        todo = todo.addReminder(new Reminder("todo after", LocalDateTime.of(2017, 1, 1, 17, 0)));
        todo = todo.addReminder(new Reminder("todo on", LocalDateTime.of(2016, 1, 1, 17, 0)));

        Task eventBefore = new Task("event before", LocalDateTime.of(2015, 1, 1, 17, 0),
                LocalDateTime.of(2015, 1, 1, 19, 0));
        Task eventOn = new Task("event on", LocalDateTime.of(2015, 1, 1, 17, 0), LocalDateTime.of(2016, 1, 1, 17, 0));
        Task eventAfter = new Task("event after", LocalDateTime.of(2015, 1, 1, 17, 0),
                LocalDateTime.of(2017, 1, 1, 17, 0));

        Task deadlineBefore = new Task("deadline before", LocalDateTime.of(2015, 1, 1, 17, 0));
        Task deadlineOn = new Task("deadline On", LocalDateTime.of(2016, 1, 1, 17, 0));
        Task deadlineAfter = new Task("deadline before", LocalDateTime.of(2017, 1, 1, 17, 0));

        this.schedule.addTask(todo);
        this.schedule.addTask(eventBefore);
        this.schedule.addTask(eventOn);
        this.schedule.addTask(eventAfter);
        this.schedule.addTask(deadlineBefore);
        this.schedule.addTask(deadlineOn);
        this.schedule.addTask(deadlineAfter);

        CommandResult result = this.listCommand.execute("list st/2016-01-01 5.00PM");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo));
        assertTrue(!filteredTasks.contains(eventBefore));
        assertTrue(filteredTasks.contains(eventOn));
        assertTrue(filteredTasks.contains(eventAfter));
        assertTrue(!filteredTasks.contains(deadlineBefore));
        assertTrue(filteredTasks.contains(deadlineOn));
        assertTrue(filteredTasks.contains(deadlineAfter));

        String expectedFeedback = "Reminders:\n" + "1. todo on (On 2016-01-01 5.00PM)\n"
                + "2. todo after (On 2017-01-01 5.00PM)";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    /**
     * Test that list command filters by end time
     */
    @Test
    public void execute_endTime_tasksAndRemindersReturned() {
        Task todo = new Task("todo");
        todo = todo.addReminder(new Reminder("todo before", LocalDateTime.of(2015, 1, 1, 17, 0)));
        todo = todo.addReminder(new Reminder("todo after", LocalDateTime.of(2017, 1, 1, 17, 0)));
        todo = todo.addReminder(new Reminder("todo on", LocalDateTime.of(2016, 1, 1, 17, 0)));

        Task eventBefore = new Task("event before", LocalDateTime.of(2015, 1, 1, 17, 0),
                LocalDateTime.of(2015, 1, 1, 19, 0));
        Task eventOn = new Task("event on", LocalDateTime.of(2015, 1, 1, 17, 0), LocalDateTime.of(2016, 1, 1, 17, 0));
        Task eventEndTimeAfter = new Task("event after", LocalDateTime.of(2015, 1, 1, 19, 0),
                LocalDateTime.of(2017, 1, 1, 17, 0));
        Task eventStartTimeAfter = new Task("event after", LocalDateTime.of(2017, 1, 1, 19, 0),
                LocalDateTime.of(2018, 1, 1, 17, 0));

        Task deadlineBefore = new Task("deadline before", LocalDateTime.of(2015, 1, 1, 17, 0));
        Task deadlineOn = new Task("deadline On", LocalDateTime.of(2016, 1, 1, 17, 0));
        Task deadlineAfter = new Task("deadline after", LocalDateTime.of(2017, 1, 1, 17, 0));

        this.schedule.addTask(todo);
        this.schedule.addTask(eventBefore);
        this.schedule.addTask(eventOn);
        this.schedule.addTask(eventEndTimeAfter);
        this.schedule.addTask(eventStartTimeAfter);
        this.schedule.addTask(deadlineBefore);
        this.schedule.addTask(deadlineOn);
        this.schedule.addTask(deadlineAfter);

        CommandResult result = this.listCommand.execute("list et/2016-01-01 5.00PM");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo));
        assertTrue(filteredTasks.contains(eventBefore));
        assertTrue(filteredTasks.contains(eventOn));
        assertTrue(filteredTasks.contains(eventEndTimeAfter));
        assertTrue(!filteredTasks.contains(eventStartTimeAfter));
        assertTrue(filteredTasks.contains(deadlineBefore));
        assertTrue(filteredTasks.contains(deadlineOn));
        assertTrue(!filteredTasks.contains(deadlineAfter));

        String expectedFeedback = "Reminders:\n" + "1. todo before (On 2015-01-01 5.00PM)\n"
                + "2. todo on (On 2016-01-01 5.00PM)";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    /**
     * Test that list command filters by start and end time
     */
    @Test
    public void execute_startTimeAndEndTime_tasksAndRemindersReturned() {
        Task todo = new Task("todo");
        todo = todo.addReminder(new Reminder("todo before", LocalDateTime.of(2015, 1, 1, 17, 0)));
        todo = todo.addReminder(new Reminder("todo after", LocalDateTime.of(2017, 1, 1, 17, 0)));
        todo = todo.addReminder(new Reminder("todo during", LocalDateTime.of(2016, 6, 1, 17, 0)));

        Task eventEndTimeBefore = new Task("event end time before", LocalDateTime.of(2015, 1, 1, 17, 0),
                LocalDateTime.of(2015, 1, 1, 19, 0));
        Task eventDuring1 = new Task("event during1", LocalDateTime.of(2015, 1, 1, 17, 0),
                LocalDateTime.of(2016, 2, 1, 17, 0));
        Task eventDuring2 = new Task("event during2", LocalDateTime.of(2016, 1, 2, 19, 0),
                LocalDateTime.of(2016, 1, 3, 17, 0));
        Task eventDuring3 = new Task("event during3", LocalDateTime.of(2016, 1, 2, 19, 0),
                LocalDateTime.of(2017, 1, 3, 17, 0));
        Task eventDuring4 = new Task("event during4", LocalDateTime.of(2014, 1, 1, 17, 0),
                LocalDateTime.of(2017, 1, 1, 17, 0));
        Task eventStartTimeAfter = new Task("event start time after", LocalDateTime.of(2017, 1, 1, 19, 0),
                LocalDateTime.of(2018, 1, 1, 17, 0));

        Task deadlineBefore = new Task("deadline before", LocalDateTime.of(2015, 1, 1, 17, 0));
        Task deadlineDuring = new Task("deadline during", LocalDateTime.of(2016, 6, 1, 17, 0));
        Task deadlineAfter = new Task("deadline after", LocalDateTime.of(2017, 1, 1, 17, 0));

        this.schedule.addTask(todo);
        this.schedule.addTask(eventEndTimeBefore);
        this.schedule.addTask(eventDuring1);
        this.schedule.addTask(eventDuring2);
        this.schedule.addTask(eventDuring3);
        this.schedule.addTask(eventDuring4);
        this.schedule.addTask(eventStartTimeAfter);
        this.schedule.addTask(deadlineBefore);
        this.schedule.addTask(deadlineDuring);
        this.schedule.addTask(deadlineAfter);

        CommandResult result = this.listCommand.execute("list st/2016-01-01 5.00PM et/2016-12-31 5.00PM");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo));
        assertTrue(!filteredTasks.contains(eventEndTimeBefore));
        assertTrue(filteredTasks.contains(eventDuring1));
        assertTrue(filteredTasks.contains(eventDuring2));
        assertTrue(filteredTasks.contains(eventDuring3));
        assertTrue(filteredTasks.contains(eventDuring4));
        assertTrue(!filteredTasks.contains(eventStartTimeAfter));
        assertTrue(!filteredTasks.contains(deadlineBefore));
        assertTrue(filteredTasks.contains(deadlineDuring));
        assertTrue(!filteredTasks.contains(deadlineAfter));

        String expectedFeedback = "Reminders:\n" + "1. todo during (On 2016-06-01 5.00PM)";
        assertEquals(expectedFeedback, result.getFeedback());
    }

    /**
     * Test that list command filters task by tags
     */
    @Test
    public void execute_tags_tasksReturned() {
        ArrayList<String> tags1 = new ArrayList<>();
        ArrayList<String> tags2 = new ArrayList<>();
        ArrayList<String> tags3 = new ArrayList<>();

        tags1.add("hello");
        tags2.add("hello");
        tags2.add("world");
        tags3.add("wat");

        Task todo1 = new Task("todo 1", tags1);
        Task todo2 = new Task("todo 2", tags2);
        Task todo3 = new Task("todo 3", tags3);

        this.schedule.addTask(todo1);
        this.schedule.addTask(todo2);
        this.schedule.addTask(todo3);

        this.listCommand.execute("list #/hello");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo1));
        assertTrue(filteredTasks.contains(todo2));
        assertTrue(!filteredTasks.contains(todo3));
    }

    /**
     * Test that list command filters by tags does not show reminders
     */
    @Test
    public void execute_tags_remindersNotReturned() {
        ArrayList<String> tags1 = new ArrayList<>();
        ArrayList<String> tags2 = new ArrayList<>();
        ArrayList<String> tags3 = new ArrayList<>();

        tags1.add("hello");
        tags2.add("hello");
        tags2.add("world");
        tags3.add("wat");

        Task todo1 = new Task("todo 1", tags1);
        Task todo2 = new Task("todo 2", tags2);
        Task todo3 = new Task("todo 3", tags3);

        todo1.addReminder(new Reminder("reminder", LocalDateTime.of(2016, 1, 1, 17, 0)));

        this.schedule.addTask(todo1);
        this.schedule.addTask(todo2);
        this.schedule.addTask(todo3);

        CommandResult result = this.listCommand.execute("list #/hello");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo1));
        assertTrue(filteredTasks.contains(todo2));
        assertTrue(!filteredTasks.contains(todo3));

        assertEquals("", result.getFeedback());
    }

    /**
     * Test that list command filters by tags is case-insensitive
     */
    @Test
    public void execute_tags_caseInsensitive() {
        ArrayList<String> tags1 = new ArrayList<>();
        ArrayList<String> tags2 = new ArrayList<>();
        ArrayList<String> tags3 = new ArrayList<>();

        tags1.add("hello");
        tags2.add("hello");
        tags2.add("world");
        tags3.add("wat");

        Task todo1 = new Task("todo 1", tags1);
        Task todo2 = new Task("todo 2", tags2);
        Task todo3 = new Task("todo 3", tags3);

        this.schedule.addTask(todo1);
        this.schedule.addTask(todo2);
        this.schedule.addTask(todo3);

        this.listCommand.execute("list #/hElLo");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo1));
        assertTrue(filteredTasks.contains(todo2));
        assertTrue(!filteredTasks.contains(todo3));
    }

    /**
     * Test that default list command does not show done task.
     */
    @Test
    public void execute_noDoneFlag_doneTasksAreNotShown() {
        Task todo1 = new Task("todo 1");
        Task todo2 = new Task("todo 2");

        todo1 = todo1.markAsDone();

        this.schedule.addTask(todo1);
        this.schedule.addTask(todo2);

        this.listCommand.execute("list");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(!filteredTasks.contains(todo1));
        assertTrue(filteredTasks.contains(todo2));
    }

    /**
     * Test that list command field d/yes (view done only)
     */
    @Test
    public void execute_doneFlagYes_doneTasksReturned() {
        Task todo1 = new Task("todo 1");
        Task todo2 = new Task("todo 2");

        todo1 = todo1.markAsDone();

        this.schedule.addTask(todo1);
        this.schedule.addTask(todo2);

        this.listCommand.execute("list d/yes");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo1));
        assertTrue(!filteredTasks.contains(todo2));
    }

    /**
     * Test that list command field d/all (view all including done)
     */
    @Test
    public void execute_doneFlagAll_allTasksReturned() {
        Task todo1 = new Task("todo 1");
        Task todo2 = new Task("todo 2");

        todo1 = todo1.markAsDone();

        this.schedule.addTask(todo1);
        this.schedule.addTask(todo2);

        this.listCommand.execute("list d/all");

        ArrayList<Task> filteredTasks = this.schedule.getFilteredTasks();

        assertTrue(filteredTasks.contains(todo1));
        assertTrue(filteredTasks.contains(todo2));
    }

    /**
     * Test that list command field d/ when invalid
     */
    @Test
    public void execute_doneFlagInvalid_commandResultReturn() {
        Task todo = new Task("todo");

        this.schedule.addTask(todo);

        CommandResult result = this.listCommand.execute("list d/invalid");

        String expectedFeedback = "Unable to parse \"invalid\".\n" + "Did you mean:\n"
                + "d/all - View all done and uncompleted tasks.\n" + "d/yes - Show only tasks that are marked done.";
        assertEquals(expectedFeedback, result.getFeedback());
    }
}
```
###### /java/linenux/command/RemindCommandTest.java
``` java
/**
 * JUnit test for remind command.
 */
public class RemindCommandTest {
    private Schedule schedule;
    private RemindCommand remindCommand;

    @Before
    public void setupRemindCommand() {
        Task todo = new Task("Todo");
        Task deadline = new Task("Deadline", LocalDateTime.of(2016, 1, 1, 1, 0));
        Task event = new Task("Event", LocalDateTime.of(2016, 1, 1, 1, 0), LocalDateTime.of(2016, 1, 1, 13, 0));

        this.schedule = new Schedule();
        this.schedule.addTask(todo);
        this.schedule.addTask(deadline);
        this.schedule.addTask(event);
        this.remindCommand = new RemindCommand(this.schedule);
    }

    private void setupTaskWithSameNameAndExecuteAmbiguousCommand() {
        this.schedule.addTask(new Task("Todo 2"));
        this.remindCommand.execute("remind Todo t/2016-01-01 05.00PM n/Hey");
    }

    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + this.remindCommand.getCommandFormat() + "\n\n" + Command.CALLOUTS;
    }

    /**
     * Get search result when done is executed. Assumes userInput is in correct
     * format and schedule is not null.
     */
    private ArrayList<Task> getSearchResult(String keywords) {
        String[] keywordsArr = keywords.split("\\s+");
        return this.schedule.search(keywordsArr);
    }

    /**
     * Test that respondTo detects various versions of the commands. It should
     * return true even if the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputThatStartsWithRemind_trueReturned() {
        assertTrue(this.remindCommand.respondTo("remind"));
        assertTrue(this.remindCommand.respondTo("remind task"));
        assertTrue(this.remindCommand.respondTo("remind task t/2016-01-01"));
        assertTrue(this.remindCommand.respondTo("remind task t/2016-01-01 n/notes"));
    }

    /**
     * Test respondTo is case-insensitive.
     */
    @Test
    public void repondTo_upperCase_trueReturned() {
        assertTrue(this.remindCommand.respondTo("ReMiNd task t/2016-01-01"));
    }

    /**
     * Test that respondTo will return false for commands not related to adding
     * reminders.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.remindCommand.respondTo("notremind"));
        assertFalse(this.remindCommand.respondTo("remindr"));
    }

    /**
     * Test that executing adding reminder to a To-Do should return correct
     * result.
     */
    @Test
    public void execute_remindTodo_reminderAdded() {
        assertChangeBy(() -> getSearchResult("Todo").get(0).getReminders().size(), 1,
                () -> this.remindCommand.execute("remind Todo t/2000-01-01 05.00PM n/Attend Workshop"));
        ArrayList<Reminder> reminders = getSearchResult("Todo").get(0).getReminders();
        Reminder addedReminder = reminders.get(reminders.size() - 1);
        assertEquals(LocalDateTime.of(2000, 1, 1, 17, 0), addedReminder.getTimeOfReminder());
        assertEquals("Attend Workshop", addedReminder.getNote());
    }

    /**
     * Test that executing adding reminder in different order to a To-Do should
     * return correct result.
     */
    @Test
    public void execute_shuffleFlags_reminderAdded() {
        assertChangeBy(() -> getSearchResult("Todo").get(0).getReminders().size(), 1,
                () -> this.remindCommand.execute("remind Todo n/Attend Workshop t/2000-01-01 05.00PM"));
        ArrayList<Reminder> reminders = getSearchResult("Todo").get(0).getReminders();
        Reminder addedReminder = reminders.get(reminders.size() - 1);
        assertEquals(LocalDateTime.of(2000, 1, 1, 17, 0), addedReminder.getTimeOfReminder());
        assertEquals("Attend Workshop", addedReminder.getNote());
    }

    /**
     * Test that executing adding reminder to a Deadline should return correct
     * result.
     */
    @Test
    public void execute_deadline_reminderAdded() {
        assertChangeBy(() -> getSearchResult("Deadline").get(0).getReminders().size(), 1,
                () -> this.remindCommand.execute("remind deadline t/2000-01-01 05.00PM n/Attend Workshop"));
        ArrayList<Reminder> reminders = getSearchResult("Deadline").get(0).getReminders();
        Reminder addedReminder = reminders.get(reminders.size() - 1);
        assertEquals(LocalDateTime.of(2000, 1, 1, 17, 0), addedReminder.getTimeOfReminder());
        assertEquals("Attend Workshop", addedReminder.getNote());
    }

    /**
     * Test that executing adding reminder in different order to a Deadline
     * should return correct result.
     */
    @Test
    public void execute_shuffleDeadlineFlags_reminderAdded() {
        assertChangeBy(() -> getSearchResult("Deadline").get(0).getReminders().size(), 1,
                () -> this.remindCommand.execute("remind deadline n/Attend Workshop t/2000-01-01 05.00PM"));
        ArrayList<Reminder> reminders = getSearchResult("Deadline").get(0).getReminders();
        Reminder addedReminder = reminders.get(reminders.size() - 1);
        assertEquals(LocalDateTime.of(2000, 1, 1, 17, 0), addedReminder.getTimeOfReminder());
        assertEquals("Attend Workshop", addedReminder.getNote());
    }

    /**
     * Test that executing adding reminder to a Event should return correct
     * result.
     */
    @Test
    public void execute_event_reminderAdded() {
        assertChangeBy(() -> getSearchResult("Event").get(0).getReminders().size(), 1,
                () -> this.remindCommand.execute("remind Event t/2000-01-01 05.00PM n/Attend Workshop"));
        ArrayList<Reminder> reminders = getSearchResult("Event").get(0).getReminders();
        Reminder addedReminder = reminders.get(reminders.size() - 1);
        assertEquals(LocalDateTime.of(2000, 1, 1, 17, 0), addedReminder.getTimeOfReminder());
        assertEquals("Attend Workshop", addedReminder.getNote());
    }

    /**
     * Test that executing adding reminder in different order to a Event should
     * return correct result.
     */
    @Test
    public void execute_eventFlagsShuffled_reminderAdded() {
        assertChangeBy(() -> getSearchResult("Event").get(0).getReminders().size(), 1,
                () -> this.remindCommand.execute("remind Event n/Attend Workshop t/2000-01-01 05.00PM"));
        ArrayList<Reminder> reminders = getSearchResult("Event").get(0).getReminders();
        Reminder addedReminder = reminders.get(reminders.size() - 1);
        assertEquals(LocalDateTime.of(2000, 1, 1, 17, 0), addedReminder.getTimeOfReminder());
        assertEquals("Attend Workshop", addedReminder.getNote());
    }

    /**
     * Test the result when no task name is given to search.
     */
    @Test
    public void execute_noTaskName_commandResultReturned() {
        ArrayList<Task> tasks = this.schedule.getTaskList();
        CommandResult result = assertNoChange(() -> {
            int size = 0;
            for (int i = 0; i < tasks.size(); i++) {
                size += tasks.get(i).getReminders().size();
            }
            return size;
        }, () -> this.remindCommand.execute("remind t/2011-01-01 05.00PM n/hey"));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test the result when no reminder note is given to search.
     */
    @Test
    public void execute_noReminderNote_commandResultReturned() {
        ArrayList<Task> tasks = this.schedule.getTaskList();
        CommandResult result = assertNoChange(() -> {
            int size = 0;
            for (int i = 0; i < tasks.size(); i++) {
                size += tasks.get(i).getReminders().size();
            }
            return size;
        }, () -> this.remindCommand.execute("remind Todo t/2011-01-01 05.00PM"));
        assertEquals("Cannot create reminder without note.", result.getFeedback());
    }

    /**
     * Test the result when no time is given for the reminder.
     */
    @Test
    public void execute_noTime_commandResultReturned() {
        CommandResult result = assertNoChange(() -> getSearchResult("Todo").get(0).getReminders().size(),
                () -> this.remindCommand.execute("remind todo n/hey"));
        assertEquals("Cannot create reminder without date.", result.getFeedback());
    }

    /**
     * Test the result when time is invalid.
     */
    @Test
    public void execute_invalidTime_commandResultReturned() {
        CommandResult result = assertNoChange(() -> getSearchResult("Todo").get(0).getReminders().size(),
                () -> this.remindCommand.execute("remind todo t/tomorrow"));
        assertEquals("Cannot parse \"tomorrow\".", result.getFeedback());
    }

    /**
     * Test the result when no match is found.
     */
    @Test
    public void execute_taskNotFound_commandResultReturned() {
        ArrayList<Task> tasks = this.schedule.getTaskList();
        CommandResult result = assertNoChange(() -> {
            int size = 0;
            for (int i = 0; i < tasks.size(); i++) {
                size += tasks.get(i).getReminders().size();
            }
            return size;
        }, () -> this.remindCommand.execute("remind not task t/2016-01-01 05.00PM"));
        assertEquals("Cannot find task names with \"not task\".", result.getFeedback());
    }

    /**
     * Test the result when multiple matches are found.
     */
    @Test
    public void execute_multipleMatches_commandResultReturned() {
        this.schedule.addTask(new Task("todo 2"));
        CommandResult result = assertNoChange(() -> this.totalNumberOfReminders(),
                () -> this.remindCommand.execute("remind todo t/2016-01-01 05.00PM"));
        assertEquals("Which one? (1-2, \"cancel\" to cancel the current operation)\n1. Todo\n2. todo 2", result.getFeedback());
    }

    /**
     * Test that command is waiting user response.
     */
    @Test
    public void isAwaitingUserResponse_multipleMatches_trueReturned() {
        assertFalse(this.remindCommand.isAwaitingUserResponse());
        this.setupTaskWithSameNameAndExecuteAmbiguousCommand();
        assertTrue(this.remindCommand.isAwaitingUserResponse());
    }

    /**
     * Test the result when user cancel response.
     */
    @Test
    public void processUserResponse_cancel_isNotAwaitingUserResponse() {
        this.setupTaskWithSameNameAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.totalNumberOfReminders(),
                () -> this.remindCommand.processUserResponse("cancel"));
        assertEquals("OK! Not adding new reminder.", result.getFeedback());
        assertFalse(this.remindCommand.isAwaitingUserResponse());
    }

    /**
     * Test the result when user inputs valid index.
     */
    @Test
    public void processUserResponse_validIndex_reminderAdded() {
        this.setupTaskWithSameNameAndExecuteAmbiguousCommand();
        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().get(0).getReminders().size(), 1,
                () -> this.remindCommand.processUserResponse("1"));
        assertEquals("Added reminder on 2016-01-01 5.00PM for Todo", result.getFeedback());
        assertFalse(this.remindCommand.isAwaitingUserResponse());
    }

    /**
     * Test the result when user inputs invalid index.
     */
    @Test
    public void processUserResponse_invalidIndex_commandResultReturned() {
        this.setupTaskWithSameNameAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> getSearchResult("Todo").get(0).getReminders().size(),
                () -> this.remindCommand.processUserResponse("0"));
        assertEquals("That's not a valid index. Enter a number between 1 and 2, or \"cancel\" to cancel the current operation:\n" + "1. Todo\n2. Todo 2",
                result.getFeedback());
        assertTrue(this.remindCommand.isAwaitingUserResponse());
    }

    /**
     * Test the result when user inputs invalid response.
     */
    @Test
    public void processUserResponse_invalidResponse_commandResultReturned() {
        this.setupTaskWithSameNameAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> getSearchResult("Todo").get(0).getReminders().size(),
                () -> this.remindCommand.processUserResponse("One"));
        assertEquals("I don't understand \"One\".\nEnter a number to indicate which task to add reminder to:\n"
                + "1. Todo\n2. Todo 2", result.getFeedback());
        assertTrue(this.remindCommand.isAwaitingUserResponse());
    }

    private int totalNumberOfReminders() {
        return new ArrayListUtil.ChainableArrayListUtil<>(this.schedule.getTaskList())
                .map(Task::getReminders)
                .map(ArrayList::size)
                .foldr(Integer::sum, 0);
    }
}
```
###### /java/linenux/command/UndoneCommandTest.java
``` java
public class UndoneCommandTest {
    private Schedule schedule;
    private UndoneCommand undoneCommand;

    @Before
    public void setupUndoneCommand() {
        this.schedule = new Schedule();
        this.undoneCommand = new UndoneCommand(this.schedule);
    }

    /**
     * Get search result when done is executed. Assumes userInput is in correct
     * format and schedule is not null.
     */
    private ArrayList<Task> getSearchResult(String keywords) {
        return this.schedule.search(keywords);
    }

    private void setupMultipleHelloTasksAndExecuteAmbiguousCommand() {
        Task task1 = new Task("hello world");
        Task task2 = new Task("say hello from the other side");

        task1 = task1.markAsDone();
        task2 = task2.markAsDone();

        this.schedule.addTask(task1);
        this.schedule.addTask(task2);
        this.undoneCommand.execute("undone hello");
    }

    /**
     * Test that respondTo detects various versions of the commands. It should
     * return true even if the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputThatBeginsWithUndone_trueReturned() {
        assertTrue(this.undoneCommand.respondTo("undone"));
        assertTrue(this.undoneCommand.respondTo("undone       "));
        assertTrue(this.undoneCommand.respondTo("undone hey"));
    }

    /**
     * Test that the undone command is case insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.undoneCommand.respondTo("uNdOnE hello"));
    }

    /**
     * Test that respondTo will return false for commands not related to undone.
     */
    @Test
    public void respondTo_otherCommand_falseReturned() {
        assertFalse(this.undoneCommand.respondTo("donedone"));
    }

    /**
     * Test the feedback when no match is found.
     */
    @Test
    public void execute_noMatch_commandResultReturned() {
        this.schedule.addTask(new Task("Shot through the heart"));
        CommandResult result = this.undoneCommand.execute("undone and you are to blame");
        assertEquals("Cannot find task names with \"and you are to blame\".", result.getFeedback());
    }

    /**
     * Test the feedback when only one match is found.
     */
    @Test
    public void execute_oneMatch_taskMarkAsDone() {
        Task task1 = new Task("Live like we are dying");
        task1 = task1.markAsDone();
        this.schedule.addTask(task1);
        this.schedule.addTask(new Task("Play on broken strings"));

        ArrayList<Task> taskList = getSearchResult("live");
        assertFalse(taskList.get(0).isNotDone());
        CommandResult result = this.undoneCommand.execute("undone live");
        assertEquals("\"Live like we are dying\" is marked as undone.", result.getFeedback());

        taskList = getSearchResult("live");
        assertTrue(taskList.get(0).isNotDone());
    }

    /**
     * Test the feedback when multiple matches are found.
     */
    @Test
    public void exeucte_multipleMatches_commandResultReturned() {
        Task task1 = new Task("hello world");
        Task task2 = new Task("say hello");

        task1 = task1.markAsDone();
        task2 = task2.markAsDone();

        this.schedule.addTask(task1);
        this.schedule.addTask(task2);
        CommandResult result = this.undoneCommand.execute("undone hello");
        assertEquals("Which one? (1-2, \"cancel\" to cancel the current operation)\n1. hello world\n2. say hello", result.getFeedback());
    }

    /**
     * Test the command is awaiting user response when multiple matches are
     * found.
     */
    @Test
    public void isAwaitingUserResponse_multipleMatches_trueReturned() {
        assertFalse(this.undoneCommand.isAwaitingUserResponse());
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        assertTrue(this.undoneCommand.isAwaitingUserResponse());
    }

    /**
     * Test that cancel works properly.
     */
    @Test
    public void processingUserResponse_cancel_isNotAwaitingUserResponse() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = this.undoneCommand.processUserResponse("cancel");
        assertEquals("OK! Not marking any task as undone.", result.getFeedback());
        assertFalse(this.undoneCommand.isAwaitingUserResponse());
    }

    /**
     * Test that task is marked as done if user selects a valid index.
     */
    @Test
    public void processingUserResponse_validIndex_taskMarkUndone() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        ArrayList<Task> taskList = getSearchResult("hello");
        assertFalse(taskList.get(0).isNotDone());

        CommandResult result = this.undoneCommand.processUserResponse("1");
        assertEquals("\"hello world\" is marked as undone.", result.getFeedback());
        taskList = getSearchResult("hello");
        assertTrue(taskList.get(0).isNotDone());

        assertFalse(this.undoneCommand.isAwaitingUserResponse());
    }

    /**
     * Test that task is not marked as done if user selects an invalid index.
     */
    @Test
    public void processUserResponse_invalidIndex_commandResultReturned() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        ArrayList<Task> taskList = getSearchResult("hello");
        assertFalse(taskList.get(0).isNotDone());

        CommandResult result = this.undoneCommand.processUserResponse("0");
        String expectedResponse = "That's not a valid index. Enter a number between 1 and 2, or \"cancel\" to cancel the current operation:\n"
                + "1. hello world\n2. say hello from the other side";
        assertEquals(expectedResponse, result.getFeedback());
        taskList = getSearchResult("hello");
        assertFalse(taskList.get(0).isNotDone());

        assertTrue(this.undoneCommand.isAwaitingUserResponse());
    }

    /**
     * Test that task is not marked as done if user types an invalid response.
     */
    @Test
    public void processUserResponse_invalidResponse_commandResultReturned() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        ArrayList<Task> taskList = getSearchResult("hello");
        assertFalse(taskList.get(0).isNotDone());

        CommandResult result = this.undoneCommand.processUserResponse("roses are red");
        String expectedResponse = "I don't understand \"roses are red\".\n"
                + "Enter a number to indicate which task to mark as undone.\n1. hello world\n2. say hello from the other side";
        assertEquals(expectedResponse, result.getFeedback());
        taskList = getSearchResult("hello");
        assertFalse(taskList.get(0).isNotDone());

        assertTrue(this.undoneCommand.isAwaitingUserResponse());
    }

    /**
     * Test searching only searches for done tasks.
     */

    @Test
    public void execute_validArguments_looksForDoneTasksOnly() {
        this.schedule.addTask(new Task("hello"));
        this.schedule.addTask(new Task("hello", LocalDateTime.of(2017, 1, 1, 17, 0)).markAsDone());

        CommandResult result = this.undoneCommand.execute("undone hello");
        String expectedResponse = "\"hello\" is marked as undone.";

        assertEquals(expectedResponse, result.getFeedback());
    }
}
```
###### /java/linenux/command/ViewCommandTest.java
``` java
/**
 * JUnit test for view command.
 */
public class ViewCommandTest {
    private Schedule schedule;
    private ViewCommand viewCommand;
    private Task task1;
    private Task task2;

    @Before
    public void setupListCommand() {
        this.schedule = new Schedule();
        this.viewCommand = new ViewCommand(this.schedule);
    }

    public void setupTaskWithAndWithoutReminders() {
        this.task1 = new Task("Task1");
        this.task2 = new Task("Task2");
        this.schedule.addTask(task1);
        this.schedule.addTask(task2);
        ArrayList<Reminder> reminders = this.task2.getReminders();
        reminders.add(new Reminder("Attend Workshop 1", LocalDateTime.of(2016, 1, 1, 17, 0)));
        reminders.add(new Reminder("Attend Workshop 2", LocalDateTime.of(2016, 2, 1, 17, 0)));
        reminders.add(new Reminder("Attend Workshop 3", LocalDateTime.of(2016, 3, 1, 17, 0)));
    }

    public CommandResult setupMultipleHelloTaskAndExecuteAmbiguousCommand() {
        this.schedule.addTask(new Task("hello it's me"));
        this.schedule.addTask(new Task("hello from the other side"));
        return this.viewCommand.execute("view hello");
    }

    /**
     * Test that command responds to the correct format.
     */
    @Test
    public void respondTo_inputThatBeginsWithView_trueReturned() {
        assertTrue(this.viewCommand.respondTo("view keyword"));
    }

    /**
     * Test that command is case insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.viewCommand.respondTo("ViEw keyword"));
    }

    /**
     * Test that command does not respond to other commands.
     */
    @Test
    public void respondTo_otherCommand_falseReturned() {
        assertFalse(this.viewCommand.respondTo("notview"));
    }

    /**
     * Test the result when no match is found.
     */
    @Test
    public void execute_noMatch_commandResultReturned() {
        this.schedule.addTask(new Task("asdjkahsdkjhasjdkh"));
        CommandResult result = this.viewCommand.execute("view that nasty todo");
        assertEquals("Cannot find task names with \"that nasty todo\".", result.getFeedback());
    }

    /**
     * Test the result when only one match is found and tasks does not have reminders.
     */
    @Test
    public void execute_oneMatch_viewThatTask() {
        this.setupTaskWithAndWithoutReminders();
        CommandResult result = this.viewCommand.execute("view Task1");
        assertEquals("Task1" + '\n' + "Reminders:" + '\n' + "You have not set any reminders for this task.", result.getFeedback());
    }

    /**
     * Test the result when only one match is found and task has reminders.
     */
    @Test
    public void execute_oneMatchWithReminders_commandResultReturned() {
        this.setupTaskWithAndWithoutReminders();
        CommandResult result = this.viewCommand.execute("view Task2");
        assertEquals("Task2\n" + "Reminders:\n"
            + "1. Attend Workshop 1 (On 2016-01-01 5.00PM)\n"
            + "2. Attend Workshop 2 (On 2016-02-01 5.00PM)\n"
            + "3. Attend Workshop 3 (On 2016-03-01 5.00PM)", result.getFeedback());
    }

    /**
     * Test the result when multiple matches are found.
     */
    @Test
    public void execute_multipleMatches_commandResultReturned() {
        CommandResult result = this.setupMultipleHelloTaskAndExecuteAmbiguousCommand();
        assertEquals("Which one? (1-2, \"cancel\" to cancel the current operation)\n1. hello it's me\n2. hello from the other side", result.getFeedback());
    }

    /**
     * Test that command is wating user response.
     */
    @Test
    public void isAwaitingUserResponse_multipleMatches_trueReturned() {
        assertFalse(this.viewCommand.isAwaitingUserResponse());
        this.setupMultipleHelloTaskAndExecuteAmbiguousCommand();
        assertTrue(this.viewCommand.isAwaitingUserResponse());
    }

    /**
     * Test that cancel works properly.
     */
    @Test
    public void processUserResponse_cancel_isNotAwaitingUserResponse() {
        this.setupMultipleHelloTaskAndExecuteAmbiguousCommand();
        CommandResult result = this.viewCommand.processUserResponse("cancel");
        assertEquals("OK! Not viewing any task.", result.getFeedback());
        assertFalse(this.viewCommand.isAwaitingUserResponse());
    }

    /**
     * Test that reminder is added if user selects a valid index.
     */
    @Test
    public void processUserResponse_validIndex_viewSelectedTask() {
        this.setupMultipleHelloTaskAndExecuteAmbiguousCommand();
        CommandResult result = this.viewCommand.processUserResponse("1");
        assertEquals("hello it's me\nReminders:\nYou have not set any reminders for this task.", result.getFeedback());
        assertFalse(this.viewCommand.isAwaitingUserResponse());
    }

    /**
     * Test that reminder is not added if user selects an invalid index.
     */
    @Test
    public void processUserResponse_invalidIndex_commandResultReturned() {
        this.setupMultipleHelloTaskAndExecuteAmbiguousCommand();
        CommandResult result = this.viewCommand.processUserResponse("0");
        String expectedResponse = "That's not a valid index. Enter a number between 1 and 2, or \"cancel\" to cancel the current operation:\n" +
                "1. hello it's me\n2. hello from the other side";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.viewCommand.isAwaitingUserResponse());
    }

    /**
     * Test that reminder is not added if user puts an invalid response.
     */
    @Test
    public void processUserResponse_invalidResponse_commandResultReturned() {
        this.setupMultipleHelloTaskAndExecuteAmbiguousCommand();
        CommandResult result = this.viewCommand.processUserResponse("notindex");
        String expectedResponse = "I don't understand \"notindex\".\n" + "Enter a number to indicate which task to view.\n" +
                "1. hello it's me\n2. hello from the other side";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.viewCommand.isAwaitingUserResponse());
    }
}
```
###### /java/linenux/gui/DefaultFocusTest.java
``` java
public class DefaultFocusTest extends GuiTest {
    @Test
    public void commandBox_checkDefaultFocus_commandBoxFocused() {
        verifyThat("#textField", isFocused());
    }
}
```
###### /java/linenux/time/parser/TodayWithTimeParserTest.java
``` java
/**
 * JUnit test for TodayWithTime time format.
 */
public class TodayWithTimeParserTest {
    private TimeParser parser;

    @Before
    public void setupParser() {
        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));
        TodayWithTimeParser parser = new TodayWithTimeParser();
        parser.setClock(clock);
        this.parser = parser;
    }

    /**
     * Test that parser responds to valid format.
     */
    @Test
    public void respondTo_validInputFormat_trueReturned() {
        assertTrue(this.parser.respondTo("today 2.05PM"));
    }

    /**
     * Test that parser responds to lowercase am and pm.
     */
    @Test
    public void respondTo_lowerCaseAmPm_trueReturned() {
        assertTrue(this.parser.respondTo("today 2.05am"));
        assertTrue(this.parser.respondTo("today 2.06pm"));
    }

    /**
     * Test that parser responds to uppercase today.
     */
    @Test
    public void respondTo_upperCaseToday_trueReturned() {
        assertTrue(this.parser.respondTo("TODAY 2.05am"));
    }

    /**
     * Test that parser responds to mixed case today.
     */
    @Test
    public void respondTo_mixedCaseToday_trueReturned() {
        assertTrue(this.parser.respondTo("TodAy 2.05am"));
    }

    /**
     * Test that parser responds to invalid format.
     */
    @Test
    public void respondTo_invalidInputFormat_falseReturned() {
        assertFalse(this.parser.respondTo("Jan 1, 2016 2:05PM"));
        assertFalse(this.parser.respondTo("yesterday"));
        assertFalse(this.parser.respondTo("2:05PM"));
        assertFalse(this.parser.respondTo("2016-01-01"));
        assertFalse(this.parser.respondTo("2016-01-01 14:00"));
    }

    @Test
    public void testParse_validInput_correctOutputReturned() {
        LocalDateTime output = this.parser.parse("today 5.00PM");
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 00), output);
    }
}
```
