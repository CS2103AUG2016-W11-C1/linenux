# A0127694U
###### /java/linenux/command/DeleteCommandTest.java
``` java
/**
 * JUnit test for delete command.
 */
public class DeleteCommandTest {
    private Schedule schedule;
    private DeleteCommand deleteCommand;

    @Before
    public void setupDeleteCommand() {
        this.schedule = new Schedule();
        this.deleteCommand = new DeleteCommand(this.schedule);
    }

    private void setupMultipleHelloTasksAndExecuteAmbiguousCommand() {
        this.schedule.addTask(new Task("hello world"));
        this.schedule.addTask(new Task("say hello"));
        this.deleteCommand.execute("delete hello");
    }

    /**
     * Test that respondTo detects various versions of the commands. It should return true even if
     * the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputThatStartsWithDelete_trueReturned() {
        assertTrue(this.deleteCommand.respondTo("delete"));
        assertTrue(this.deleteCommand.respondTo("delete    "));
        assertTrue(this.deleteCommand.respondTo("delete hello"));
    }

    /**
     * Test that the delete command is case insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.deleteCommand.respondTo("dElEte hello"));
    }

    /**
     * Test that respondTo will return false for commands not related to delete tasks.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.deleteCommand.respondTo("walala"));
    }

    /**
     * Test invalid arguments.
     */
    @Test
    public void execute_invalidArgument_commandResultReturned() {
        CommandResult result1 = this.deleteCommand.execute("delete");
        CommandResult result2 = this.deleteCommand.execute("delete ");
        CommandResult result3 = this.deleteCommand.execute("delete      ");

        assertEquals(expectedInvalidArgumentMessage(), result1.getFeedback());
        assertEquals(expectedInvalidArgumentMessage(), result2.getFeedback());
        assertEquals(expectedInvalidArgumentMessage(), result3.getFeedback());
    }

    /**
     * Test the feedback when no match is found.
     */
    @Test
    public void execute_taskNotFound_commandResultReturned() {
        this.schedule.addTask(new Task("flkasdjfaklsdfjaldf"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.execute("delete that nasty todo"));
        assertEquals("Cannot find task names with \"that nasty todo\".", result.getFeedback());
    }

    /**
     * Test the feedback when only one match is found.
     */
    @Test
    public void execute_oneMatchFound_taskDeleted() {
        this.schedule.addTask(new Task("hello"));
        this.schedule.addTask(new Task("i can' type"));
        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().size(),
                -1,
                () -> this.deleteCommand.execute("delete hello"));
        assertEquals("Deleted \"hello\".", result.getFeedback());
    }

    /**
     * Test the feedback when multiple matches are found.
     */
    @Test
    public void execute_multipleMatches_commandResultReturned() {
        this.schedule.addTask(new Task("hello world"));
        this.schedule.addTask(new Task("say hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.execute("delete hello"));
        assertEquals("Which one? (1-2, \"cancel\" to cancel the current operation)\n1. hello world\n2. say hello", result.getFeedback());
    }

    /**
     * Test the command is awaiting user response when multiple matches are found.
     */
    @Test
    public void isAwaitingUserResponse_multipleMatches_trueReturned() {
        assertFalse(this.deleteCommand.isAwaitingUserResponse());
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        assertTrue(this.deleteCommand.isAwaitingUserResponse());
    }

    /**
     * Test that cancel works properly.
     */
    @Test
    public void processUserResponse_cancel_isNotAwaitingUserResponse() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.processUserResponse("cancel"));
        assertEquals("OK! Not deleting anything.", result.getFeedback());
        assertFalse(this.deleteCommand.isAwaitingUserResponse());
    }

    /**
     * Test that task is deleted if user selects a valid index.
     */
    @Test
    public void processUserResponse_validIndex_taskDeleted() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertChangeBy(() -> this.schedule.getTaskList().size(),
                -1,
                () -> this.deleteCommand.processUserResponse("1"));
        assertEquals("Deleted \"hello world\".", result.getFeedback());
        assertFalse(this.deleteCommand.isAwaitingUserResponse());
    }

    /**
     * Test that task is not deleted if user selects an invalid index.
     */
    @Test
    public void processUserResponse_invalidIndex_commandResultReturned() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.processUserResponse("0"));
        String expectedResponse = "That's not a valid index. Enter a number between 1 and 2, or \"cancel\" to cancel the current operation:\n" +
                "1. hello world\n2. say hello";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.deleteCommand.isAwaitingUserResponse());
    }

    /**
     * Test that task is not deleted if user types an invalid response.
     */
    @Test
    public void processUserResponse_invalidInput_commandResultReturned() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.deleteCommand.processUserResponse("roses are red"));
        String expectedResponse = "I don't understand \"roses are red\".\n" +
                "Enter a number to indicate which task to delete.\n1. hello world\n2. say hello";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.deleteCommand.isAwaitingUserResponse());
    }

    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + this.deleteCommand.getCommandFormat() + "\n\n" + Command.CALLOUTS;
    }
}
```
###### /java/linenux/command/DeleteReminderCommandTest.java
``` java
/**
 * JUnit test for deleter command.
 */
public class DeleteReminderCommandTest {
    private Schedule schedule;
    private DeleteReminderCommand deleteReminderCommand;

    @Before
    public void setupDeleterCommand() {
        this.schedule = new Schedule();
        this.deleteReminderCommand = new DeleteReminderCommand(this.schedule);
    }

    private void setupMultipleRemindersAndExecuteAmbiguousCommand() {
        Task task1 = new Task("hello world");
        task1.getReminders().add(new Reminder("wash up", LocalDateTime.of(2016, 11, 1, 17, 0)));
        this.schedule.addTask(task1);
        Task task2 = new Task("hello");
        task2.getReminders().add(new Reminder("wash laundry", LocalDateTime.of(2016, 12, 1, 3, 0)));
        task2.getReminders().add(new Reminder("wash car", LocalDateTime.of(2016, 12, 2, 3, 0)));
        this.schedule.addTask(task2);
        this.deleteReminderCommand.execute("deleter wash");
    }

    /**
     * Test that respondTo detects various versions of the commands. It should
     * return true even if the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputThatStartsWithDeleter_trueReturned() {
        assertTrue(this.deleteReminderCommand.respondTo("deleter"));
        assertTrue(this.deleteReminderCommand.respondTo("deleter    "));
        assertTrue(this.deleteReminderCommand.respondTo("deleter hello"));
    }

    /**
     * Test that the deleter command is case insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.deleteReminderCommand.respondTo("dElEteR hello"));
    }

    /**
     * Test that respondTo will return false for commands not related to deleter
     * tasks.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.deleteReminderCommand.respondTo("walala"));
    }

    /**
     * Test invalid arguments.
     */
    @Test
    public void excute_invalidArguments_commandResultReturned() {
        CommandResult result1 = this.deleteReminderCommand.execute("deleter");
        CommandResult result2 = this.deleteReminderCommand.execute("deleter ");
        CommandResult result3 = this.deleteReminderCommand.execute("deleter      ");

        assertEquals(expectedInvalidArgumentMessage(), result1.getFeedback());
        assertEquals(expectedInvalidArgumentMessage(), result2.getFeedback());
        assertEquals(expectedInvalidArgumentMessage(), result3.getFeedback());
    }

    /**
     * Test the feedback when no match is found.
     */
    @Test
    public void execute_noMatch_commandResultReturned() {
        this.schedule.clear();
        this.schedule.getTaskList().add(new Task("task!"));

        CommandResult result = assertNoChange(() -> this.schedule.getReminderList().size(),
                () -> this.deleteReminderCommand.execute("deleter that nasty reminder"));
        assertEquals("Cannot find reminders with \"that nasty reminder\".", result.getFeedback());
    }

    /**
     * Test the feedback when only one match is found.
     */
    @Test
    public void execute_oneMatch_reminderDeleted() {
        this.schedule.clear();
        Task task1 = new Task("hello");
        task1.getReminders().add(new Reminder("world", LocalDateTime.of(2016, 12, 1, 18, 0)));
        this.schedule.addTask(task1);
        Task task2 = new Task("new world");
        task2.getReminders().add(new Reminder("begins", LocalDateTime.of(2016, 12, 3, 2, 0)));

        CommandResult result = assertChangeBy(() -> this.schedule.getReminderList().size(), -1,
                () -> this.deleteReminderCommand.execute("deleter world"));
        assertEquals("Deleted reminder \"world (On 2016-12-01 6.00PM)\" from task \"hello\".", result.getFeedback());
    }

    /**
     * Test the feedback when multiple matches are found.
     */
    @Test
    public void execute_multipleMatches_commandResultReturned() {
        Task task1 = new Task("hello world");
        task1.getReminders().add(new Reminder("hello", LocalDateTime.of(2017, 1, 1, 0, 0)));
        this.schedule.addTask(task1);
        Task task2 = new Task("say hello");
        task2.getReminders().add(new Reminder("hello again", LocalDateTime.of(2017, 1, 5, 3, 0)));
        this.schedule.addTask(task2);
        CommandResult result = assertNoChange(() -> this.schedule.getReminderList().size(),
                () -> this.deleteReminderCommand.execute("deleter hello"));
        assertEquals(
                "Which one? (1-2, \"cancel\" to cancel the current operation)\nTask: hello world\n1. hello (On 2017-01-01 12.00AM)\nTask: say hello\n2. hello again (On 2017-01-05 3.00AM)",
                result.getFeedback());
    }

    /**
     * Test the command is awaiting user response when multiple matches are
     * found.
     */
    @Test
    public void isAwaitingUserResponse_multipleMatches_trueReturned() {
        assertFalse(this.deleteReminderCommand.isAwaitingUserResponse());
        this.setupMultipleRemindersAndExecuteAmbiguousCommand();
        assertTrue(this.deleteReminderCommand.isAwaitingUserResponse());
    }

    /**
     * Test that cancel works properly.
     */
    @Test
    public void processUserResponse_cancel_isNotAwaitingUserResponse() {
        this.setupMultipleRemindersAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getReminderList().size(),
                () -> this.deleteReminderCommand.processUserResponse("cancel"));
        assertEquals("OK! Not deleting anything.", result.getFeedback());
        assertFalse(this.deleteReminderCommand.isAwaitingUserResponse());
    }

    /**
     * Test that reminder is deleted if user selects a valid index.
     */
    @Test
    public void processUserResponse_validIndex_reminderDeleted() {
        this.setupMultipleRemindersAndExecuteAmbiguousCommand();
        CommandResult result = assertChangeBy(() -> this.schedule.getReminderList().size(), -1,
                () -> this.deleteReminderCommand.processUserResponse("1"));
        assertEquals("Deleted reminder \"wash up (On 2016-11-01 5.00PM)\" from task \"hello world\".",
                result.getFeedback());
        assertFalse(this.deleteReminderCommand.isAwaitingUserResponse());
    }

    /**
     * Test that reminder is not deleted if user selects an invalid index.
     */
    @Test
    public void processUserResponse_invalidIndex_commandResultReturned() {
        this.setupMultipleRemindersAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getReminderList().size(),
                () -> this.deleteReminderCommand.processUserResponse("0"));
        String expectedResponse = "That's not a valid index. Enter a number between 1 and 3, or \"cancel\" to cancel the current operation:\n"
                + "Task: hello world\n1. wash up (On 2016-11-01 5.00PM)\nTask: hello\n2. wash laundry (On 2016-12-01 3.00AM)\n3. wash car (On 2016-12-02 3.00AM)";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.deleteReminderCommand.isAwaitingUserResponse());
    }

    /**
     * Test that task is not deleted if user types an invalid response.
     */
    @Test
    public void processUserResponse_invalidResponse_commandResultReturned() {
        this.setupMultipleRemindersAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getReminderList().size(),
                () -> this.deleteReminderCommand.processUserResponse("roses are red"));
        String expectedResponse = "I don't understand \"roses are red\".\n"
                + "Enter a number to indicate which reminder to delete.\nTask: hello world\n1. wash up (On 2016-11-01 5.00PM)\nTask: hello\n2. wash laundry (On 2016-12-01 3.00AM)\n3. wash car (On 2016-12-02 3.00AM)";
        assertEquals(expectedResponse, result.getFeedback());
        assertTrue(this.deleteReminderCommand.isAwaitingUserResponse());
    }

    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + this.deleteReminderCommand.getCommandFormat() + "\n\n" + Command.CALLOUTS;
    }

}
```
###### /java/linenux/command/EditCommandTest.java
``` java
/**
 * JUnit test for edit command.
 */
public class EditCommandTest {
    private Schedule schedule;
    private EditCommand editCommand;

    @Before
    public void setupEditCommand() {
        this.schedule = new Schedule();
        this.editCommand = new EditCommand(this.schedule);
    }

    private void setupMultipleHelloTasksAndExecuteAmbiguousCommand() {
        this.schedule.addTask(new Task("hello world"));
        this.schedule.addTask(new Task("say hello"));
        this.editCommand.execute("edit hello n/CS2103T Tutorial");
    }

    /**
     * Test that respondTo detects various versions of the commands. It should
     * return true even if the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputThatStartsWithEdit_trueReturned() {
        assertTrue(this.editCommand.respondTo("edit"));
        assertTrue(this.editCommand.respondTo("edit #/"));
        assertTrue(this.editCommand.respondTo("edit #/tag"));
        assertTrue(this.editCommand.respondTo("edit #/tag #/"));
        assertTrue(this.editCommand.respondTo("edit #/tag #/anothertag"));

        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial #/tag"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial #/tag #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial #/tag #/anothertag"));

        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project #/tag"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project #/tag #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project #/tag #/anothertag"));

        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial st/2016-01-01"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial st/2016-01-01 #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial st/2016-01-01 #/tag"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial st/2016-01-01 #/tag #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial st/2016-01-01 #/tag #/anothertag"));

        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial et/2016-01-01"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial et/2016-01-01 #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial et/2016-01-01 #/tag"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial et/2016-01-01 #/tag #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial et/2016-01-01 #/tag #/anothertag"));

        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project st/2016-01-01"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project st/2016-01-01 #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2013T Project st/2016-01-01 #/tag"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project st/2016-01-01 #/tag #/"));
        assertTrue(
                this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project st/2016-01-01 #/tag #/anothertag"));

        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project et/2016-01-01"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project et/2016-01-01 #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project et/2016-01-01 #/tag"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project et/2016-01-01 #/tag #/"));
        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project et/2016-01-01 #/tag #/tag"));

        assertTrue(this.editCommand.respondTo("edit CS2103T Tutorial n/CS2103T Project st/2016-01-01 et/2016-01-01"));
        assertTrue(this.editCommand
                .respondTo("edit CS2103T Tutorial n/CS2103T Project st/2016-01-01 et/2016-01-01 #/tag"));
    }

    /**
     * Test that respondTo is case-insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.editCommand.respondTo("EdIT CS2103T Tutorial N/hello"));
    }

    /**
     * Test that respondTo will return false for commands not related to edit
     * tasks.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.editCommand.respondTo("halp"));
        assertFalse(this.editCommand.respondTo("editr"));
    }

    /**
     * Test that executing the edit task command will correctly edit existing
     * todo in schedule.
     *
     */
    @Test
    public void execute_editTodoName_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello"));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0,
                () -> this.editCommand.execute("edit hello n/CS2103T Tutorial"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should not have start time
        assertNull(editedTask.getStartTime());

        // The edited task should not have end time
        assertNull(editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly modify existing
     * Todo in schedule into a Deadline.
     *
     */
    @Test
    public void execute_addEndTimeToTodo_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello"));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0,
                () -> this.editCommand.execute("edit hello n/CS2103T Tutorial et/2016-01-01 5.00PM"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should not have start time
        assertNull(editedTask.getStartTime());

        // The edited task should have the new specified end time.
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly modify existing
     * Todo in schedule into an Event.
     *
     */
    @Test
    public void execute_addStartTimeAndEndTime_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello"));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0, () -> this.editCommand
                .execute("edit hello n/CS2103T Tutorial st/2016-01-01 5.00PM " + "et/2016-01-01 7.00PM"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should have the new specified start time
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), editedTask.getStartTime());

        // The edited task should have the new specified end time
        assertEquals(LocalDateTime.of(2016, 1, 1, 19, 0), editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly modify existing
     * Deadline in schedule to Todo.
     *
     */
    @Test
    public void execute_removeEndTimeFromDeadline_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello", null, LocalDateTime.of(2016, 1, 1, 17, 0)));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0,
                () -> this.editCommand.execute("edit hello n/CS2103T Tutorial et/-"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should not have start time
        assertNull(editedTask.getStartTime());

        // The edited task should not have end time
        assertNull(editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly edit existing
     * Deadline in schedule.
     *
     */
    @Test
    public void execute_updateDeadline_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello", null, LocalDateTime.of(2016, 1, 1, 17, 0)));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0,
                () -> this.editCommand.execute("edit hello n/CS2103T Tutorial et/2016-01-01 7.00PM"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should not have start time
        assertNull(editedTask.getStartTime());

        // The edited task should have the new specified end time
        assertEquals(LocalDateTime.of(2016, 1, 1, 19, 0), editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly modify existing
     * Deadline in schedule to Event.
     *
     */
    @Test
    public void execute_editEvent_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello", null, LocalDateTime.of(2016, 1, 1, 17, 0)));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0, () -> this.editCommand
                .execute("edit hello n/CS2103T Tutorial st/2016-01-01 5.00PM et/2016-01-01 7.00PM"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should have the new specified end time
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), editedTask.getStartTime());

        // The edited task should have the new specified end time
        assertEquals(LocalDateTime.of(2016, 1, 1, 19, 0), editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly modify existing
     * Event in schedule to Todo.
     *
     */
    @Test
    public void execute_removeStartTimeAndEndTimeFromEvent_taskUpdated() {
        this.schedule.clear();
        this.schedule
                .addTask(new Task("hello", LocalDateTime.of(2016, 1, 1, 15, 0), LocalDateTime.of(2016, 1, 1, 17, 0)));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0,
                () -> this.editCommand.execute("edit hello n/CS2103T Tutorial st/- et/-"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should not have start time
        assertNull(editedTask.getStartTime());

        // The edited task should not have end time
        assertNull(editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly modify existing
     * Event in schedule to Deadline.
     *
     */
    @Test
    public void execute_removeStartTimeFromEvent_taskUpdated() {
        this.schedule.clear();
        this.schedule
                .addTask(new Task("hello", LocalDateTime.of(2016, 1, 1, 15, 0), LocalDateTime.of(2016, 1, 1, 17, 0)));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0,
                () -> this.editCommand.execute("edit hello n/CS2103T Tutorial st/- et/2016-01-01 7.00PM"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should have the new specified end time
        assertNull(editedTask.getStartTime());

        // The edited task should have the new specified end time
        assertEquals(LocalDateTime.of(2016, 1, 1, 19, 0), editedTask.getEndTime());
    }

    /**
     * Test that executing the edit task command will correctly edit existing
     * Event in schedule.
     *
     */
    @Test
    public void execute_updateEvent_taskUpdated() {
        this.schedule.clear();
        this.schedule
                .addTask(new Task("hello", LocalDateTime.of(2016, 1, 1, 15, 0), LocalDateTime.of(2016, 1, 1, 17, 0)));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0, () -> this.editCommand
                .execute("edit hello n/CS2103T Tutorial st/2016-01-01 5.00PM et/2016-01-01 7.00PM"));

        // The edited task has correct name
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals("CS2103T Tutorial", editedTask.getTaskName());

        // The edited task should have the new specified start time
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), editedTask.getStartTime());

        // The edited task should have the new specified end time
        assertEquals(LocalDateTime.of(2016, 1, 1, 19, 0), editedTask.getEndTime());
    }

    /**
     * Tests that edit command successfully adds tags to existing untagged
     * tasks.
     *
     */
    @Test
    public void execute_addTag_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello"));
        assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello #/tag"));

        // Test that the edited task has the correct categories.
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals(1, editedTask.getTags().size());
        assertEquals("tag", editedTask.getTags().get(0));
    }

    /**
     * Tests that edit command successfully removes tags.
     *
     */
    @Test
    public void execute_removeTag_taskUpdated() {
        this.schedule.clear();
        ArrayList<String> existingCatList = new ArrayList<>();
        existingCatList.add("blah");
        this.schedule.addTask(new Task("hello", existingCatList));
        assertChangeBy(() -> this.schedule.getTaskList().get(0).getTags().size(), -1,
                () -> this.editCommand.execute("edit hello #/-"));

        // Test that the edited task has the correct categories.
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals(0, editedTask.getTags().size());
    }

    /**
     * Tests that edit command successfully overwrites tags of existing tagged
     * tasks with a single tag.
     *
     */
    @Test
    public void execute_updateTag_taskUpdated() {
        this.schedule.clear();
        ArrayList<String> existingCatList = new ArrayList<>();
        existingCatList.add("blah");
        this.schedule.addTask(new Task("hello", existingCatList));
        assertNoChange(() -> this.schedule.getTaskList().get(0).getTags().size(),
                () -> this.editCommand.execute("edit hello #/tag"));

        // Test that the edited task has the correct categories.
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals(1, editedTask.getTags().size());
        assertEquals("tag", editedTask.getTags().get(0));
    }

    /**
     * Tests that edit command successfully overwrites tags of existing tagged
     * tasks with multiple tags.
     *
     */
    @Test
    public void execute_updateTags_taskUpdated() {
        this.schedule.clear();
        ArrayList<String> existingCatList = new ArrayList<>();
        existingCatList.add("blah");
        this.schedule.addTask(new Task("hello", existingCatList));
        assertChangeBy(() -> this.schedule.getTaskList().get(0).getTags().size(), 1,
                () -> this.editCommand.execute("edit hello #/tag1 #/tag2"));

        // Test that the edited task has the correct categories.
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals(2, editedTask.getTags().size());
        assertEquals("tag1", editedTask.getTags().get(0));
        assertEquals("tag2", editedTask.getTags().get(1));
    }

    /**
     * Tests that edit command leaves tags untouched when no modification to
     * tags is made.
     *
     */
    @Test
    public void execute_noUpdateToTags_tagsNotUpdated() {
        this.schedule.clear();
        ArrayList<String> existingCatList = new ArrayList<>();
        existingCatList.add("blah");
        this.schedule.addTask(new Task("hello", existingCatList));
        assertNoChange(() -> this.schedule.getTaskList().get(0).getTags().size(),
                () -> this.editCommand.execute("edit hello n/blah"));

        // Test that the edited task has the correct categories.
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);
        assertEquals(1, editedTask.getTags().size());
        assertEquals("blah", editedTask.getTags().get(0));
    }

    /**
     * Tests that editing tags of existing tagged tasks returns correct message.
     *
     */
    @Test
    public void execute_editTag_commandResultReturned() {
        ArrayList<String> existingCatList = new ArrayList<>();
        existingCatList.add("tag");
        this.schedule.addTask(new Task("hello", existingCatList));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello #/tag"));

        String expectedResponse = "Edited \"hello\".\nNew task details: hello [Tags: \"tag\" ]";
        assertEquals(expectedResponse, result.getFeedback());
    }

    @Test
    public void execute_multipleMatches_commandResultReturned() {
        this.schedule.addTask(new Task("hello world"));
        this.schedule.addTask(new Task("say hello"));

        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello n/CS2103T Tutorial"));

        assertEquals("Which one? (1-2, \"cancel\" to cancel the current operation)\n1. hello world\n2. say hello", result.getFeedback());
    }

    @Test
    public void isAwaitingUserResponse_multipleMatches_trueReturned() {
        assertFalse(this.editCommand.isAwaitingUserResponse());
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        assertTrue(this.editCommand.isAwaitingUserResponse());
    }

    @Test
    public void processUserResponse_cancel_isNotAwaitingUserResponse() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.processUserResponse("cancel"));
        assertEquals("OK! Not editing anything.", result.getFeedback());
        assertFalse(this.editCommand.isAwaitingUserResponse());
    }

    @Test
    public void processUserResponse_validIndex_taskUpdated() {
        this.schedule.clear();
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.processUserResponse("1"));
        assertEquals("Edited \"hello world\".\nNew task details: CS2103T Tutorial", result.getFeedback());
    }

    @Test
    public void processUserResponse_invalidIndex_commandResultReturned() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.processUserResponse("0"));
        String expectedResponse = "That's not a valid index. Enter a number between 1 and 2, or \"cancel\" to cancel the current operation:\n"
                + "1. hello world\n2. say hello";
        assertEquals(expectedResponse, result.getFeedback());
    }

    @Test
    public void processUserResponse_invalidResponse_commandResultReturned() {
        this.setupMultipleHelloTasksAndExecuteAmbiguousCommand();
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.processUserResponse("roses are red"));
        String expectedResponse = "I don't understand \"roses are red\".\n"
                + "Enter a number to indicate which task to edit.\n1. hello world\n2. say hello";
        assertEquals(expectedResponse, result.getFeedback());
    }

    /**
     * Test that arguments entered in wrong order will be stored in the correct
     * order.
     *
     */
    @Test
    public void execute_flagsSuffled_taskUpdated() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello"));
        assertChangeBy(() -> this.schedule.getTaskList().size(), 0, () -> this.editCommand
                .execute(
                        "edit hello et/2016-01-02 5.00PM n/CS2103T Tutorial #/tag1 tag2 st/2016-01-01 5.00PM #/tag3"));

        // The new event has the correct name, start time, and end time
        ArrayList<Task> tasks = this.schedule.getTaskList();
        Task editedTask = tasks.get(0);

        assertEquals("CS2103T Tutorial", editedTask.getTaskName());
        assertEquals(LocalDateTime.of(2016, 1, 1, 17, 0), editedTask.getStartTime());
        assertEquals(LocalDateTime.of(2016, 1, 2, 17, 0), editedTask.getEndTime());

        assertEquals(2, editedTask.getTags().size());
        assertEquals("tag1 tag2", editedTask.getTags().get(0));
        assertEquals("tag3", editedTask.getTags().get(1));
    }

    @Test
    public void execute_invalidStartTime_commandResultReturned() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello st/yesterday et/2016-12-31 11.59PM"));

        assertEquals("Cannot parse \"yesterday\".", result.getFeedback());
    }

    @Test
    public void execute_invalidEndTime_commandResultReturned() {
        this.schedule.clear();
        this.schedule.addTask(new Task("hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello et/tomorrow"));

        assertEquals("Cannot parse \"tomorrow\".", result.getFeedback());
    }

    @Test
    public void execute_startTimeWithoutEndTime_commandResultReturned() {
        this.schedule.addTask(new Task("hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello st/2016-01-01 5.00PM"));

        assertEquals("Cannot create task with start time but without end time.", result.getFeedback());
    }

    @Test
    public void execute_endTimeBeforeStartTime_commandResultReturned() {
        this.schedule.addTask(new Task("hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello st/2016-01-02 5.00PM et/2016-01-01 5.00PM"));

        assertEquals("End time cannot come before start time.", result.getFeedback());
    }

    /**
     * Test that edit command will correctly reject input when there are no
     * keywords and arguments.
     *
     */
    @Test
    public void execute_noKeywords_commandResultReturned() {
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit "));
        assertEquals(expectedInvalidArgumentMessage() , result.getFeedback());
    }

    /**
     * Test that edit command will correctly reject input when there are no
     * arguments.
     *
     */
    @Test
    public void execute_noFlags_taskNotUpdated() {
        this.schedule.addTask(new Task("hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello "));
        assertEquals("No changes to be made!", result.getFeedback());
    }

    /**
     * Test the result when the task name consists of only empty spaces
     */
    @Test
    public void execute_emptyUpdatedName_commandResultReturned() {
        this.schedule.addTask(new Task("hello"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit hello n/            "));
        assertEquals(expectedInvalidArgumentMessage(), result.getFeedback());
    }

    /**
     * Test that edit command will correctly reject input with no matching
     * keywords.
     */
    @Test
    public void execute_noMatch_commandResultReturned() {
        this.schedule.addTask(new Task("flkasdjfaklsdfjaldf"));
        CommandResult result = assertNoChange(() -> this.schedule.getTaskList().size(),
                () -> this.editCommand.execute("edit that nasty todo n/new name"));
        assertEquals("Cannot find task names with \"that nasty todo\".", result.getFeedback());
    }

    //@@ A0140702X
    /**
     * Test that ensures command will not edit will not create duplicate task.
     */
    @Test
    public void execute_deplicatedTasks_commandResultReturned() {
        this.schedule.addTask(new Task("todo"));
        this.schedule.addTask(new Task("deadline", LocalDateTime.of(2016, 1, 1, 17, 0)));
        this.schedule
                .addTask(new Task("event", LocalDateTime.of(2016, 1, 1, 17, 0), LocalDateTime.of(2017, 1, 1, 17, 0)));

        Task toEdit = new Task("toedit");
        this.schedule.addTask(toEdit);

        CommandResult result = this.editCommand.execute("edit toedit n/todo");
        assertEquals("todo already exists in the schedule!", result.getFeedback());

        CommandResult result2 = this.editCommand.execute("edit toedit n/deadline et/2016-01-01 5.00PM");
        assertEquals("deadline (Due 2016-01-01 5.00PM) already exists in the schedule!", result2.getFeedback());

        CommandResult result3 = this.editCommand
                .execute("edit toedit n/event st/2016-01-01 5.00PM et/2017-01-01 5.00PM");
        assertEquals("event (2016-01-01 5.00PM - 2017-01-01 5.00PM) already exists in the schedule!",
                result3.getFeedback());
    }

    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + this.editCommand.getCommandFormat() + "\n\n" + Command.CALLOUTS;
    }
}
```
###### /java/linenux/command/InformationCommandTest.java
``` java
public class InformationCommandTest {
    public static final String VERSION_NO = "v0.0";
    public static final String DEFAULT_FILE_PATH = Paths.get(".").toAbsolutePath().toString();
    public static final String CONFIG_FILENAME = "ConfigTest.json";
    public static final String SCHEDULE_FILENAME = "ScheduleTest.xml";

    private InformationCommand informationCommand;
    private JsonConfig config;

    @Before
    public void setupInformationCommand() {
        this.config = new JsonConfig(VERSION_NO, DEFAULT_FILE_PATH + CONFIG_FILENAME,
                DEFAULT_FILE_PATH + SCHEDULE_FILENAME);
        this.informationCommand = new InformationCommand(this.config);
    }

    /**
     * Test that respondTo detects various versions of the commands. It should
     * return true even if the format of the arguments are invalid.
     */
    @Test
    public void respondTo_information_trueReturned() {
        assertTrue(this.informationCommand.respondTo("information"));
    }

    /**
     * Test that respondTo is case-insensitive.
     */
    @Test
    public void respondTo_upperCase_trueReturned() {
        assertTrue(this.informationCommand.respondTo("inFORMatIon"));
    }

    /**
     * Test that respondTo will return false for commands not related to add
     * tasks.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.informationCommand.respondTo("halp"));
    }

    /**
     * Test information command.
     */
    @Test
    public void execute_validInput_commandResultReturned() {
        CommandResult result = this.informationCommand.execute("information");
        String output = "Version: " + VERSION_NO + "\n\nCurrent Working Directory: \n"
                + Paths.get("").toAbsolutePath().toString() + "\n\nCurrent Schedule Location: \n" + DEFAULT_FILE_PATH
                + SCHEDULE_FILENAME;
        assertEquals(output, result.getFeedback());
    }

    @After
    public void removeConfigFile() {
        File configFile = new File(DEFAULT_FILE_PATH + CONFIG_FILENAME);
        configFile.delete();
    }
}
```
###### /java/linenux/command/parser/GenericParserTest.java
``` java
public class GenericParserTest {
    private GenericParser parser;

    @Before
    public void setupParser() {
        this.parser = new GenericParser();
    }

    @Test
    public void parseKeywords_noFlags_keywordsReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello world");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void parseKeywords_spacesWithNoFlags_trimmedKeywordsReturned() {
        GenericParser.GenericParserResult result = parser.parse("   hello world    ");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void parseKeywords_withFlags_keywordsReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/12345");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void parseKeywords_spacesWithFlags_trimmedKeywordsReturned() {
        GenericParser.GenericParserResult result = parser.parse("  hello world      st/12345");
        assertEquals("hello world", result.getKeywords());
    }

    @Test
    public void parseFlags_singleFlag_flagReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/12345");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("12345", flagValues.get(0));
    }

    @Test
    public void parseFlags_repeatedFlags_flagsReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/12345 st/67890");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(2, flagValues.size());
        assertEquals("12345", flagValues.get(0));
        assertEquals("67890", flagValues.get(1));
    }

    @Test
    public void parseFlags_repeatedButSeparatedFlags_flagsReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/1 et/2 st/3");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(2, flagValues.size());
        assertEquals("1", flagValues.get(0));
        assertEquals("3", flagValues.get(1));
        flagValues = result.getArguments("et");
        assertEquals(1, flagValues.size());
        assertEquals("2", flagValues.get(0));
    }

    @Test
    public void parseFlags_nonWordsFlags_flagsReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello world #/yo #/foo");
        ArrayList<String> flagValues = result.getArguments("#");
        assertEquals(2, flagValues.size());
        assertEquals("yo", flagValues.get(0));
        assertEquals("foo", flagValues.get(1));
    }

    @Test
    public void parseFlags_multiWordsFlagValue_flagsReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello world st/Jan 1 et/Jan 2");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("Jan 1", flagValues.get(0));
        flagValues = result.getArguments("et");
        assertEquals(1, flagValues.size());
        assertEquals("Jan 2", flagValues.get(0));
    }

    @Test
    public void parseFlags_emptyFlagValue_flagReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello st/");
        assertEquals("hello", result.getKeywords());
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("", flagValues.get(0));
    }

    @Test
    public void parseFlags_emptyFlagValueFollowByAnotherFlag_flagsReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello st/  et/12345");
        assertEquals("hello", result.getKeywords());
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("", flagValues.get(0));
        flagValues = result.getArguments("et");
        assertEquals(1, flagValues.size());
        assertEquals("12345", flagValues.get(0));
    }

    @Test
    public void parseFlags_flagValueContainsSlash_flagReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello st/2016/01/01");
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("2016/01/01", flagValues.get(0));
    }

    @Test
    public void parseFlags_flagValueWithTrailingSpaces_flagReturned() {
        GenericParser.GenericParserResult result = parser.parse("hello st/12345       ");
        ArrayList<String> flagValue = result.getArguments("st");
        assertEquals(1, flagValue.size());
        assertEquals("12345", flagValue.get(0));
    }

    @Test
    public void parseFlags_noKeywords_flagReturned() {
        GenericParser.GenericParserResult result = parser.parse("st/12345");
        assertEquals("", result.getKeywords());
        ArrayList<String> flagValues = result.getArguments("st");
        assertEquals(1, flagValues.size());
        assertEquals("12345", flagValues.get(0));
    }
}
```
###### /java/linenux/command/RenameCommandTest.java
``` java
/**
 * JUnit test for rename command.
 */
public class RenameCommandTest {
    private Schedule schedule;
    private RenameCommand renameCommand;

    @Before
    public void setUpRenameCommand() {
        this.schedule = new Schedule();
        this.renameCommand = new RenameCommand(this.schedule);
    }

    private void setUpSetOfTasksWithSameTags() {
        schedule.addTask(new Task("hello", ArrayListUtil.fromArray(new String[]{"adele", "happy"})));
        schedule.addTask(new Task("goodbye", ArrayListUtil.fromArray(new String[]{"adele", "tragedy"})));
        schedule.addTask(new Task("hugs", ArrayListUtil.fromArray(new String[]{"adele"})));
    }

    /**
     * Test that respondTo detects various versions of the commands. It should return true even if
     * the format of the arguments are invalid.
     */
    @Test
    public void respondTo_inputThatBeginsWithRename_trueReturned() {
        assertTrue(this.renameCommand.respondTo("rename"));
        assertTrue(this.renameCommand.respondTo("rename #/"));
        assertTrue(this.renameCommand.respondTo("rename #/hi #/bye"));
    }

    /**
     * Test that respondTo will return false for commands not related to add tasks.
     */
    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.renameCommand.respondTo("halp"));
    }

    /**
     * Test invalid command format.
     */
    @Test
    public void execute_invalidArgument_commandResultReturned() {
        assertEquals(expectedInvalidArgumentMessage(), this.renameCommand.execute("rename hi #/").getFeedback());
        assertEquals(expectedInvalidArgumentMessage(), this.renameCommand.execute("rename hi ").getFeedback());
        assertEquals(expectedInvalidArgumentMessage(), this.renameCommand.execute("rename").getFeedback());
    }

    /**
     * Test rename searches for case insensitive.
     */
    @Test
    public void execute_caseInsensitiveKeywords_correctTagIsChosen() {
        schedule.addTask(new Task("hugs", ArrayListUtil.fromSingleton("aDele")));
        schedule.addTask(new Task("punches", ArrayListUtil.fromSingleton("adele")));
        assertEquals("Edited tag \"adele\".\nNew tag name: swift", this.renameCommand.execute("rename adele #/swift").getFeedback());

        ArrayList<Task> taskList = this.schedule.getTaskList();
        assertTrue(taskList.get(0).getTags().contains("swift"));
        assertTrue(taskList.get(1).getTags().contains("swift"));
    }

    /**
     * Test execute no such tag in schedule.
     */
    @Test
    public void execute_tagNotFound_commandResultReturned() {
        setUpSetOfTasksWithSameTags();
        assertEquals("Cannot find tasks with tag \"hi\".", this.renameCommand.execute("rename hi #/bye").getFeedback());
    }

    /**
     * Test execute successfully renaming tags.
     */
    @Test
    public void execute_validInput_tagsRenamed() {
        setUpSetOfTasksWithSameTags();
        assertEquals("Edited tag \"adele\".\nNew tag name: swift", this.renameCommand.execute("rename adele #/swift").getFeedback());
        ArrayList<Task> taskList = this.schedule.getTaskList();

        assertTrue(taskList.get(0).getTags().contains("swift"));
        assertTrue(taskList.get(1).getTags().contains("swift"));
        assertTrue(taskList.get(2).getTags().contains("swift"));

        assertTrue(taskList.get(0).getTags().contains("happy"));
        assertTrue(taskList.get(1).getTags().contains("tragedy"));
    }

    private String expectedInvalidArgumentMessage() {
        return "Invalid arguments.\n\n" + RenameCommand.COMMAND_FORMAT + "\n\n" + Command.CALLOUTS;
    }
}
```
###### /java/linenux/command/TodayCommandTest.java
``` java
public class TodayCommandTest {
    private TodayCommand todayCommand;

    private Schedule schedule;
    private Task todo;
    private Task deadlineToday;
    private Task deadlineTomorrow;
    private Task eventYesterday;
    private Task eventTomorrow;
    private Task eventYesterdayToday;
    private Task eventTodayTomorrow;
    private Task eventYesterdayTomorrow;

    @Before
    public void setupCommand() {
        this.schedule = new Schedule();
        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));
        this.todayCommand = new TodayCommand(this.schedule, clock);

        this.todo = new Task("hello");
        this.deadlineToday = new Task("deadline 1", LocalDateTime.of(2016, 1, 1, 21, 0));
        this.deadlineTomorrow = new Task("deadline 2", LocalDateTime.of(2016, 1, 2, 21, 0));
        this.eventYesterday = new Task("event 1", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2015, 12, 31, 12, 0));
        this.eventTomorrow = new Task("event 2", LocalDateTime.of(2016, 1, 2, 10, 0), LocalDateTime.of(2016, 1, 2, 12, 0));
        this.eventYesterdayToday = new Task("event 3", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2016, 1, 1, 10, 0));
        this.eventTodayTomorrow = new Task("event 4", LocalDateTime.of(2016, 1, 1, 10, 0), LocalDateTime.of(2016, 1, 2, 10, 0));
        this.eventYesterdayTomorrow = new Task("event 5", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2016, 1, 2, 10, 0));

        this.schedule.addTask(this.todo);
        this.schedule.addTask(this.deadlineToday);
        this.schedule.addTask(this.deadlineTomorrow);
        this.schedule.addTask(this.eventYesterday);
        this.schedule.addTask(this.eventTomorrow);
        this.schedule.addTask(this.eventYesterdayToday);
        this.schedule.addTask(this.eventTodayTomorrow);
        this.schedule.addTask(this.eventYesterdayTomorrow);
    }

    @Test
    public void respondTo_inputThatBeginsWithToday_trueReturned() {
        assertTrue(this.todayCommand.respondTo("today"));
        assertTrue(this.todayCommand.respondTo("today hello"));
        assertTrue(this.todayCommand.respondTo("toDay"));
    }

    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.todayCommand.respondTo("atoday"));
        assertFalse(this.todayCommand.respondTo("todaya"));
        assertFalse(this.todayCommand.respondTo("toda"));
    }

    @Test
    public void execute_commandResultReturned() {
        this.todayCommand.execute("today");
        assertTrue(this.schedule.getFilteredTasks().contains(this.todo));
        assertTrue(this.schedule.getFilteredTasks().contains(this.deadlineToday));
        assertFalse(this.schedule.getFilteredTasks().contains(this.deadlineTomorrow));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventYesterday));
        assertFalse(this.schedule.getFilteredTasks().contains(this.eventTomorrow));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventYesterdayToday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventTodayTomorrow));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventYesterdayTomorrow));
    }
}
```
###### /java/linenux/command/TomorrowCommandTest.java
``` java
public class TomorrowCommandTest {
    private TomorrowCommand tomorrowCommand;

    private Schedule schedule;
    private Task todo;
    private Task deadlineToday;
    private Task deadlineTomorrow;
    private Task eventYesterday;
    private Task eventTomorrow;
    private Task eventYesterdayToday;
    private Task eventTodayTomorrow;

    @Before
    public void setupCommand() {
        this.schedule = new Schedule();
        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));
        this.tomorrowCommand = new TomorrowCommand(this.schedule, clock);

        this.todo = new Task("hello");
        this.deadlineToday = new Task("deadline 1", LocalDateTime.of(2016, 1, 1, 21, 0));
        this.deadlineTomorrow = new Task("deadline 2", LocalDateTime.of(2016, 1, 2, 21, 0));
        this.eventYesterday = new Task("event 1", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2015, 12, 31, 12, 0));
        this.eventTomorrow = new Task("event 2", LocalDateTime.of(2016, 1, 2, 10, 0), LocalDateTime.of(2016, 1, 2, 12, 0));
        this.eventYesterdayToday = new Task("event 3", LocalDateTime.of(2015, 12, 31, 10, 0), LocalDateTime.of(2016, 1, 1, 10, 0));
        this.eventTodayTomorrow = new Task("event 4", LocalDateTime.of(2016, 1, 1, 10, 0), LocalDateTime.of(2016, 1, 2, 10, 0));

        this.schedule.addTask(this.todo);
        this.schedule.addTask(this.deadlineToday);
        this.schedule.addTask(this.deadlineTomorrow);
        this.schedule.addTask(this.eventYesterday);
        this.schedule.addTask(this.eventTomorrow);
        this.schedule.addTask(this.eventYesterdayToday);
        this.schedule.addTask(this.eventTodayTomorrow);
    }

    @Test
    public void respondTo_inputThatBeginsWithTomorrow_trueReturned() {
        assertTrue(this.tomorrowCommand.respondTo("tomorrow"));
        assertTrue(this.tomorrowCommand.respondTo("tomorrow bla"));
        assertTrue(this.tomorrowCommand.respondTo("toMorrow"));
    }

    @Test
    public void respondTo_otherCommands_falseReturned() {
        assertFalse(this.tomorrowCommand.respondTo("tomorrowa"));
        assertFalse(this.tomorrowCommand.respondTo("atomorrow"));
        assertFalse(this.tomorrowCommand.respondTo("tomorro"));
    }

    @Test
    public void execute_commandResultReturned() {
        this.tomorrowCommand.execute("tomorrow");

        assertTrue(this.schedule.getFilteredTasks().contains(this.todo));
        assertFalse(this.schedule.getFilteredTasks().contains(this.deadlineToday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.deadlineTomorrow));
        assertFalse(this.schedule.getFilteredTasks().contains(this.eventYesterday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventTomorrow));
        assertFalse(this.schedule.getFilteredTasks().contains(this.eventYesterdayToday));
        assertTrue(this.schedule.getFilteredTasks().contains(this.eventTodayTomorrow));
    }
}
```
###### /java/linenux/control/TimeParserManagerTest.java
``` java
/**
 * JUnit test for time parser manager.
 */
public class TimeParserManagerTest {
    /**
     * Test that parses can correctly parse.
     */
    @Test
    public void canParse_trueOrFalseParser_trueWhenParserIsTrue() {
        TimeParser trueParser = new TimeParser() {
            @Override
            public boolean respondTo(String u) {
                return true;
            }

            @Override
            public LocalDateTime parse(String u) {
                return null;
            }
        };

        TimeParser falseParser = new TimeParser() {
            @Override
            public boolean respondTo(String u) {
                return false;
            }

            @Override
            public LocalDateTime parse(String u) {
                return null;
            }
        };

        TimeParserManager manager = new TimeParserManager(falseParser);
        assertFalse(manager.canParse("123123"));

        manager = new TimeParserManager(falseParser, trueParser);
        assertTrue(manager.canParse("1231231"));
    }
}
```
###### /java/linenux/model/ReminderTest.java
``` java
public class ReminderTest {
    @Test
    public void toString_reminderWithNote() {
        Reminder reminder = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        String expectedValue = "note (On 2016-01-01 5.00PM)";
        assertEquals(expectedValue, reminder.toString());
    }

    @Test
    public void toString_reminderWithoutNote() {
        Reminder reminder = new Reminder().setTimeOfReminder(LocalDateTime.of(2016, 1, 1, 17, 0));
        String expectedValue = "Reminder on 2016-01-01 5.00PM";
        assertEquals(expectedValue, reminder.toString());
    }

    @Test
    public void equals_otherObject_falseReturned() {
        Reminder reminder = new Reminder();
        assertFalse(reminder.equals(new Object()));
    }

    @Test
    public void equals_differentNote_falseReturned() {
        Reminder r1 = new Reminder("reminder 1", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder r2 = new Reminder("reminder 2", LocalDateTime.of(2016, 1, 1, 17, 0));
        assertFalse(r1.equals(r2));
    }

    @Test
    public void equals_differentTime_falseReturned() {
        Reminder r1 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder r2 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 1));
        assertFalse(r1.equals(r2));
    }

    @Test
    public void equals_sameNoteAndTime_trueReturned() {
        Reminder r1 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder r2 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        assertTrue(r1.equals(r2));
    }

    @Test
    public void equals_noteUpperCase_trueReturned() {
        Reminder r1 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder r2 = new Reminder("NOTE", LocalDateTime.of(2016, 1, 1, 17, 0));
        assertTrue(r1.equals(r2));
    }

    @Test
    public void hashCode_sameNoteAndTime_sameHashCode() {
        Reminder r1 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder r2 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        assertEquals(r1.hashCode(), r2.hashCode());
    }

    @Test
    public void hashCode_noteUpperCase_sameHashCode() {
        Reminder r1 = new Reminder("note", LocalDateTime.of(2016, 1, 1, 17, 0));
        Reminder r2 = new Reminder("NOTE", LocalDateTime.of(2016, 1, 1, 17, 0));
        assertEquals(r1.hashCode(), r2.hashCode());
    }
}
```
###### /java/linenux/time/parser/TomorrowWithTimeParserTest.java
``` java
/**
 * JUnit test for TomorrowWithTime time format.
 */
public class TomorrowWithTimeParserTest {
    private TimeParser parser;

    @Before
    public void setupParser() {
        Clock clock = Clock.fixed(Instant.parse("2016-01-01T07:24:00.00Z"), ZoneId.of("Asia/Singapore"));
        TomorrowWithTimeParser parser = new TomorrowWithTimeParser();
        parser.setClock(clock);
        this.parser = parser;
    }

    /**
     * Test that parser responds to valid format.
     */
    @Test
    public void respondTo_validInputFormat_trueReturned() {
        assertTrue(this.parser.respondTo("tomorrow 2.05PM"));
    }

    /**
     * Test that parser responds to lowercase am and pm.
     */
    @Test
    public void respondTo_lowerCaseAmPm_trueReturned() {
        assertTrue(this.parser.respondTo("tomorrow 2.05am"));
        assertTrue(this.parser.respondTo("tomorrow 2.05pm"));
    }

    /**
     * Test that parser responds to uppercase tomorrow.
     */
    @Test
    public void respondTo_upperCaseTomorrow_trueReturned() {
        assertTrue(this.parser.respondTo("TOMORROW 2.05am"));
    }

    /**
     * Test that parser responds to mixed case tomorrow.
     */
    @Test
    public void respondTo_mixedCaseTomorrow_trueReturned() {
        assertTrue(this.parser.respondTo("ToMorrOw 2.05am"));
    }

    /**
     * Test that parser responds to invalid format.
     */
    @Test
    public void respondTo_invalidInputFormat_falseReturned() {
        assertFalse(this.parser.respondTo("Jan 1, 2016 2:05PM"));
        assertFalse(this.parser.respondTo("yesterday"));
        assertFalse(this.parser.respondTo("2:05PM"));
        assertFalse(this.parser.respondTo("2016-01-01"));
        assertFalse(this.parser.respondTo("2016-01-01 14:00"));
    }

    @Test
    public void parse_validInput_correctOutputReturned() {
        LocalDateTime output = this.parser.parse("tomorrow 2.00PM");
        assertEquals(LocalDateTime.of(2016, 1, 2, 14, 00), output);
    }
}
```
###### /java/linenux/util/TimeIntervalTest.java
``` java
public class TimeIntervalTest {
    TimeInterval interval;

    @Before
    public void setupInterval() {
        this.interval = new TimeInterval(LocalDateTime.of(2016, 1, 1, 0, 0), LocalDateTime.of(2016, 12, 31, 23, 59));
    }

    @Test
    public void inInterval_timesInInterval_trueReturned() {
        assertTrue(this.interval.inInterval(LocalDateTime.of(2016, 1, 1, 0, 0)));
        assertTrue(this.interval.inInterval(LocalDateTime.of(2016, 1, 2, 0, 0)));
        assertTrue(this.interval.inInterval(LocalDateTime.of(2016, 12, 31, 23, 59)));
    }

    @Test
    public void inInterval_timesNotInInterval_falseReturned() {
        assertFalse(this.interval.inInterval(LocalDateTime.of(2015, 12, 31, 23, 59)));
        assertFalse(this.interval.inInterval(LocalDateTime.of(2017, 1, 1, 0, 0)));
    }

    @Test
    public void isTrivial_timeIntervalIsTrivial_trueReturned() {
        LocalDateTime time1 = LocalDateTime.of(2016, 1, 1, 0, 0);
        LocalDateTime time2 = LocalDateTime.of(2016, 1, 1, 0, 0);
        this.interval = new TimeInterval(time1, time2);
        assertTrue(this.interval.isTrivial());
    }

    @Test
    public void isTrivial_timeIntervalIsNotTrivial_falseReturned() {
        assertFalse(this.interval.isTrivial());
    }
}
```
