# A0135788M
###### /java/linenux/command/AliasCommand.java
``` java
/**
 * Creates an alias for commands.
 */
public class AliasCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "alias";
    private static final String DESCRIPTION = "Creates an alias for commands.";
    private static final String COMMAND_FORMAT = "alias COMMAND_NAME NEW_NAME";

    private static final String ALPHANUMERIC = "^[a-zA-Z0-9]*$";

    private ArrayList<Command> commands;

    /**
     * Constructs an {@code AliasCommand}.
     * @param commands An {@code ArrayList} of {@code Command} that can be aliased.
     */
    public AliasCommand(ArrayList<Command> commands) {
        this.commands = commands;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());

        String arguments = extractArgument(userInput);
        String[] commandNames = arguments.trim().split("\\s+");

        if (commandNames.length != 2) {
            return makeInvalidArgumentResult();
        }

        String command = commandNames[0];
        String alias = commandNames[1];

        if (!isValidCommand(command)) {
            return makeNoSuchCommandResult();
        }

        if (!isValidAlias(alias)) {
            return makeInvalidAliasResult();
        }

        if (!isAliasAvailable(alias)) {
            return makeAliasUsedForAnotherCommand(alias);
        }

        for (Command cmd: this.commands) {
            if (cmd.respondTo(command)) {
                cmd.setAlias(alias);
                break;
            }
        }

        return makeSuccessfulAliasResult(command, alias);
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * @param command A {@code String} representing a trigger word for some {@code Command}.
     * @return {@code true} if and only if there is some {@code Command} that respond to {@code command}.
     */
    private boolean isValidCommand(String command) {
        for (Command cmd: this.commands) {
            if (cmd.respondTo(command)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if {@code alias} is a valid alias.
     * @param alias A {@code String} representing the alias.
     * @return {@code true} if and only if {@code alias} is a valid alias.
     */
    private boolean isValidAlias(String alias) {
        Matcher matcher = Pattern.compile(ALPHANUMERIC).matcher(alias);
        return matcher.matches();
    }

    /**
     * Check if {@code alias} can be used as an alias.
     * @param alias A {@code String} representing the alias.
     * @return {@code true} if and only if {@code alias} is not used by some other {@code Command}.
     */
    private boolean isAliasAvailable(String alias) {
        for (Command cmd: this.commands) {
            if (cmd.respondTo(alias)) {
                return false;
            }
        }

        return true;
    }

    /**
     * @return A {@code CommandResult} indicating that the input format is invalid.
     */
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @return A {@code CommandResult} indicating that the {@code Command} that the user is trying to alias does not
     * exist.
     */
    private CommandResult makeNoSuchCommandResult() {
        return () -> "No such command to make alias for.";
    }

    /**
     * @return A {@code CommandResult} indicating that the alias that the user specified is not a valid alias.
     */
    private CommandResult makeInvalidAliasResult() {
        return () -> "Alias must be alphanumeric.";
    }

    /**
     * @param alias A {@code String} representing the alias the that user is trying to create.
     * @return A {@code CommandResult} indicating the {@code alias} is used for some other {@code Command}.
     */
    private CommandResult makeAliasUsedForAnotherCommand(String alias) {
        return () -> "\"" + alias + "\" is used for another command.";
    }

    /**
     * @param command The {@code Command} that {@code alias} is now pointing to.
     * @param alias A {@code String} representing the alias that the user is creating.
     * @return A {@code CommandResult} indicating that the alias is created.
     */
    private CommandResult makeSuccessfulAliasResult(String command, String alias) {
        return () -> alias + " is now the alias for the " + command + " command.";
    }
}
```
###### /java/linenux/command/Command.java
``` java
/**
 * All command types must support interface methods.
 */
public interface Command {
    public static final String CALLOUTS = "* Non-compulsory fields are in square brackets.\n* Arguments are case insensitive.";

    /**
     * Checks if the user input corresponds to the format of the respective
     * command.
     *
     * @param userInput
     * @return true if format matches and false otherwise.
     */
    public boolean respondTo(String userInput);

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    public CommandResult execute(String userInput);

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    default public boolean isAwaitingUserResponse() {
        return false;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    default public CommandResult processUserResponse(String userInput) {
        return null;
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    public String getTriggerWord();

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    public String getDescription();

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    public String getCommandFormat();

    /**
     * @return A {@code String} representing a regular expression for this {@code Command}.
     */
    public String getPattern();


    /**
     * Add a new alias.
     * @param alias The new alias.
     */
    public void setAlias(String alias);

    /**
     * Update the list of aliases.
     * @param aliases The new aliases.
     */
    public void setAliases(Collection<String> aliases);

    /**
     * Remove an alias.
     * @param alias The alias to remove.
     */
    public void removeAlias(String alias);

    /**
     * Returns the list of trigger words for that command.
     * @return an ArrayList of trigger words for that command.
     */
    public Set<String> getTriggerWords();
}
```
###### /java/linenux/command/DoneCommand.java
``` java
/**
 * Marks task as done.
 */
public class DoneCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "done";
    private static final String DESCRIPTION = "Marks a task as done.";
    private static final String COMMAND_FORMAT = "done KEYWORDS";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private ArrayList<Task> foundTasks;

    /**
     * Constructs an {@code AliasCommand}.
     * @param schedule The {@code Schedule} to search and update {@code Task} from.
     */
    public DoneCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = new ArrayListUtil.ChainableArrayListUtil<>(this.schedule.search(keywords))
                .filter(Task::isNotDone)
                .value();

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            this.schedule.updateTask(task, task.markAsDone());
            return makeDoneTask(task);
        } else {
            setResponse(true, tasks);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                this.schedule.updateTask(task, task.markAsDone());

                setResponse(false, null);
                return makeDoneTask(task);
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Updates the user response status.
     * @param requiresUserResponse Whether or not this {@code Command} is expecting user response.
     * @param foundTasks An {@code ArrayList} of {@code Task} matching some search criteria.
     */
    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
    }

    /**
     * @return A {@code CommandResult} indicating that the user does not specify a keywords.
     */
    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @param task The {@code Task} that is marked as done.
     * @return A {@code CommandResult} informing the user that {@code task} has been marked as done.
     */
    private CommandResult makeDoneTask(Task task) {
        return () -> "\"" + task.getTaskName() + "\" is marked as done.";
    }

    /**
     * @return A {@code CommandResult} indicating that the done operation is cancelled.
     */
    private CommandResult makeCancelledResult() {
        return () -> "OK! Not marking any task as done.";
    }

    /**
     * @param userInput A {@code String} representing the user response.
     * @return A {@code CommandResult} indicating that {@code userInput} is invalid.
     */
    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to mark as done.\n");
            builder.append(ArrayListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/result/CommandResult.java
``` java
/**
 * An interface representing the result of executing a {@code Command}.
 */
public interface CommandResult {
    /**
     * @return A {@code String} that will be shown to the user.
     */
    public String getFeedback();
}
```
###### /java/linenux/command/UndoCommand.java
``` java
/**
 * Undo the previous command that mutated the state of the schedule.
 */
public class UndoCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "undo";
    private static final String DESCRIPTION = "Undo the previous command.";
    private static final String COMMAND_FORMAT = "undo";

    private Schedule schedule;

    public UndoCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        if (this.schedule.popState()) {
            return makeUndoSuccessfulMessage();
        } else {
            return makeUndoUnsuccessfulMessage();
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private CommandResult makeUndoSuccessfulMessage() {
        return () -> "Successfully undo last command.";
    }

    private CommandResult makeUndoUnsuccessfulMessage() {
        return () -> "No more commands to undo!";
    }

}
```
###### /java/linenux/command/ViewCommand.java
``` java
/**
 * Generates details of tasks and reminders attached to task based on userInput.
 */
public class ViewCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "view";
    private static final String DESCRIPTION = "Views details of specific task.";
    private static final String COMMAND_FORMAT = "view KEYWORDS";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private ArrayList<Task> foundTasks;

    public ViewCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(keywords);

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            return makeResult(task);
        } else {
            setResponse(true, tasks);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);

                setResponse(false, null);
                return makeResult(task);
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Updates the user response status.
     * @param requiresUserResponse Whether or not this {@code Command} is expecting user response.
     * @param foundTasks An {@code ArrayList} of {@code Task} matching some search criteria.
     */
    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
    }

    /**
     * @return A {@code CommandResult} indicating that the user does not specify a keywords.
     */
    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeResult(Task task) {
        ArrayList<Reminder> reminders = task.getReminders();
        StringBuilder builder = new StringBuilder();
        builder.append(task.toString());
        builder.append('\n');
        builder.append("Reminders:" + '\n');

        if (reminders.size() == 0) {
            builder.append("You have not set any reminders for this task.");
        } else {
            builder.append(ArrayListUtil.display(reminders));
        }

        return () -> builder.toString().trim();

    }

    /**
     * @return A {@code CommandResult} indicating that the view operation is cancelled.
     */
    private CommandResult makeCancelledResult() {
        return () -> "OK! Not viewing any task.";
    }

    /**
     * @param userInput A {@code String} representing the user response.
     * @return A {@code CommandResult} indicating that {@code userInput} is invalid.
     */
    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to view.\n");
            builder.append(ArrayListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/config/JsonConfig.java
``` java
/**
 * A JSON-backed config file.
 */
public class JsonConfig implements Config{
    public static final String VERSION_NO = "v0.5";
    public static final String DEFAULT_FILE_PATH = Paths.get(".").toAbsolutePath().toString();
    public static final String CONFIG_FILENAME = "Config.json";
    public static final String SCHEDULE_FILENAME = "Schedule.xml";

    private static final String VERSION_KEY = "versionNo";
    private static final String SCHEDULE_PATH_KEY = "schedulePath";
    private static final String ALIASES_KEY = "aliases";
    private static final Logger logger = LogsCenter.getLogger(JsonConfig.class);

    private Path configFilePath;
    private Path scheduleFilePath;
    private String verNo;

    private JSONObject configFile;

    public JsonConfig() {
        this(VERSION_NO, DEFAULT_FILE_PATH + CONFIG_FILENAME, DEFAULT_FILE_PATH + SCHEDULE_FILENAME);
    }

    public JsonConfig(String verNo, String configFilePath, String scheduleFilePath) {
        this.verNo = verNo;
        this.configFilePath = Paths.get(configFilePath);
        this.scheduleFilePath = Paths.get(scheduleFilePath);
        initialize();
    }

    /**
     * Initializes configuration file with default values;
     */
    private void initialize() {
        logger.info("Initializing config");
        JSONObject configFile;

        if (hasConfigFile()) {
            configFile = this.getConfigFile();
        } else {
            configFile = new JSONObject();
        }

        if (!configFile.has(VERSION_KEY)) {
            configFile.put(VERSION_KEY, verNo);
        }

        if (!configFile.has(SCHEDULE_PATH_KEY)) {
            logger.info("Initializing default schedule path");
            configFile.put(SCHEDULE_PATH_KEY, scheduleFilePath.toString());
        }

        this.configFile = configFile;
        this.saveConfig();
        logger.info("Done initializing config");
    }

    /**
     * @return The version of the program that created the config file.
     */
    @Override
    public String getVersionNo() {
        try {
            return this.getConfigFile().getString(VERSION_KEY);
        } catch (JSONException e) {
            return VERSION_NO;
        }
    }

    /**
     * @return The absolute path to the current schedule file.
     */
    @Override
    public String getScheduleFilePath() {
        try {
            return this.getConfigFile().getString(SCHEDULE_PATH_KEY);
        } catch (JSONException e) {
            return DEFAULT_FILE_PATH + SCHEDULE_FILENAME;
        }
    }

    /**
     * @param path The absolute path to the new schedule file.
     */
    @Override
    public void setScheduleFilePath(String path) {
        this.getConfigFile().put(SCHEDULE_PATH_KEY, path);
        this.saveConfig();
    }

    /**
     * @return Whether or not the config file is present.
     */
    @Override
    public boolean hasConfigFile() {
        return Files.exists(configFilePath);
    }

    /**
     * @param triggerWord The original trigger word of a command.
     * @return A {@code Collection} of aliases for that command.
     */
    @Override
    public Collection<String> getAliases(String triggerWord) {
        JSONObject configFile = this.getConfigFile();
        JSONObject aliasesMap;

        if (configFile.has(ALIASES_KEY)) {
            aliasesMap = configFile.getJSONObject(ALIASES_KEY);
        } else {
            aliasesMap = new JSONObject();
        }

        ArrayList<String> output = new ArrayList<>();
        if (aliasesMap.has(triggerWord)) {
            JSONArray triggerWords = aliasesMap.getJSONArray(triggerWord);
            for (int i = 0; i < triggerWords.length(); i++) {
                try {
                    output.add(triggerWords.getString(i));
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
        }

        return output;
    }

    /**
     * @param triggerWord The original trigger word of a command.
     * @param aliases A {@code Collection} of aliases for that command.
     */
    @Override
    public void setAliases(String triggerWord, Collection<String> aliases) {
        JSONObject aliasesMap;

        if (this.configFile.has(ALIASES_KEY)) {
            aliasesMap = this.configFile.getJSONObject(ALIASES_KEY);
        } else {
            aliasesMap = new JSONObject();
        }

        aliasesMap.put(triggerWord, aliases);
        this.configFile.put(ALIASES_KEY, aliasesMap);

        this.saveConfig();
    }

    /**
     * Lazily instantiate the {@code configFile} object.
     * @return A {@code JSONObject} representing the config.
     */
    private JSONObject getConfigFile() {
        if (this.configFile == null) {
            this.configFile = new JSONObject();

            try {
                JSONTokener tokener = new JSONTokener(new FileReader(configFilePath.toString()));
                this.configFile = new JSONObject(tokener);
            } catch (IOException e) {
                Alerts.alertAndDie("Error Reading Config File", "Config file is not readable at\n" + configFilePath.toString());
            } catch (JSONException e) {
                boolean recover = Alerts.alertAndConfirm("Error Parsing Config File", "Config file cannot be parsed at\n" + configFilePath + "\nOverwrite with defaults?");
                if (!recover) {
                    System.exit(1);
                }
            }
        }

        return this.configFile;
    }

    /**
     * Save the config into a JSON file.
     */
    private void saveConfig() {
        logger.info("Saving config");
        try {
            FileWriter file = new FileWriter(configFilePath.toString());
            file.write(configFile.toString());
            file.flush();
            file.close();
        } catch (IOException i) {
            logger.severe(ThrowableUtil.getStackTrace(i));
            Alerts.alertAndDie("Error Saving Config File", "Config file cannot be saved at " + configFilePath.toString());
        }
        logger.info("Done saving config");
    }
}
```
###### /java/linenux/control/ControlUnit.java
``` java
/**
 * Controls data flow for the entire application.
 */
public class ControlUnit {
    private Schedule schedule;
    private ScheduleStorage scheduleStorage;
    private CommandManager commandManager;
    private ObjectProperty<CommandResult> lastCommandResult = new SimpleObjectProperty<>();
    private Config config;
    private ArrayList<BiConsumer<String, CommandResult>> postExecuteListeners = new ArrayList<>();

    /**
     * Constructs a {@code ControlUnit} from a {@code Config}.
     * @param config A {@code Config} representing the application configuration.
     */
    public ControlUnit(Config config) {
        this.scheduleStorage = new XmlScheduleStorage(config);
        this.schedule = (this.scheduleStorage.hasScheduleFile()) ? this.scheduleStorage.loadScheduleFromFile() : new Schedule();
        this.commandManager = new CommandManager();
        this.config = config;

        this.initializeCommands();
        this.initializeAliases();
    }

    /**
     * Constructs a {@code ControlUnit} from {@code ScheduleStorage}, {@code Config}, and {@code CommandManager}.
     * @param storage The {@code ScheduleStorage} class that will be used to store {@code Schedule}.
     * @param config The application configuration.
     * @param commandManager The {@code CommandManager} that should be used.
     */
    public ControlUnit(ScheduleStorage storage, Config config, CommandManager commandManager) {
        this.scheduleStorage = storage;
        this.schedule = this.scheduleStorage.loadScheduleFromFile();
        this.config = config;
        this.commandManager = commandManager;
    }

    /**
     * Executes a user command.
     * @param userInput A {@code String}, which is the user input.
     * @return A {@code CommandResult} containing feedback for the user.
     */
    public CommandResult execute(String userInput) {
        CommandResult result = commandManager.delegateCommand(userInput);
        lastCommandResult.setValue(result);
        this.saveSchedule();
        for (Command command: this.commandManager.getCommandList()) {
            this.config.setAliases(command.getTriggerWord(), command.getTriggerWords());
        }

        for (BiConsumer<String, CommandResult> listener: this.postExecuteListeners) {
            listener.accept(userInput, result);
        }

        return result;
    }

    /**
     * @return The current {@code Schedule}.
     */
    public Schedule getSchedule() {
        return this.schedule;
    }

    /**
     * @return The application configuration.
     */
    public Config getConfig() {
        return (this.config);
    }

    /**
     * @return A reactive object which encapsulate the latest {@code CommandResult} shown to the user.
     */
    public ObjectProperty<CommandResult> getLastCommandResultProperty() {
        return this.lastCommandResult;
    }

    /**
     * @return An {@code ArrayList} of supported {@code Command}.
     */
    public ArrayList<Command> getCommandList() {
        return commandManager.getCommandList();
    }

    /**
     * Update the path to the schedule file.
     * @param path The absolute path to the new file.
     */
    public void setScheduleFilePath(String path) {
        this.config.setScheduleFilePath(path);
    }

    /**
     * Save the current {@code Schedule} into the file.
     */
    public void saveSchedule() {
        this.scheduleStorage.saveScheduleToFile(schedule);
    }

    /**
     * Load the current {@code Schedule} from file.
     */
    public void loadSchedule() {
        Schedule schedule;

        if (this.scheduleStorage.hasScheduleFile()) {
            schedule = this.scheduleStorage.loadScheduleFromFile();
        } else {
            schedule = new Schedule();
        }

        this.schedule.update(schedule);
    }

    /**
     * Add a listener that will be executed every time a command is processed.
     * @param listener A function that takes in the user input and the {@code CommandResult}.
     */
    public void addPostExecuteListener(BiConsumer<String, CommandResult> listener) {
        this.postExecuteListeners.add(listener);
    }

    /**
     * Setup aliases for the commands based on what's in the config file.
     */
    private void initializeAliases() {
        for (Command command: this.commandManager.getCommandList()) {
            command.setAliases(this.config.getAliases(command.getTriggerWord()));
        }
    }

    /**
     * Setup the default set of commands.
     */
    private void initializeCommands() {
        this.commandManager.addCommand(new AddCommand(this.schedule));
        this.commandManager.addCommand(new EditReminderCommand(this.schedule));
        this.commandManager.addCommand(new DeleteReminderCommand(this.schedule));
        this.commandManager.addCommand(new EditCommand(this.schedule));
        this.commandManager.addCommand(new RenameCommand(this.schedule));
        this.commandManager.addCommand(new DoneCommand(this.schedule));
        this.commandManager.addCommand(new UndoneCommand(this.schedule));
        this.commandManager.addCommand(new RemindCommand(this.schedule));
        this.commandManager.addCommand(new DeleteCommand(this.schedule));
        this.commandManager.addCommand(new ClearCommand(this.schedule));

        this.commandManager.addCommand(new ListCommand(this.schedule));
        this.commandManager.addCommand(new ViewCommand(this.schedule));
        this.commandManager.addCommand(new TodayCommand(this.schedule));
        this.commandManager.addCommand(new TomorrowCommand(this.schedule));

        this.commandManager.addCommand(new SaveCommand(this));
        this.commandManager.addCommand(new LoadCommand(this));

        this.commandManager.addCommand(new UndoCommand(this.schedule));
        this.commandManager.addCommand(new FreeTimeCommand(this.schedule));
        this.commandManager.addCommand(new HelpCommand(this.commandManager.getCommandList()));
        this.commandManager.addCommand(new AliasCommand(this.commandManager.getCommandList()));
        this.commandManager.addCommand(new UnaliasCommand(this.commandManager.getCommandList()));
        this.commandManager.addCommand(new ExitCommand());
        this.commandManager.addCommand(new InformationCommand(this.config));

        this.commandManager.setCatchAllCommand(new InvalidCommand(this));
    }
}
```
###### /java/linenux/Main.java
``` java
/**
 * Main program for Linenux.
 */
public class Main extends Application {
    public static final String APP_NAME = "Linenux";

    private static Logger logger = LogsCenter.getLogger(Main.class);

    protected Config config = new JsonConfig();

    @Override
    public void start(Stage primaryStage) {
        logger.info("Setting up main window");
        setupMainWindow(primaryStage);
    }

    /**
     * Setup the main window
     * @param primaryStage The stage where the window will live in.
     */
    private void setupMainWindow(Stage primaryStage) {
        try {
            FXMLLoader loader = setUpLoader();
            Scene scene = new Scene(loader.load());
            setUpStage(primaryStage);
            primaryStage.setScene(scene);
            primaryStage.show();
        } catch (Exception e) {
            logger.severe(ThrowableUtil.getStackTrace(e));
            Alerts.alertAndDie("Fatal Error", "Unable to initialize main window.");
        }
    }

    /**
     * Setup the loader to load the main window.
     * @return An {@code FXMLLoader} with the correct locations set.
     */
    private FXMLLoader setUpLoader() {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(Main.class.getResource("/view/MainWindow.fxml"));
        loader.setController(new MainWindowController(this.config));
        return loader;
    }

    /**
     * Setup the stage for the application to live in.
     * @param primaryStage The {@code Stage} to setup.
     */
    private void setUpStage(Stage primaryStage) {
        primaryStage.setTitle(APP_NAME);
        primaryStage.getIcons().add(new Image("/images/terminal.png"));
        primaryStage.setMaximized(true);;
    }
}
```
###### /java/linenux/model/adapted/AdaptedReminder.java
``` java
@XmlRootElement(name = "Reminder")
@XmlType(propOrder = { "note", "timeOfReminder" })
public class AdaptedReminder {
    @XmlElement(name = "note")
    private String note;

    @XmlElement(name = "timeOfReminder")
    @XmlJavaTypeAdapter(LocalDateTimeAdapter.class)
    private LocalDateTime timeOfReminder;

    /**
     * Empty constructor for XML use.
     */
    public AdaptedReminder() {
    }

    /**
     * Converts a reminder to an XML-friendly reminder object.
     * @param r A {@code reminder} instance.
     * @return an XML-friendly reminder object.
     */
    public AdaptedReminder convertToXml(Reminder r) {
        this.note = r.getNote();
        this.timeOfReminder = r.getTimeOfReminder();
        return this;
    }

    /**
     * Converts an XML-friendly reminder object to a reminder.
     * @return a reminder object.
     */
    public Reminder convertToModel() {
        return new Reminder(note, timeOfReminder);
    }
}
```
###### /java/linenux/model/adapted/AdaptedSchedule.java
``` java
@XmlRootElement(name = "Schedule")
public class AdaptedSchedule {
    @XmlElement(name = "state")
    private AdaptedState state;

    /**
     * Empty constructor for XML use.
     */
    public AdaptedSchedule() {
    }

    /**
     * Converts a schedule to an XML-friendly schedule object.
     * @param r A {@code schedule} instance.
     * @return an XML-friendly schedule object.
     */
    public AdaptedSchedule convertToXml(Schedule sch) {
        this.state = new AdaptedState();
        this.state.convertToXml(sch.getStates().get(sch.getStates().size() - 1));
        return this;
    }

    /**
     * Converts an XML-friendly schedule object to a schedule.
     * @return a schedule object.
     */
    public Schedule convertToModel() {
        return new Schedule(state.convertToModel());
    }
}
```
###### /java/linenux/model/adapted/AdaptedState.java
``` java
@XmlRootElement(name = "State")
public class AdaptedState {
    @XmlElement(name = "tasks")
    private ArrayList<AdaptedTask> tasks;

    /**
     * Empty constructor for XML use.
     */
    public AdaptedState() {
    }

    /**
     * Converts a state to an XML-friendly state object.
     * @param r A {@code state} instance.
     * @return an XML-friendly state object.
     */
    public AdaptedState convertToXml(State s) {
        this.tasks = new ArrayList<>();
        for (Task t : s.getTaskList()) {
            tasks.add(new AdaptedTask().convertToXml(t));
        }
        return this;
    }

    /**
     * Converts an XML-friendly state object to a state.
     * @return a state object.
     */
    public State convertToModel() {
        ArrayList<Task> newTasks = new ArrayList<>();
        for (AdaptedTask t : tasks) {
            newTasks.add(t.convertToModel());
        }
        return new State(newTasks);
    }
}
```
###### /java/linenux/model/adapted/AdaptedTask.java
``` java
@XmlRootElement(name = "Task")
@XmlType(propOrder = { "taskName", "isDone", "startTime", "endTime", "tags", "reminders" })
public class AdaptedTask {
    @XmlElement(name = "taskName")
    private String taskName;

    @XmlElement(name = "isDone")
    private boolean isDone;

    @XmlElement(name = "startTime", nillable = true)
    @XmlJavaTypeAdapter(LocalDateTimeAdapter.class)
    private LocalDateTime startTime;

    @XmlElement(name = "endTime", nillable = true)
    @XmlJavaTypeAdapter(LocalDateTimeAdapter.class)
    private LocalDateTime endTime;

    @XmlElement(name = "tags")
    @XmlElementWrapper
    private ArrayList<String> tags;

    @XmlElement(name = "reminders")
    @XmlElementWrapper
    private ArrayList<AdaptedReminder> reminders;

    /**
     * Empty constructor for XML use.
     */
    public AdaptedTask() {
    }

    /**
     * Converts a reminder to an XML-friendly task object.
     * @param r A {@code task} instance.
     * @return an XML-friendly task object.
     */
    public AdaptedTask convertToXml(Task t) {
        this.taskName = t.getTaskName();
        this.isDone = t.isDone();
        this.startTime = t.getStartTime();
        this.endTime = t.getEndTime();
        this.tags = t.getTags();
        this.reminders = new ArrayList<>();
        for (Reminder r : t.getReminders()) {
            reminders.add(new AdaptedReminder().convertToXml(r));
        }
        return this;
    }

    /**
     * Converts an XML-friendly task object to a task.
     * @return a task object.
     */
    public Task convertToModel() {
        ArrayList<Reminder> newReminders = new ArrayList<>();
        for (AdaptedReminder r : reminders) {
            newReminders.add(r.convertToModel());
        }
        return new Task(taskName, isDone, startTime, endTime, tags, newReminders);
    }
}
```
###### /java/linenux/model/Schedule.java
``` java
/**
 * Contains all outstanding tasks.
 */
public class Schedule {
    public static final int MAX_STATES = 10;
    private final ObservableList<State> states = FXCollections.observableArrayList();
    private final ObservableList<ArrayList<Task>> filteredTaskList = FXCollections.observableArrayList();

    /**
     * Constructs an empty schedule
     */
    public Schedule() {
        this.states.add(new State());
    }

    public Schedule(State s) {
        this.states.add(s);
    }

    /**
     * Adds a task to the schedule
     */
    public void addTask(Task task) {
        addState(getMostRecentState().addTask(task));
    }

    /**
     * Replace {@code originalTask} with {@code newTask}.
     * @param originalTask The original task.
     * @param newTask The new ask.
     */
    public void updateTask(Task originalTask, Task newTask) {
        addState(getMostRecentState().updateTask(originalTask, newTask));
    }

    public void updateTask(ArrayList<Task> originalTasks, ArrayList<Task> newTasks) {
        addState(getMostRecentState().updateTasks(originalTasks, newTasks));
    }

    /**
     * Delete the specified task.
     *
     * @param task The task to delete.
     */
    public void deleteTask(Task task) {
        addState(getMostRecentState().deleteTask(task));
    }

    /**
     * Deletes the specified reminder.
     *
     * @param reminder
     *            The reminder to delete.
     */
    public void deleteReminder(ReminderSearchResult reminder) {
        addState(getMostRecentState().deleteReminder(reminder));
    }

    /**
     * Delete the specified list of tasks.
     *
     * @param tasks
     *            The tasks to delete.
     */
    public void deleteTasks(ArrayList<Task> tasks) {
        State newState = getMostRecentState();

        for (Task task : tasks) {
            newState = newState.deleteTask(task);
        }

        addState(newState);
    }

    /**
     * Clears all tasks from the schedule
     */
    public void clear() {
        State newState = new State();
        addState(newState);
    }

    public ArrayList<Task> search(String keywords) {
        return search(keywords.split("\\s+"));
    }

    /**
     * Performs case-insensitive task search using keywords.
     *
     * @param keywords
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
    public ArrayList<Task> search(String[] keywords) {
        return getMostRecentState().search(keywords);
    }

    /**
     * Performs case-insensitive tag search using keywords.
     *
     * @param tagName Tag name to look for.
     * @return List of {@code Task} with tags matching the keywords.
     */
    public ArrayList<Task> searchTag(String tagName) {
        return getMostRecentState().searchTag(tagName);
    }

    /**
     * Search reminders based on keywords.
     * @param keywords The keywords to search for.
     * @return An {@code ArrayList} of {@code Reminder} matching the keywords.
     */
    public ArrayList<Reminder> searchReminder(String keywords) {
        return searchReminder(keywords.split("\\s+"));
    }

    /**
     * Performs case-insensitive reminder search using keywords.
     *
     * @param keywords Search keywords
     * @return List of {@code Reminder} matching the keywords.
     */
    public ArrayList<Reminder> searchReminder(String[] keywords) {
        return getMostRecentState().searchReminder(keywords);
    }

    /**
     * Checks if the task given is a unique task.
     */
    public boolean isUniqueTask(Task task) {
        ArrayList<Task> taskList = getMostRecentState().getTaskList();
        ArrayList<Task> duplicateTaskList = new ArrayListUtil.ChainableArrayListUtil<>(taskList)
                .filter(a -> a.equals(task)).value();

        if (duplicateTaskList.size() >= 1) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Returns the list of states.
     */
    public ObservableList<State> getStates() {
        return states;
    }

    public ObservableList<ArrayList<Task>> getFilteredTaskList() {
        return filteredTaskList;
    }

    /**
     * Returns the list of tasks.
     */
    public ArrayList<Task> getTaskList() {
        return getMostRecentState().getTaskList();
    }

    /**
     * Returns the list of filtered tasks.
     */
    public ArrayList<Task> getFilteredTasks() {
        if (filteredTaskList.isEmpty()) {
            return getTaskList();
        }

        return filteredTaskList.get(0);
    }

    /**
     * Returns the list of all task reminders.
     */
    public ArrayList<Reminder> getReminderList() {
        ArrayList<Reminder> result = new ArrayList<>();
        for (Task t : getMostRecentState().getTaskList()) {
            result.addAll(t.getReminders());
        }

        return result;
    }

    /**
     * Remove the last state if there are more than one.
     *
     * @return {@code true} if and only if a state is removed.
     */
    public boolean popState() {
        if (states.size() > 1) {
            states.remove(states.size() - 1);
            return true;
        }
        return false;
    }

    /**
     * Replace the content of the schedule with another schedule.
     */
    public void update(Schedule other) {
        this.states.setAll(other.states);
        this.filteredTaskList.setAll(other.filteredTaskList);
    }

    /**
     * Adds a new list of filtered tastes into filteredTaskList
     * @param filteredTasks
     */
    public void addFilterTasks(ArrayList<Task> filteredTasks) {
        filteredTaskList.clear();
        filteredTaskList.add(filteredTasks);
    }

    /**
     * Returns the most recent state of schedule
     */
    private State getMostRecentState() {
        return states.get(states.size() - 1);
    }

    /**
     * Adds a new state to states.
     * @param state
     */
    private void addState(State state) {
        while (states.size() + 1 > MAX_STATES && states.size() > 1) {
            states.remove(0);
        }
        states.add(state);
    }
}
```
###### /java/linenux/model/State.java
``` java
/**
 * Represents a snapshot in time of a schedule. The State class is immutable.
 */
public class State {
    private final ArrayList<Task> tasks;

    /**
     * Construct an empty {@code State}.
     */
    public State(){
        this.tasks = new ArrayList<>();
    }

    /**
     * Copy constructor.
     * @param other The {@code State} to copy from.
     */
    public State(State other) {
        this.tasks = new ArrayList<>(other.tasks);
    }

    /**
     * Construct a {@code State} with the given list of tasks.
     * @param taskList An {@code ArrayList} of {@code Task}.
     */
    public State(ArrayList<Task> taskList) {
        this.tasks = taskList;
    }

    /**
     * Adds a task to the schedule
     * @param task The task to add.
     * @return The new State of the schedule.
     */
    public State addTask(Task task) {
        State output = new State(this);
        output.tasks.add(task);
        return output;
    }

    /**
     * Updates the specified task.
     *
     * @param originalTask The original version of the specified task.
     * @param newTask The edited version of the specified task.
     */
    public State updateTask(Task originalTask, Task newTask) {
        int taskIndex = tasks.indexOf(originalTask);
        State output = new State(this);
        output.tasks.set(taskIndex, newTask);
        return output;
    }

    /**
     * Updates the specified task.
     *
     * @param originalTasks
     *            The original version of the specified task.
     * @param newTasks
     *            The edited version of the specified task.
     */
    public State updateTasks(ArrayList<Task> originalTasks, ArrayList<Task> newTasks) {
        State output = new State(this);
        for (int i = 0; i < originalTasks.size(); i++) {
            int taskIndex = tasks.indexOf(originalTasks.get(i));
            output.tasks.set(taskIndex, newTasks.get(i));
        }
        return output;
    }

    /**
     * Delete the specified task.
     *
     * @param task
     *            The task to delete.
     * @return The new State of the schedule.
     */
    public State deleteTask(Task task) {
        int taskIndex = tasks.indexOf(task);
        State output = new State(this);
        output.tasks.remove(taskIndex);
        return output;
    }

    /**
     * Delete the specified reminder.
     *
     * @param reminder
     *            The reminder to delete.
     * @return The new State of the schedule.
     */
    public State deleteReminder(ReminderSearchResult reminder) {
        assert (reminder.getReminders().size() == 1);

        int taskIndex = this.tasks.indexOf(reminder.getTask());
        int reminderIndex = this.tasks.get(taskIndex).getReminders().indexOf(reminder.getReminders().get(0));
        State output = new State(this);
        output.tasks.get(taskIndex).getReminders().remove(reminderIndex);
        return output;
    }

    /**
     * Returns the list of tasks.
     */
    public ArrayList<Task> getTaskList() {
        return tasks;
    }

    /**
     * Performs case-insensitive task search using keywords.
     *
     * @param keywords
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
    public ArrayList<Task> search(String[] keywords) {
        ArrayList<String> keywordsList = new ArrayListUtil.ChainableArrayListUtil<>(keywords)
                .map(String::toLowerCase)
                .value();

        return new ArrayListUtil.ChainableArrayListUtil<>(this.tasks)
                .filter(task -> { ArrayList<String> taskKeywords =
                        new ArrayListUtil.ChainableArrayListUtil<>(task.getTaskName().split("\\s+"))
                                .map(String::toLowerCase)
                                .value();
                    return !Collections.disjoint(keywordsList, taskKeywords);
                })
                .value();
    }

    /**
     * Performs case-insensitive reminder search using keywords.
     *
     * @param keywords
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
    public ArrayList<Reminder> searchReminder(String[] keywords) {
        ArrayList<Reminder> result = new ArrayList<>();

        for (Task t : this.tasks) {
            result.addAll(searchReminder(keywords, t));
        }

        return result;
    }

    /**
     * Search reminders based on keywords.
     * @param keywords The search keywords.
     * @param task The task whose reminders will form the search space.
     * @return An {@code ArrayList} of {@code Reminder} matching the keywords.
     */
    public ArrayList<Reminder> searchReminder(String[] keywords, Task task) {
        ArrayList<String> keywordsList = new ArrayListUtil.ChainableArrayListUtil<>(keywords)
                .map(String::toLowerCase).value();

        return new ArrayListUtil.ChainableArrayListUtil<>(task.getReminders()).filter(reminder -> {
            ArrayList<String> reminderKeywords = new ArrayListUtil.ChainableArrayListUtil<>(
                    reminder.getNote().split("\\s+")).map(String::toLowerCase).value();
            return !Collections.disjoint(keywordsList, reminderKeywords);
        }).value();
    }

    /**
     * Performs case-insensitive tag search using keywords.
     *
     * @param tagName
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
    public ArrayList<Task> searchTag(String tagName) {
        ArrayList<Task> result = this.tasks;

        result = new ArrayListUtil.ChainableArrayListUtil<>(result).filter(task -> task.hasTag(tagName)).value();

        return result;
    }
}
```
###### /java/linenux/model/Task.java
``` java
/**
 * Represents a task in the schedule. Only taskName is a required field and
 * cannot be an empty string.
 */
public class Task {
    private String taskName;
    private boolean isDone;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private ArrayList<String> tags;
    private ArrayList<Reminder> reminders;

    /**
     * Constructor for tagged To-Dos (tasks with no deadlines or predetermined
     * time slots).
     *
     * @param taskName
     */
    public Task(String taskName) {
        this(taskName, new ArrayList<String>());
    }

    /**
     * Constructor for tagged Deadlines (tasks with deadlines only).
     *
     * @param taskName
     * @param endTime
     */
    public Task(String taskName, LocalDateTime endTime) {
        this(taskName, endTime, new ArrayList<String>());
    }

    /**
     * Constructor for tagged Events (tasks with predetermined time slots).
     *
     * @param taskName
     * @param startTime
     * @param endTime
     */
    public Task(String taskName, LocalDateTime startTime, LocalDateTime endTime) {
        this(taskName, startTime, endTime, new ArrayList<>());
    }

    /**
     * Constructor for To-Dos (tasks with no deadlines or predetermined time
     * slots).
     */
    public Task(String taskName, ArrayList<String> tags) {
        this(taskName, false, null, null, tags, new ArrayList<>());
    }

    /**
     * Constructor for Deadlines (tasks with deadlines only).
     */
    public Task(String taskName, LocalDateTime endTime, ArrayList<String> tags) {
        this(taskName, false, null, endTime, tags, new ArrayList<>());
    }

    /**
     * Constructor for Events (tasks with predetermined time slots).
     */
    public Task(String taskName, LocalDateTime startTime, LocalDateTime endTime, ArrayList<String> tags) {
        this(taskName, false, startTime, endTime, tags, new ArrayList<>());
    }

    /**
     * Constructor for all Tasks
     */
    public Task(String taskName, boolean isDone, LocalDateTime startTime, LocalDateTime endTime, ArrayList<String> tags, ArrayList<Reminder> reminders) {
        this.taskName = taskName;
        this.isDone = isDone;
        this.startTime = startTime;
        this.endTime = endTime;
        this.tags = tags;
        this.reminders = reminders;
    }

    /**
     * Copy constructor.
     * @param other The other {@code Task} to copy from.
     */
    public Task(Task other) {
        this.taskName = other.taskName;
        this.isDone = other.isDone;
        this.startTime = other.startTime;
        this.endTime = other.endTime;
        this.tags = new ArrayList<>(other.tags);
        this.reminders = new ArrayList<>(other.reminders);
    }

    /**
     * @return The textual representation of the {@code Task}.
     */
    @Override
    public String toString() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd h.mma");

        if (this.isDeadline()) {
            return taskName + " (Due " + this.endTime.format(formatter) + ")" + tagsToString();
        } else if (this.isEvent()) {
            return taskName + " (" + this.startTime.format(formatter) + " - " + this.endTime.format(formatter) + ")"
                    + tagsToString();
        } else {
            return taskName + tagsToString();
        }
    }

    /**
     * @return {@code true} if and only if this {@code Task} is a todo.
     */
    public boolean isTodo() {
        return startTime == null && endTime == null;
    }

    /**
     * @return {@code true} if and only if this {@code Task} is a deadline.
     */
    public boolean isDeadline() {
        return startTime == null && endTime != null;
    }

    /**
     * @return {@code true} if and only if this {@code Task} is an event.
     */
    public boolean isEvent() {
        return startTime != null && endTime != null;
    }

    /**
     * @return {@code true} if and only if this {@code Task} is marked as done.
     */
    public boolean isDone() {
        return isDone == true;
    }

    /**
     * @return {@code true} if and only if this {@code Task} is not marked as done.
     */
    public boolean isNotDone() {
        return isDone == false;
    }

    /**
     * @param other Another {@code Object} to compare with.
     * @return {@code true} if and only if this {@code Task} is equal to {@code other}.
     */
    @Override
    public boolean equals(Object other) {
        if (other == null || !(other instanceof Task)) {
            return false;
        }

        Task otherTask = (Task) other;

        // equality of task name should be case insensitive
        if (!this.getTaskName().toLowerCase().equals(otherTask.getTaskName().toLowerCase())) {
            return false;
        }

        LocalDateTime thisStartTime = this.getStartTime();
        LocalDateTime otherStartTime = otherTask.getStartTime();

        if (thisStartTime == null && otherStartTime == null) {
            // do nothing and proceed to check other fields.
        } else {
            if (thisStartTime == null || otherStartTime == null) {
                return false;
            }

            if (!thisStartTime.equals(otherStartTime)) {
                return false;
            }
        }

        LocalDateTime thisEndTime = this.getEndTime();
        LocalDateTime otherEndTime = otherTask.getEndTime();

        if (thisEndTime == null && otherEndTime == null) {
            // do nothing and proceed to check other fields.
        } else {
            if (thisEndTime == null || otherEndTime == null) {
                return false;
            }

            if (!thisEndTime.equals(otherEndTime)) {
                return false;
            }
        }

        return true;
    }

    /**
     * @return The correct hash code for the current {@code Task}.
     */
    @Override
    public int hashCode() {
        int result = taskName.hashCode() ^ startTime.hashCode() ^ endTime.hashCode();

        return result;
    }

    /**
     * @param tag The tag to check.
     * @return {@code true} if and only if this {@code Task} has {@code tag}.
     */
    public boolean hasTag(String tag) {
        ArrayList<String> lowercaseTags = new ArrayListUtil.ChainableArrayListUtil<>(tags).map(String::toLowerCase)
                .value();
        return lowercaseTags.contains(tag.toLowerCase());
    }

    /**
     * @return The name of the task.
     */
    public String getTaskName() {
        return this.taskName;
    }

    /**
     * @return The start time of the task.
     */
    public LocalDateTime getStartTime() {
        return this.startTime;
    }

    /**
     * @return The end time of the task.
     */
    public LocalDateTime getEndTime() {
        return this.endTime;
    }

    /**
     * @return An {@code ArrayList} of tags.
     */
    public ArrayList<String> getTags() {
        return this.tags;
    }

    /**
     * @return An {@code ArrayList} of {@code Reminder}.
     */
    public ArrayList<Reminder> getReminders() {
        return this.reminders;
    }

    /**
     * @param taskName The new task name.
     * @return A new {@code Task} with the updated name.
     */
    public Task setTaskName(String taskName) {
        Task output = new Task(this);
        output.taskName = taskName;
        return output;
    }

    /**
     * @param startTime The new start time.
     * @return A new {@code Task} with the updated start time.
     */
    public Task setStartTime(LocalDateTime startTime) {
        Task output = new Task(this);
        output.startTime = startTime;
        return output;
    }

    /**
     * @param endTime The new end time.
     * @return A new {@code Task} with the updated end time.
     */
    public Task setEndTime(LocalDateTime endTime) {
        Task output = new Task(this);
        output.endTime = endTime;
        return output;
    }

    /**
     * @return A new {@code Task} by marking the current {@code Task} as done.
     */
    public Task markAsDone() {
        Task output = new Task(this);
        output.isDone = true;
        return output;
    }

    //A0140702X
    /**
     * @return A new {@code Task} by marking the current {@code Task} as undone.
     */
    public Task markAsUndone() {
        Task output = new Task(this);
        output.isDone = false;
        return output;
    }

    /**
     * @param reminder The {@code Reminder} to add.
     * @return A new {@code Task} by adding a new reminder.
     */
    public Task addReminder(Reminder reminder) {
        Task output = new Task(this);
        output.reminders.add(reminder);
        return output;
    }

    /**
     * @param tags The new tag to add.
     * @return A new {@code Task} by adding a new tag.
     */
    public Task setTags(ArrayList<String> tags) {
        Task output = new Task(this);
        output.tags = tags;
        return output;
    }

    /**
     * @param reminder The {@code Reminder} to remove from this {@code Task}.
     * @return A new {@code Task} by removing {@code reminder}.
     */
    public Task removeReminder(Reminder reminder) {
        Task output = new Task(this);
        output.reminders.remove(reminder);
        return output;
    }

    /**
     * @return The textual representation of the tags.
     */
    private String tagsToString() {
        StringBuilder builder = new StringBuilder();
        if (this.tags.isEmpty()) {
            return "";
        }

        builder.append(" [");
        builder.append("Tags:");
        for (String s : this.tags) {
            builder.append(" \"");
            builder.append(s);
            builder.append("\"");
        }
        builder.append(" ]");

        return builder.toString();
    }

    /**
     * @param keywords The search keywords.
     * @return An {@code ArrayList} of {@code Reminder} matching the keywords.
     */
    public ArrayList<Reminder> searchReminder(String keywords) {
        return this.searchReminder(keywords.split("\\s+"));
    }

    /**
     * @param keywords The search keywords.
     * @return An {@code ArrayList} of {@code Reminder} matching the keywords.
     */
    public ArrayList<Reminder> searchReminder(String[] keywords) {
        ArrayList<String> keywordsList = new ArrayListUtil.ChainableArrayListUtil<>(keywords)
                .map(String::toLowerCase)
                .value();

        return new ArrayListUtil.ChainableArrayListUtil<>(this.reminders)
                .filter(task -> { ArrayList<String> reminderKeywords =
                        new ArrayListUtil.ChainableArrayListUtil<>(task.getNote().split("\\s+"))
                                .map(String::toLowerCase)
                                .value();
                    return !Collections.disjoint(keywordsList, reminderKeywords);
                })
                .value();
    }
}
```
###### /java/linenux/storage/LocalDateTimeAdapter.java
``` java
/**
 * Converts between LocalDateTime instance and a String.
 */
public class LocalDateTimeAdapter extends XmlAdapter<String, LocalDateTime> {

    /**
     * Converts a {@code String} to a {@code LocalDateTime}.
     * @param v A string from the XML file.
     * @return A {@code LocalDateTime} instance.
     */
    @Override
    public LocalDateTime unmarshal(String v) {
        if (v.isEmpty()) {
            return null;
        } else {
            return LocalDateTime.parse(v);
        }
    }

    /**
     * Converts a {@code LocalDateTime} to a {@code String}.
     * @param A {@code LocalDateTime} instance.
     * @return A {@code String} of the (@code LocalDateTime} instance.
     */
    @Override
    public String marshal(LocalDateTime v) {
        if (v == null) {
            return "";
        } else {
            return v.toString();
        }
    }
}
```
###### /java/linenux/storage/ScheduleStorage.java
``` java
/**
 * Reads and writes Schedule to the file format.
 */
public interface ScheduleStorage {
    /**
     * Reads schedule from file.
     * @return a {@code Schedule} instance.
     */
    public Schedule loadScheduleFromFile();

    /**
     * Writes schedule to file type.
     * @param a {@code Schedule} instance to write to file type.
     */
    public void saveScheduleToFile(Schedule schedule);

    /**
     * Checks if file exist.
     * @return {@code Boolean} true if there is a schedule file of that file type.
     */
    public boolean hasScheduleFile();
}
```
###### /java/linenux/storage/XmlScheduleStorage.java
``` java
/**
 * An XML-backed implementation of schedule storage.
 */
public class XmlScheduleStorage implements ScheduleStorage {
    private static Logger logger = LogsCenter.getLogger(XmlScheduleStorage.class);

    private Config config;

    /**
     * Instantiate using the application config.
     * @param config
     */
    public XmlScheduleStorage(Config config) {
        this.config = config;
    }

    /**
     * Reads schedule from file.
     */
    @Override
    public Schedule loadScheduleFromFile() {
        logger.info("Loading schedule from " + this.getFilePath());

        Schedule output;
        try {
            JAXBContext context = JAXBContext.newInstance(AdaptedSchedule.class);
            Unmarshaller u = context.createUnmarshaller();

            AdaptedSchedule aSchedule = (AdaptedSchedule) u.unmarshal(this.getFilePath().toFile());
            output = aSchedule.convertToModel();
        } catch (Exception e) {
            logger.warning(ThrowableUtil.getStackTrace(e));
            Alerts.alert("Error Reading Schedule", "Schedule cannot be read from\n" + this.getFilePath().toString() + "\nPlease use the load command to load another schedule.");
            output = new Schedule();
        }

        logger.info("Done loading schedule from " + this.getFilePath());
        return output;
    }

    /**
     * Writes schedule to file.
     */
    @Override
    public void saveScheduleToFile(Schedule schedule) {
        logger.info("Saving schedule to " + this.getFilePath());

        try {
            AdaptedSchedule aSchedule = new AdaptedSchedule();
            aSchedule.convertToXml(schedule);
            JAXBContext context = JAXBContext.newInstance(aSchedule.getClass());
            Marshaller m = context.createMarshaller();
            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);

            if (!hasScheduleFile()) {
                createFile();
            }

            m.marshal(aSchedule, this.getFilePath().toFile());
        } catch (Exception e) {
            logger.warning(ThrowableUtil.getStackTrace(e));
            Alerts.alert("Error Writing Schedule", "Schedule cannot be saved to\n" + this.getFilePath().toString() + "\nPlease use the save command to specify another location.");
        }

        logger.info("Done saving schedule to " + this.getFilePath());
    }

    /**
     * Checks if file exist.
     */
    @Override
    public boolean hasScheduleFile() {
        return Files.exists(this.getFilePath());
    }

    /**
     * Creates an XML file at the path specified in the config class.
     * @throws IOException when there is problem with creating the file.
     */
    private void createFile() {
        logger.info("Creating " + this.getFilePath());

        try {
            Files.createFile(this.getFilePath());
        } catch (IOException i) {
            new File(this.getFilePath().getParent().toString()).mkdirs();
            createFile();
        } catch (Exception e) {
            logger.warning(ThrowableUtil.getStackTrace(e));
            Alerts.alert("Error Writing Schedule", "Schedule cannot be saved to\n" + this.getFilePath().toString() + "\nPlease use the save command to specify another location.");
        }

        logger.info("Done creating " + this.getFilePath());
    }

    /**
     * @return The path to where the XML file is located.
     */
    private Path getFilePath() {
        return Paths.get(this.config.getScheduleFilePath());
    }
}
```
###### /java/linenux/time/parser/StandardDateWithTimeParser.java
``` java
/**
 * Parse date and time in the form of "16 October 2016 5.00pm"
 */
public class StandardDateWithTimeParser implements TimeParser {
    DateTimeFormatter formatter = new DateTimeFormatterBuilder().parseCaseInsensitive()
                                        .appendPattern("dd MMM yyyy h.mma").toFormatter();

    /**
     * Checks if the user input corresponds to the format of the respective
     * time parser.
     *
     * @param input
     * @return true if format matches and false otherwise.
     */
    @Override
    public boolean respondTo(String input) {
        try {
            parse(input);
            return true;
        } catch (DateTimeParseException e) {
            return false;
        }
    }

    /**
     * Parses the userInput string to a time instance. This method assumes that {@code respondTo} returns {@code true}.
     * @param input The input to parse.
     * @return The {@code LocalDateTime}, which is the result of parsing {@code input}.
     */
    @Override
    public LocalDateTime parse(String input) {
        return LocalDateTime.parse(input, formatter);
    }

}
```
###### /java/linenux/time/parser/TimeParser.java
``` java
/**
 * All time parser types must support interface methods.
 */
public interface TimeParser {

    /**
     * Checks if the user input corresponds to the format of the respective
     * time parser.
     *
     * @param input
     * @return true if format matches and false otherwise.
     */
    public boolean respondTo(String input);

    /**
     * Parses the userInput string to a time instance. This method assumes that {@code respondTo} returns {@code true}.
     * @param input The input to parse.
     * @return The {@code LocalDateTime}, which is the result of parsing {@code input}.
     */
    public LocalDateTime parse(String input);
}
```
###### /java/linenux/util/AutoCompleter.java
``` java
/**
 * Stateful class that autocompletes.
 */
public class AutoCompleter {
    private TernarySearchTree tree;
    private ArrayList<Command> commandList;
    private ArrayList<String> searchResult;
    private int searchIndex;

    public AutoCompleter() {
        this.tree = new TernarySearchTree();
        this.searchResult = new ArrayList<>();
        this.searchIndex = -1;
    }

    /**
     * Adds default command string and their aliases to the tree.
     * @param commandList
     */
    public AutoCompleter(ArrayList<Command> commandList) {
        this();
        this.commandList = commandList;
        buildTree();
    }

    /**
     * @return {@code true} if and only if there is no suggestion.
     */
    public boolean hasNoSearchResult() {
        return searchResult.isEmpty();
    }

    /**
     * Find all strings with prefix.
     * @param prefix
     */
    public void findPrefix(String prefix) {
        int indexOfLastSpace = prefix.lastIndexOf(' ');

        //if no ' ' found
        if (indexOfLastSpace == -1) {
            this.searchResult = tree.getAllStringsWithPrefix(prefix);
        }

        String stringAfterLastSpace = prefix.substring(indexOfLastSpace + 1);

        ArrayList<String> searchResult = tree.getAllStringsWithPrefix(stringAfterLastSpace);
        ArrayList<String> finalResult = new ArrayListUtil.ChainableArrayListUtil<>(searchResult)
                                                     .map(result -> result.substring(stringAfterLastSpace.length()))
                                                     .map(suggestedSuffix -> prefix + suggestedSuffix)
                                                     .value();
        this.searchResult = finalResult;
    }

    /**
     * Returns the next search result of prefix.
     * @return next search result.
     */
    public String next() {
        if (hasNoSearchResult()) {
            return "";
        }
        if (searchIndex + 1 < searchResult.size()) {
            searchIndex++;
        }
        return searchResult.get(searchIndex);
    }

    /**
     * Clears search result of previous prefix search.
     */
    public void clear() {
        searchResult.clear();
        searchIndex = -1;
    }

    /**
     * Adds a given string into the search tree
     */
    public void addStringsToTree(String string) {
        String[] wordArray = string.split("\\s+");

        for (String word : wordArray) {
            tree.addString(word);
        }
    }

    /**
     * Builds a tree of triggerWords of command.
     */
    private void buildTree() {
        for (Command c : commandList) {
            for (String word : c.getTriggerWords()) {
                tree.addString(word);
            }
        }
    }
}
```
###### /java/linenux/view/components/EventCell.java
``` java
/**
 * View component used to display a single event.
 */
public class EventCell extends ListCell<Task> {
    @FXML
    private Label title;

    @FXML
    private Label time;

    @FXML
    private Label tags;

    @FXML
    private AnchorPane container;

    private ListView<Task> parent;

    /**
     * Instantiate a {@code EventCell}.
     * @param parent The {@code ListView} that uses this cell.
     */
    public EventCell(ListView<Task> parent) {
        super();

        this.parent = parent;

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(TodoCell.class.getResource("/view/EventCell.fxml"));
            loader.setController(this);
            AnchorPane result = loader.load();
            this.setGraphic(result);
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }

    /**
     * Callback when the {@code Task} is updated.
     * @param task The new {@code Task}.
     * @param empty Whether the cell is empty.
     */
    @Override
    public void updateItem(Task task, boolean empty) {
        super.updateItem(task, empty);

        this.container.getStyleClass().removeAll("no-tags", "overdue", "empty", "done");

        if (empty || task == null) {
            this.title.setText("");
            this.time.setText("");
            this.tags.setText("");
            this.container.getStyleClass().add("empty");
        } else {
            ArrayList<String> tagsWithHash = new ArrayListUtil.ChainableArrayListUtil<>(task.getTags())
                    .map(tag -> "#" + tag).value();

            if (tagsWithHash.isEmpty()) {
                this.container.getStyleClass().add("no-tags");
            }

            if (this.isOverdue(task)) {
                this.container.getStyleClass().add("overdue");
            }

            if (task.isDone()) {
                this.container.getStyleClass().add("done");
            }

            this.title.setText(task.getTaskName());
            this.time.setText(LocalDateTimeUtil.toString(task.getStartTime()) + " - "
                    + LocalDateTimeUtil.toString(task.getEndTime()));
            this.tags.setText(String.join(", ", tagsWithHash));
        }
    }

    /**
     * Check if a {@code Task} is overdue.
     * @param task The {@code Task} to check.
     * @return {@code true} if and only if {@code task} is overdue.
     */
    private boolean isOverdue(Task task) {
        if (task.isDeadline() || task.isEvent()) {
            LocalDateTime now = LocalDateTime.now();
            return now.isAfter(task.getEndTime());
        }
        return false;
    }

    /**
     * Callback to initialize the component when various children are ready.
     * Here we make sure that the container does not grow wider than the list.
     */
    @FXML
    private void initialize() {
        this.container.setMaxWidth(this.parent.getWidth());
        this.parent.widthProperty().addListener(change -> {
            this.container.setMaxWidth(this.parent.getWidth());
        });
    }
}
```
###### /java/linenux/view/ExpandableResultBoxController.java
``` java
/**
 * Controller for expandable result box, which is used to show longer command results.
 */
public class ExpandableResultBoxController {
    public enum UserAction {
        SHOW, HIDE
    }

    @FXML
    TextArea textArea;

    private BooleanProperty expanded = new SimpleBooleanProperty(false);
    private ControlUnit controlUnit;
    private boolean isShowingReminders = true;
    private UserAction lastUserAction = UserAction.HIDE;
    private Clock clock = Clock.systemDefaultZone();

    /**
     * Update the application {@code ControlUnit}.
     * @param controlUnit The new {@code ControlUnit}.
     */
    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        this.controlUnit.getLastCommandResultProperty().addListener((change) -> {
            this.setText(this.controlUnit.getLastCommandResultProperty().get().getFeedback());
        });
        this.renderInitialReminders();
        this.controlUnit.getSchedule().getFilteredTaskList().addListener((ListChangeListener<? super ArrayList<Task>>) (change) -> {
            this.onFilteredTaskListChange();
        });
    }

    /**
     * Initializes subviews.
     */
    @FXML
    private void initialize() {
        this.expanded.addListener(change -> {
            this.render();
        });
    }

    /**
     * Show the result box if it's currently hidden, hide otherwise.
     */
    @FXML
    private void toggleExpandedState() {
        if (this.expanded.get()) {
            this.lastUserAction = UserAction.HIDE;
            this.expanded.set(false);
        } else {
            this.lastUserAction = UserAction.SHOW;
            this.expanded.set(true);
        }
    }

    /**
     * Ensure that the UI is in the correct state.
     */
    private void render() {
        if (this.expanded.get()) {
            this.textArea.setPrefHeight(200);
        } else {
            this.textArea.setPrefHeight(0);
        }
    }

    /**
     * Render {@code text} on screen.
     * @param text The {@code String} to show.
     */
    private void setText(String text) {
        if (text.trim().contains("\n")) {
            this.isShowingReminders = false;
            this.expanded.set(true);
            this.textArea.setText(text.trim());
        } else {
            if (this.lastUserAction == UserAction.HIDE) {
                this.expanded.set(false);
            }
            this.isShowingReminders = true;
            this.renderReminders();
        }
    }

    /**
     * Callback when filtered task changes.
     */
    private void onFilteredTaskListChange() {
        if (this.isShowingReminders) {
            this.renderReminders();
        }
    }

    /**
     * Render the initial set of reminders.
     */
    private void renderInitialReminders() {
        String formattedReminders = this.formatReminders();

        if (!formattedReminders.isEmpty()) {
            this.lastUserAction = UserAction.SHOW;
            this.isShowingReminders = true;
            this.expanded.set(true);
            this.renderReminders();
        }
    }

    /**
     * @return Format the reminders that will be shown.
     */
    private String formatReminders() {
        LocalDateTime now = LocalDateTime.now(this.clock);
        LocalDateTime today = now.withHour(0).withMinute(0).withSecond(0);

        ArrayList<Reminder> reminders = new ArrayListUtil.ChainableArrayListUtil<>(this.controlUnit.getSchedule().getFilteredTasks())
                .map(Task::getReminders)
                .foldr((x, xs) -> {
                    xs.addAll(x);
                    return xs;
                }, new ArrayList<Reminder>())
                .filter(reminder -> today.compareTo(reminder.getTimeOfReminder()) <= 0)
                .sortBy(Reminder::getTimeOfReminder)
                .value();

        return ArrayListUtil.display(reminders);
    }

    /**
     * Display the reminders on screen.
     */
    private void renderReminders() {
        this.textArea.setText(formatReminders());
    }
}
```
###### /java/linenux/view/MainWindowController.java
``` java
/**
 * Controller for the main window.
 */
public class MainWindowController {
    private static Logger logger = LogsCenter.getLogger(MainWindowController.class);

    @FXML
    private StackPane stackPane;
    @FXML
    private VBox vbox;
    @FXML
    private GridPane gridPane;
    @FXML
    private AnchorPane commandBoxContainer;

    private ControlUnit controlUnit;

    /**
     * Instatiate {@code MainWindowController} using application {@code Config}.
     * @param config The application config.
     */
    public MainWindowController(Config config) {
        this.controlUnit = new ControlUnit(config);
    }

    /**
     * Initializes subviews.
     */
    @FXML
    private void initialize() {
        logger.info("Initializing MainWindowController");

        try {
            setupTodoBox();
            setupDeadlineBox();
            setupEventBox();
            setupExpandableCommandResult();
            setupCommandBox();
            setupResultsOverlay();
        } catch (Exception e) {
            Alerts.alertAndDie("Fatal Error", "Unable to initialize the application.");
        }

        logger.info("Done initializing MainWindowController");
    }

    /**
     * Setup todo box.
     * @throws Exception Thrown when setup fails.
     */
    private void setupTodoBox() throws Exception {
        logger.info("Setting up todo box");

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/TodoBox.fxml"));
            AnchorPane todoBox = loader.load();
            GridPane.setRowIndex(todoBox, 0);
            GridPane.setColumnIndex(todoBox, 0);
            gridPane.getChildren().add(todoBox);
            TodoBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (Exception e) {
            logger.severe(ThrowableUtil.getStackTrace(e));
            throw e;
        }

        logger.info("Done setting up todo box");
    }

    /**
     * Setup deadline box.
     * @throws Exception Thrown when setup fails.
     */
    private void setupDeadlineBox() throws Exception {
        logger.info("Setting up deadline box");

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/DeadlineBox.fxml"));
            AnchorPane deadlineBox = loader.load();
            GridPane.setRowIndex(deadlineBox, 0);
            GridPane.setColumnIndex(deadlineBox, 1);
            gridPane.getChildren().add(deadlineBox);
            DeadlineBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            logger.severe(ThrowableUtil.getStackTrace(e));
            throw e;
        }

        logger.info("Done setting up deadline box");
    }

    /**
     * Setup event box.
     * @throws Exception Thrown when setup fails.
     */
    private void setupEventBox() throws Exception {
        logger.info("Setting up event box");

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/EventBox.fxml"));
            AnchorPane eventBox = loader.load();
            GridPane.setRowIndex(eventBox, 0);
            GridPane.setColumnIndex(eventBox, 2);
            gridPane.getChildren().add(eventBox);
            EventBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (Exception e) {
            logger.severe(ThrowableUtil.getStackTrace(e));
            throw e;
        }

        logger.info("Done setting up event box");
    }

    /**
     * Setup command box.
     * @throws Exception Thrown when setup fails.
     */
    private void setupCommandBox() throws Exception {
        logger.info("Setting up command box");

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/CommandBox.fxml"));
            TextField field = loader.load();
            AnchorPane.setTopAnchor(field, 0.0);
            AnchorPane.setRightAnchor(field, 0.0);
            AnchorPane.setBottomAnchor(field, 0.0);
            AnchorPane.setLeftAnchor(field, 0.0);
            commandBoxContainer.getChildren().add(field);
            CommandBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            logger.severe(ThrowableUtil.getStackTrace(e));
            throw e;
        }

        logger.info("Done setting up command box");
    }

    /**
     * Setup expandable command result box.
     * @throws Exception Thrown when setup fails.
     */
    private void setupExpandableCommandResult() throws Exception {
        logger.info("Setting up expandable command result");

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/ExpandableResultBox.fxml"));
            VBox root = loader.load();
            vbox.getChildren().add(1, root);
            ExpandableResultBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            logger.severe(ThrowableUtil.getStackTrace(e));
            throw e;
        }

        logger.info("Done setting up expandable command result");
    }

    /**
     * Setup results overlay.
     * @throws Exception Thrown when setup fails.
     */
    private void setupResultsOverlay() throws Exception {
        logger.info("Setting up results overlay");

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/ResultsOverlay.fxml"));
            this.stackPane.getChildren().add(loader.load());
            ResultsOverlayController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            logger.severe(ThrowableUtil.getStackTrace(e));
            throw e;
        }

        logger.info("Done setting up results overlay");
    }
}
```
###### /resources/view/EventCell.css
``` css
.eventCell {
    -fx-background-color: #83bdb8;
}

.eventCell .container {
    -fx-background-radius: 5px;
    -fx-background-color: rgba(0, 0, 0, .16);
    -fx-padding: 10px;
}

.eventCell.overdue .container {
    -fx-opacity: .6;
}

.eventCell.no-tags .container {
    -fx-padding: 10px 10px -5px 10px;
}

.eventCell.empty .container {
    -fx-background-color: #83bdb8;
}

.eventCell .name {
    -fx-font-size: 18.72px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.eventCell.done .name .text {
    -fx-strikethrough: true;
}

.eventCell .time {
    -fx-font-size: 16px;
    -fx-opacity: .7;
    -fx-text-fill: white;
}

.eventCell .tags {
    -fx-alignment: center-right;
    -fx-opacity: .5;
    -fx-font-size: 12px;
    -fx-text-fill: white;
}
```
###### /resources/view/ExpandableResultBox.css
``` css
.expandable-result-box {
    -fx-border-color: transparent transparent #80deea transparent;
    -fx-border-width: 3px;
}

.expandable-result-box .result {
    -fx-text-fill: white;
    -fx-background-color: #83bdb8;
    -fx-border-color: #80deea transparent transparent transparent;
}

.expandable-result-box .result .content {
    -fx-background-color: #51716e;
    -fx-padding: 10px;
}

.expandable-result-box .btn-toggle {
    -fx-background-color: #80deea;
    -fx-background-radius: 3px 3px 0 0;
    -fx-padding: -1px 5px -3px 5px;
}
```
