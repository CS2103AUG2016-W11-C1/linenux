# A0135788M
###### /java/linenux/command/AddCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    private String extractArguments(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords").trim();
        } else {
            return "";
        }
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    private boolean validAlias(String alias) {
        Matcher matcher = Pattern.compile(ALPHANUMERIC).matcher(alias);
        return matcher.matches();
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeNoSuchCommandResult() {
        return () -> "No such command to make alias for.";
    }

    private CommandResult makeInvalidAliasResult() {
        return () -> "Alias must be alphanumeric.";
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    private CommandResult makeSuccessfulAliasResult(String[] commands) {
        return () -> commands[1] + " is now the alias for the " + commands[0] + " command.";
    }
}
```
###### /java/linenux/command/Command.java
``` java
    /**
     * Returns the command format.
     */
    public String getCommandFormat();

    /**
     * Get regex pattern.
     */
    public String getPattern();

```
###### /java/linenux/command/DeleteCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private String extractKeywords(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords");
        } else {
            return "";
        }
    }

    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
    }

    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

```
###### /java/linenux/command/DoneCommand.java
``` java
    public DoneCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

```
###### /java/linenux/command/DoneCommand.java
``` java
    @Override
    public boolean awaitingUserResponse() {
        return requiresUserResponse;
    }

    @Override
    public CommandResult userResponse(String userInput) {
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                this.schedule.updateTask(task, task.markAsDone());

                setResponse(false, null);
                return makeDoneTask(task);
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

```
###### /java/linenux/command/DoneCommand.java
``` java
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private String extractKeywords(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords");
        } else {
            return "";
        }
    }

    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
    }

    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeDoneTask(Task task) {
        return () -> "\"" + task.getTaskName() + "\" is marked as done.";
    }

    private CommandResult makeCancelledResult() {
        return () -> "OK! Not marking any task as done.";
    }

    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to mark as done.\n");
            builder.append(TasksListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/EditCommand.java
``` java
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractKeywords(userInput);
        String argument = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(keywords);

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            return implementEdit(task, argument);
        } else {
            setResponse(true, tasks, argument);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

```
###### /java/linenux/command/EditCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

```
###### /java/linenux/command/EditCommand.java
``` java
    @Override
    public String getPattern() {
        return "(?i)^\\s*(" + getTriggerWordsPattern() + ")(\\s+(?<keywords>.*?)(?<arguments>((n|st|et|#)/)+?.*)?)?";
    }

    private String extractKeywords(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords").trim(); //TODO
        } else {
            return "";
        }
    }

```
###### /java/linenux/command/EditCommand.java
``` java
    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks, String argument) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
        this.argument = argument;
    }

    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

```
###### /java/linenux/command/ExitCommand.java
``` java
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());

        // TODO: Platform.exit();
        System.exit(0);
        return null;
    }

```
###### /java/linenux/command/ExitCommand.java
``` java
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }
}
```
###### /java/linenux/command/HelpCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

```
###### /java/linenux/command/InvalidCommand.java
``` java
    /**
     * @return true for all user inputs.
     */
    @Override
    public boolean respondTo(String userInput) {
        return true;
    }

```
###### /java/linenux/command/InvalidCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return null;
    }

    @Override
    public String getDescription() {
        return null;
    }

    @Override
    public String getCommandFormat() {
        return null;
    }

    @Override
    public String getPattern() {
        return null;
    }

```
###### /java/linenux/command/ListCommand.java
``` java
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

```
###### /java/linenux/command/ListCommand.java
``` java
    private String extractKeywords(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords").trim();
        } else {
            return "";
        }
    }

```
###### /java/linenux/command/parser/AddArgumentParser.java
``` java
/**
 * Parser for the argument portion of add command.
 **/
public class AddArgumentParser {
    public static String COMMAND_FORMAT;
    public static String CALLOUTS;

    private TimeParserManager timeParserManager;
    private GenericParser genericParser = new GenericParser();
    private GenericParser.GenericParserResult parseResult;

```
###### /java/linenux/command/parser/AddArgumentParser.java
``` java
    public AddArgumentParser(TimeParserManager timeParserManager, String commandFormat, String callouts) {
        this.timeParserManager = timeParserManager;
        AddArgumentParser.COMMAND_FORMAT = commandFormat;
        AddArgumentParser.CALLOUTS = callouts;
    }

```
###### /java/linenux/command/parser/AddArgumentParser.java
``` java
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

```
###### /java/linenux/command/parser/EditArgumentParser.java
``` java
    public EditArgumentParser(TimeParserManager timeParserManager, String commandFormat, String callouts) {
        this.timeParserManager = timeParserManager;
        this.genericParser = new GenericParser();
        EditArgumentParser.COMMAND_FORMAT = commandFormat;
        EditArgumentParser.CALLOUTS = callouts;
    }

```
###### /java/linenux/command/parser/EditArgumentParser.java
``` java
    private CommandResult makeNoArgumentsResult() {
        return () -> "No changes to be made!";
    }

```
###### /java/linenux/command/parser/EditArgumentParser.java
``` java
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeInvalidDateTimeResult(String dateTime) {
        return () -> "Cannot parse \"" + dateTime + "\".";
    }

    private CommandResult makeStartTimeWithoutEndTimeResult() {
        return () -> "Cannot create task with start time but without end time.";
    }

    private CommandResult makeEndTimeBeforeStartTimeResult() {
        return () -> "End time cannot come before start time.";
    }
}
```
###### /java/linenux/command/parser/ReminderArgumentParser.java
``` java
    public ReminderArgumentParser(TimeParserManager timeParserManager, String commandFormat, String callouts) {
        this.timeParserManager = timeParserManager;
        this.genericParser = new GenericParser();
        ReminderArgumentParser.COMMAND_FORMAT = commandFormat;
        ReminderArgumentParser.CALLOUTS = callouts;
    }

```
###### /java/linenux/command/RemindCommand.java
``` java
    public RemindCommand(Schedule schedule) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser());
        this.reminderArgumentParser = new ReminderArgumentParser(this.timeParserManager, COMMAND_FORMAT, CALLOUTS);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractKeywords(userInput);
        String argument = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(keywords);

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            return implementRemind(task, argument);
        } else {
            setResponse(true, tasks, argument);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

```
###### /java/linenux/command/RemindCommand.java
``` java
    @Override
    public boolean awaitingUserResponse() {
        return requiresUserResponse;
    }

    @Override
    public CommandResult userResponse(String userInput) {
        assert this.argument != null;
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                CommandResult result = implementRemind(task, this.argument);
                setResponse(false, null, null);
                return result;
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

```
###### /java/linenux/command/RemindCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    @Override
    public String getPattern() {
        return "(?i)^\\s*(" + this.getTriggerWordsPattern() + ")(\\s+(?<keywords>.*?)(?<arguments>((n|t)/)+?.*)?)?";
    }

    private String extractKeywords(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords").trim(); // TODO
        } else {
            return "";
        }
    }

    private String extractArgument(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("arguments") != null) {
            return matcher.group("arguments");
        } else {
            return "";
        }
    }

    private CommandResult implementRemind(Task original, String argument) {
        Either<Reminder, CommandResult> result = reminderArgumentParser.parse(argument);

        if (result.isLeft()) {
            this.schedule.updateTask(original, original.addReminder(result.getLeft()));
            return makeResult(original, result.getLeft());
        } else {
            return result.getRight();
        }
    }

    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks, String argument) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
        this.argument = argument;
    }

    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeResult(Task task, Reminder reminder) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd h:mma");

        return () -> "Added reminder on " + reminder.getTimeOfReminder().format(formatter) + " for "
                + task.getTaskName();
    }

    private CommandResult makeCancelledResult() {
        return () -> "OK! Not adding new reminder.";
    }

    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to add reminder to:\n");
            builder.append(TasksListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/result/CommandResult.java
``` java
public interface CommandResult {
    public String getFeedback();
}
```
###### /java/linenux/command/UndoCommand.java
``` java
/**
 * Undo the previous command that mutated the state of the schedule.
 */
public class UndoCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "undo";
    private static final String DESCRIPTION = "Undo the previous command.";
    private static final String COMMAND_FORMAT = "undo";

    private Schedule schedule;

    public UndoCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        if (this.schedule.popState()) {
            return makeUndoSuccessfulMessage();
        } else {
            return makeUndoUnsuccessfulMessage();
        }
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private CommandResult makeUndoSuccessfulMessage() {
        return () -> "Successfully undo last command.";
    }

    private CommandResult makeUndoUnsuccessfulMessage() {
        return () -> "No more commands to undo!";
    }

}
```
###### /java/linenux/command/ViewCommand.java
``` java
/**
 * Generates details of tasks and reminders attached to task based on userInput.
 */
public class ViewCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "view";
    private static final String DESCRIPTION = "Views details of specific task.";
    private static final String COMMAND_FORMAT = "view KEYWORDS";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private ArrayList<Task> foundTasks;

    public ViewCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractKeywords(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(keywords);

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            return makeResult(task);
        } else {
            setResponse(true, tasks);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

    @Override
    public boolean awaitingUserResponse() {
        return requiresUserResponse;
    }

    @Override
    public CommandResult userResponse(String userInput) {
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);

                setResponse(false, null);
                return makeResult(task);
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private String extractKeywords(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords");
        } else {
            return "";
        }
    }

    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
    }

    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeResult(Task task) {
        ArrayList<Reminder> reminders = task.getReminders();
        StringBuilder builder = new StringBuilder();
        builder.append(task.toString());
        builder.append('\n');
        builder.append("Reminders:" + '\n');

        if (reminders.size() == 0) {
            builder.append("You have not set any reminders for this task.");
        } else {
            builder.append(RemindersListUtil.display(reminders));
        }

        return () -> builder.toString().trim();

    }

    private CommandResult makeCancelledResult() {
        return () -> "OK! Not viewing any task.";
    }

    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to view.\n");
            builder.append(TasksListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/config/Config.java
``` java
/**
 * Creates the configuration file.
 */
public class Config {
    public static final String DEFAULT_FILE_PATH = Paths.get(".").toAbsolutePath().toString();
    public static final String CONFIG_FILENAME = "Config.json";
    public static final String SCHEDULE_FILENAME = "Schedule.xml";

    private Path configFilePath;
    private Path scheduleFilePath;

    public Config() {
        this(DEFAULT_FILE_PATH + CONFIG_FILENAME, DEFAULT_FILE_PATH + SCHEDULE_FILENAME);
    }

    public Config(String configFilePath, String scheduleFilePath) {
        this.configFilePath = Paths.get(configFilePath);
        this.scheduleFilePath = Paths.get(scheduleFilePath);
        initialize();
    }

    /**
     * Initializes configuration file with default values;
     */
    @SuppressWarnings("unchecked")
    private void initialize() {
        if (hasConfigFile()) {
            return;
        }

        JSONObject configFile = new JSONObject();
        configFile.put("Actual Schedule File Path", scheduleFilePath.toString());

        try {
            FileWriter file = new FileWriter(configFilePath.toString());
            file.write(configFile.toJSONString());
            file.flush();
            file.close();
        } catch (IOException i) {
            throwAlert("Creating File Error", "Could not create file at: \n" + configFilePath.toString());
        }
    }

    public String getActualFilePath() {
        JSONParser parser = new JSONParser();
        try {
            JSONObject configFile = (JSONObject) parser.parse(new FileReader(configFilePath.toString()));
            return (String) configFile.get("Actual Schedule File Path");
        } catch (IOException i) {
            throwAlert("Reading File Error", "Could not read file at: \n" + configFilePath.toString());
            return "";
        } catch (ParseException p) {
            throwAlert("Parsing Error", "Could not parse file at: \n" + configFilePath.toString());
            return "";
        }
    }

    public boolean hasConfigFile() {
        return Files.exists(configFilePath);
    }

    private Alert throwAlert(String title, String message) {
        Alert alert = new Alert(AlertType.ERROR);
        alert.setTitle(title);
        alert.setContentText(message);
        return alert;
    }
}
```
###### /java/linenux/control/CommandManager.java
``` java
    /**
     * Assigns the appropriate command to the user input. Contract: only 1
     * command should be awaiting user response at any point in time.
     */
    public CommandResult delegateCommand(String userInput) {
        for (Command command : commandList) {
            if (command.awaitingUserResponse()) {
                return command.userResponse(userInput);
            }
        }

        for (Command command : commandList) {
            if (command.respondTo(userInput)) {
                return command.execute(userInput);
            }
        }

        return this.catchAllCommand.execute(userInput);
    }
}
```
###### /java/linenux/control/ControlUnit.java
``` java
    public ControlUnit(Config config) {
        this.scheduleStorage = new XmlScheduleStorage(config.getActualFilePath());
        this.schedule = (this.scheduleStorage.hasScheduleFile()) ? this.scheduleStorage.loadScheduleFromFile() : new Schedule();
        this.commandManager = new CommandManager(schedule);
    }

    public CommandResult execute(String userInput) {
        CommandResult result = commandManager.delegateCommand(userInput);
        lastCommandResult.setValue(result);
        scheduleStorage.saveScheduleToFile(schedule);
        return result;
    }

```
###### /java/linenux/control/TimeParserManager.java
``` java
    public TimeParserManager(TimeParser... parsers) {
        parserList = new ArrayList<TimeParser>();
        for (TimeParser parser: parsers){
            parserList.add(parser);
        }
    }

```
###### /java/linenux/control/TimeParserManager.java
``` java
    /**
     * Assigns the appropriate time parser to the user input.
     */
    public LocalDateTime delegateTimeParser(String userInput) {
        for (TimeParser parser: parserList) {
            if (parser.respondTo(userInput)) {
                return parser.parse(userInput);
            }
        }
        return null;
    }
}
```
###### /java/linenux/Main.java
``` java
    @Override
    public void start(Stage primaryStage) throws Exception {
        setupMainWindow(primaryStage);
    }

    @Override
    public void stop() throws Exception {
        super.stop();
        Platform.exit();
        System.exit(0);
    }

```
###### /java/linenux/model/adapted/AdaptedReminder.java
``` java
@XmlRootElement(name = "Reminder")
@XmlType(propOrder = { "note", "timeOfReminder" })
public class AdaptedReminder {
    @XmlElement(name = "note")
    private String note;

    @XmlElement(name = "timeOfReminder")
    @XmlJavaTypeAdapter(LocalDateTimeAdapter.class)
    private LocalDateTime timeOfReminder;

    public AdaptedReminder() {
    }

    public AdaptedReminder convertToXml(Reminder r) {
        this.note = r.getNote();
        this.timeOfReminder = r.getTimeOfReminder();
        return this;
    }

    public Reminder convertToModel() {
        return new Reminder(note, timeOfReminder);
    }
}
```
###### /java/linenux/model/adapted/AdaptedSchedule.java
``` java
@XmlRootElement(name = "Schedule")
public class AdaptedSchedule {
    @XmlElement(name = "state")
    private AdaptedState state;

    public AdaptedSchedule() {
    }

    public AdaptedSchedule convertToXml(Schedule sch) {
        this.state = new AdaptedState();
        this.state.convertToXml(sch.getStates().get(sch.getStates().size() - 1));
        return this;
    }

    public Schedule convertToModel() {
        return new Schedule(state.convertToModel());
    }
}
```
###### /java/linenux/model/adapted/AdaptedState.java
``` java
@XmlRootElement(name = "State")
public class AdaptedState {
    @XmlElement(name = "tasks")
    private ArrayList<AdaptedTask> tasks;

    public AdaptedState() {
    }

    public AdaptedState convertToXml(State s) {
        this.tasks = new ArrayList<>();
        for (Task t : s.getTaskList()) {
            tasks.add(new AdaptedTask().convertToXml(t));
        }
        return this;
    }

    public State convertToModel() {
        ArrayList<Task> newTasks = new ArrayList<>();
        for (AdaptedTask t : tasks) {
            newTasks.add(t.convertToModel());
        }
        return new State(newTasks);
    }
}
```
###### /java/linenux/model/adapted/AdaptedTask.java
``` java
@XmlRootElement(name = "Task")
@XmlType(propOrder = { "taskName", "isDone", "startTime", "endTime", "tags", "reminders" })
public class AdaptedTask {
    @XmlElement(name = "taskName")
    private String taskName;

    @XmlElement(name = "isDone")
    private boolean isDone;

    @XmlElement(name = "startTime", nillable = true)
    @XmlJavaTypeAdapter(LocalDateTimeAdapter.class)
    private LocalDateTime startTime;

    @XmlElement(name = "endTime", nillable = true)
    @XmlJavaTypeAdapter(LocalDateTimeAdapter.class)
    private LocalDateTime endTime;

    @XmlElement(name = "tags")
    @XmlElementWrapper
    private ArrayList<String> tags;

    @XmlElement(name = "reminders")
    @XmlElementWrapper
    private ArrayList<AdaptedReminder> reminders;

    public AdaptedTask() {
    }

    public AdaptedTask convertToXml(Task t) {
        this.taskName = t.getTaskName();
        this.isDone = t.isDone();
        this.startTime = t.getStartTime();
        this.endTime = t.getEndTime();
        this.tags = t.getTags();
        this.reminders = new ArrayList<>();
        for (Reminder r : t.getReminders()) {
            reminders.add(new AdaptedReminder().convertToXml(r));
        }
        return this;
    }

    public Task convertToModel() {
        ArrayList<Reminder> newReminders = new ArrayList<>();
        for (AdaptedReminder r : reminders) {
            newReminders.add(r.convertToModel());
        }
        return new Task(taskName, isDone, startTime, endTime, tags, newReminders);
    }
}
```
###### /java/linenux/model/Reminder.java
``` java
    public Reminder(String note, LocalDateTime timeOfReminder) {
        this.note = note;
        this.timeOfReminder = timeOfReminder;
    }

```
###### /java/linenux/model/Reminder.java
``` java
    public String getNote() {
        return this.note;
    }

    public LocalDateTime getTimeOfReminder() {
        return this.timeOfReminder;
    }

    /* Setters */

```
###### /java/linenux/model/Schedule.java
``` java
    public Schedule(State s) {
        this.states.add(s);
    }

    /**
     * Adds a task to the schedule
     */
    public void addTask(Task task) {
        addState(getMostRecentState().addTask(task));
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Delete the specified task.
     *
     * @param task The task to delete.
     */
    public void deleteTask(Task task) {
        addState(getMostRecentState().deleteTask(task));
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Clears all tasks from the schedule
     */
    public void clear() {
        State newState = new State();
        addState(newState);
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Performs case-insensitive task search using keywords.
     *
     * @param keywords
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
    public ArrayList<Task> search(String[] keywords) {
        return getMostRecentState().search(keywords);
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Returns the list of states.
     */
    public ObservableList<State> getStates() {
        return states;
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Returns the list of tasks.
     */
    public ArrayList<Task> getTaskList() {
        return getMostRecentState().getTaskList();
    }

```
###### /java/linenux/model/State.java
``` java
/**
 * Represents a snapshot in time of a schedule. The State class is immutable.
 */
 public class State {
     private final ArrayList<Task> tasks;

     public State() {
         this.tasks = new ArrayList<Task>();
     }

     public State(State other) {
         this.tasks = new ArrayList<>(other.tasks);
     }

     public State(ArrayList<Task> taskList) {
         this.tasks = taskList;
     }

     /**
      * Adds a task to the schedule
      * @param task The task to add.
      * @return The new State of the schedule.
      */
     public State addTask(Task task) {
         State output = new State(this);
         output.tasks.add(task);
         return output;
     }

     /**
      * Updates the specified task.
      *
      * @param originalTask The original version of the specified task.
      * @param newTask The edited version of the specified task.
      */
     public State updateTask(Task originalTask, Task newTask) {
         int taskIndex = tasks.indexOf(originalTask);
         State output = new State(this);
         output.tasks.set(taskIndex, newTask);
         return output;
     }

     /**
      * Delete the specified task.
      * @param task The task to delete.
      * @return The new State of the schedule.
      */
     public State deleteTask(Task task) {
         int taskIndex = tasks.indexOf(task);
         State output = new State(this);
         output.tasks.remove(taskIndex);
         return output;
     }

     /**
      * Returns the list of tasks.
      */
     public ArrayList<Task> getTaskList() {
         return tasks;
     }

     /**
     * Performs case-insensitive task search using keywords.
     *
     * @param keywords
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
     public ArrayList<Task> search(String[] keywords) {
         ArrayList<String> keywordsList = new ArrayListUtil.ChainableArrayListUtil<>(keywords)
                                                           .map(String::toLowerCase)
                                                           .value();

         return new ArrayListUtil.ChainableArrayListUtil<>(this.tasks)
                                 .filter(task -> { ArrayList<String> taskKeywords =
                                                     new ArrayListUtil.ChainableArrayListUtil<>(task.getTaskName().split("\\s+"))
                                                                      .map(String::toLowerCase)
                                                                      .value();
                                                   return !Collections.disjoint(keywordsList, taskKeywords);
                                                   })
                                 .value();
     }

     /**
     * Performs case-insensitive reminder search using keywords.
     *
     * @param keywords
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
    public ArrayList<Reminder> searchReminder(String[] keywords) {
        ArrayList<Reminder> result = new ArrayList<>();

        for (Task t : this.tasks) {
            result.addAll(searchReminder(keywords, t));
        }

        return result;
    }

    public ArrayList<Reminder> searchReminder(String[] keywords, ArrayList<Task> tasks) {
        ArrayList<Reminder> result = new ArrayList<>();

        for (Task t : tasks) {
            result.addAll(searchReminder(keywords, t));
        }

        return result;
    }

    public ArrayList<Reminder> searchReminder(String[] keywords, Task task) {
        ArrayList<String> keywordsList = new ArrayListUtil.ChainableArrayListUtil<>(keywords)
                .map(String::toLowerCase).value();

        return new ArrayListUtil.ChainableArrayListUtil<>(task.getReminders()).filter(reminder -> {
                ArrayList<String> reminderKeywords = new ArrayListUtil.ChainableArrayListUtil<>(
                        reminder.getNote().split("\\s+")).map(String::toLowerCase).value();
                return !Collections.disjoint(keywordsList, reminderKeywords);
        }).value();
    }

     /**
     * Performs case-insensitive task search using keywords to search it's remidners.
     *
     * @param keywords
     *            Search keywords
     * @return List of {@code Task} matching the keywords.
     */
     public ArrayList<Task> searchByReminder(String[] keywords) {
         ArrayList<String> keywordsList = new ArrayListUtil.ChainableArrayListUtil<>(keywords)
                                                           .map(String::toLowerCase)
                                                           .value();

         return new ArrayListUtil.ChainableArrayListUtil<>(this.tasks)
                 .filter(task -> {
                     ArrayList<Reminder> filteredReminders = new ArrayListUtil.ChainableArrayListUtil<>(task.getReminders())
                             .filter(reminder -> {
                                 ArrayList<String> reminderKeywords = new ArrayListUtil.ChainableArrayListUtil<>(reminder.getNote().split("\\s+"))
                                         .map(String::toLowerCase)
                                         .value();
                                 return !Collections.disjoint(keywordsList, reminderKeywords);
                             })
                             .value();
                     return !filteredReminders.isEmpty();
                 })
                 .value();
     }
}
```
###### /java/linenux/model/Task.java
``` java
    /**
     * Constructor for To-Dos (tasks with no deadlines or predetermined time
     * slots).
     */
    public Task(String taskName, ArrayList<String> tags) {
        this(taskName, false, null, null, tags, new ArrayList<Reminder>());
    }

    /**
     * Constructor for Deadlines (tasks with deadlines only).
     */
    public Task(String taskName, LocalDateTime endTime, ArrayList<String> tags) {
        this(taskName, false, null, endTime, tags, new ArrayList<Reminder>());
    }

```
###### /java/linenux/model/Task.java
``` java
    /**
     * Constructor for Events (tasks with predetermined time slots).
     */
    public Task(String taskName, LocalDateTime startTime, LocalDateTime endTime, ArrayList<String> tags) {
        this(taskName, false, startTime, endTime, tags, new ArrayList<Reminder>());
    }

    /**
     * Constructor for all Tasks
     */
    public Task(String taskName, boolean isDone, LocalDateTime startTime, LocalDateTime endTime, ArrayList<String> tags, ArrayList<Reminder> reminders) {
        this.taskName = taskName;
        this.isDone = isDone;
        this.startTime = startTime;
        this.endTime = endTime;
        this.tags = tags;
        this.reminders = reminders;
    }

```
###### /java/linenux/model/Task.java
``` java
    public boolean isDone() {
        return isDone == true;
    }

    public boolean isNotDone() {
        return isDone == false;
    }

```
###### /java/linenux/model/Task.java
``` java
    public String getTaskName() {
        return this.taskName;
    }

    public LocalDateTime getStartTime() {
        return this.startTime;
    }

    public LocalDateTime getEndTime() {
        return this.endTime;
    }

```
###### /java/linenux/model/Task.java
``` java
    public ArrayList<Reminder> getReminders() {
        return this.reminders;
    }

    /* Setters */

```
###### /java/linenux/Stoppable.java
``` java
/**
 * Stops all processes in the application.
 */
public interface Stoppable {
    public void stop() throws Exception;
}
```
###### /java/linenux/storage/LocalDateTimeAdapter.java
``` java
public class LocalDateTimeAdapter extends XmlAdapter<String, LocalDateTime> {

    @Override
    public LocalDateTime unmarshal(String v) {
        if (v.isEmpty()) {
            return null;
        } else {
            return LocalDateTime.parse(v);
        }
    }

    @Override
    public String marshal(LocalDateTime v) {
        if (v == null) {
            return "";
        } else {
            return v.toString();
        }
    }
}
```
###### /java/linenux/storage/ScheduleStorage.java
``` java
/**
 * Reads and writes Schedule to the file format.
 */
public interface ScheduleStorage {
    public static final String DEFAULT_FILE_PATH = Paths.get(".").toAbsolutePath().toString();
    public static final String FILENAME = "Schedule.xml";

    /**
     * Reads schedule from file.
     */
    public Schedule loadScheduleFromFile();

    /**
     * Writes schedule to file.
     */
    public void saveScheduleToFile(Schedule schedule);

    /**
     * Checks if file exist.
     */
    public boolean hasScheduleFile();

    /**
     * Set file path.
     */
    public void setFilePath(String filePath);
}
```
###### /java/linenux/storage/XmlScheduleStorage.java
``` java
public class XmlScheduleStorage implements ScheduleStorage {
    private Path filePath;

    public XmlScheduleStorage() {
        this.filePath = Paths.get(DEFAULT_FILE_PATH + FILENAME);
    }

    public XmlScheduleStorage(String filePath) {
        this.filePath = Paths.get(filePath);
    }

    @Override
    public Schedule loadScheduleFromFile() {
        try {
            JAXBContext context = JAXBContext.newInstance(AdaptedSchedule.class);
            Unmarshaller u = context.createUnmarshaller();

            if (!hasScheduleFile()) {
                System.out.println("hello");
                createFile();
            }

            AdaptedSchedule aSchedule = (AdaptedSchedule) u.unmarshal(filePath.toFile());
            return aSchedule.convertToModel();
        } catch (Exception e) {
            Alert alert = throwAlert("Loading Error", "Could not load data from file: \n" + filePath.toString());
            alert.showAndWait();
            return null;
        }
    }

    @Override
    public void saveScheduleToFile(Schedule schedule) {
        try {
            AdaptedSchedule aSchedule = new AdaptedSchedule();
            aSchedule.convertToXml(schedule);
            JAXBContext context = JAXBContext.newInstance(aSchedule.getClass());
            Marshaller m = context.createMarshaller();
            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);

            if (!hasScheduleFile()) {
                createFile();
            }

            m.marshal(aSchedule, filePath.toFile());
        } catch (Exception e) {
            Alert alert = throwAlert("Saving Error", "Could not save data to file: \n" + filePath.toString());
            alert.showAndWait();
        }
    }

    @Override
    public boolean hasScheduleFile() {
        return Files.exists(filePath);
    }

    @Override
    public void setFilePath(String filePath) {
        this.filePath = Paths.get(filePath + FILENAME);
    }

    private void createFile() throws IOException {
        try {
            Files.createFile(filePath);
        } catch (IOException i) {
            Files.createDirectories(filePath);
            createFile();
        } catch (Exception e) {
            Alert alert = throwAlert("Creating File Error", "Could not create file at: \n" + filePath.toString());
            alert.showAndWait();
        }
    }

    private Alert throwAlert(String title, String message) {
        Alert alert = new Alert(AlertType.ERROR);
        alert.setTitle(title);
        alert.setContentText(message);
        return alert;
    }

}
```
###### /java/linenux/time/parser/TimeParser.java
``` java
/**
 * All time parser types must support interface methods.
 */
public interface TimeParser {

    /**
     * Checks if the user input corresponds to the format of the respective
     * time parser.
     *
     * @param userInput
     * @return true if format matches and false otherwise.
     */
    public boolean respondTo(String userInput);

    /**
     * Parses the userInput string to a time instance.
     * Contract: use respondTo to check before calling execute
     * @param userInput
     * @return
     */
    public LocalDateTime parse(String userInput);
}
```
###### /java/linenux/util/FileUtil.java
``` java
public class FileUtil {

    public static Either<Boolean, CommandResult> doesFileExist(String pathString) {
        Either<Path, CommandResult> path = getPathFromString(pathString);

        if (path.isRight()) {
            return Either.right(path.getRight());
        }
        try {
            return Either.left(Files.exists(path.getLeft()));
        } catch (SecurityException e) {
            return Either.right(makeNoPermissionsResult());
        }
    }

    public static Either<Path, CommandResult> getPathFromString(String pathString) {
        try {
            return Either.left(Paths.get(pathString));
        } catch (InvalidPathException e) {
            return Either.right(makeInvalidPathResult());
        }
    }

    private static CommandResult makeInvalidPathResult() {
        return () -> "String contains invalid characters.";
    }

    private static CommandResult makeNoPermissionsResult() {
        return () -> "Do not have permissions to read the file.";
    }
}
```
