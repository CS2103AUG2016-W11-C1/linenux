# A0140702X
###### /java/linenux/command/ClearCommand.java
``` java
/**
 * Clears the schedule of all done tasks.
 */
public class ClearCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "clear";
    private static final String DESCRIPTION = "Clears the schedule of all done tasks.";
    private static final String COMMAND_FORMAT = "clear";

    private Schedule schedule;

    /**
     * Constructs an {@code ClearCommand}.
     * @param schedule The {@code Schedule} that will be cleared.
     */
    public ClearCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        ArrayList<Task> doneTasks = this.schedule.getTaskList();

        String tag = extractTag(userInput);

        if (tag != null) {
            doneTasks = new ArrayListUtil.ChainableArrayListUtil<>(doneTasks)
                .filter(task -> task.hasTag(tag)).value();
        } else {
            doneTasks = new ArrayListUtil.ChainableArrayListUtil<>(doneTasks)
                .filter(Task::isDone).value();
        }

        if (doneTasks.isEmpty()) {
            return () -> "There are no done tasks to clear!";
        } else {
            this.schedule.deleteTasks(doneTasks);
            return () -> "Deleting tasks!";
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Extract tag from the {@code argument}.
     * @param argument A {@code String} representing the argument of the {@code Command}.
     * @return A tag, if present.
     */
    private String extractTag(String argument) {
        GenericParser parser = new GenericParser();
        GenericParser.GenericParserResult result = parser.parse(argument);

        ArrayList<String> flags = result.getArguments("#");

        if (flags.size() == 0) {
            return null;
        } else {
            return flags.get(0);
        }
    }
}
```
###### /java/linenux/command/EditReminderCommand.java
``` java
/**
 * Edits a task in the schedule.
 */
public class EditReminderCommand extends AbstractCommand {

    private static final String TRIGGER_WORD = "editr";
    private static final String DESCRIPTION = "Edits a reminder in the schedule.";
    public static final String COMMAND_FORMAT = "editr KEYWORDS... [t/TIME] [n/NOTE]";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private GenericParser.GenericParserResult parseResult;
    private TimeParserManager timeParserManager;
    private EditReminderArgumentParser editReminderArgumentParser;
    private ArrayList<ReminderSearchResult> searchResults;

    /**
     * Constructs an {@code EditReminderCommand}.
     * @param schedule The {@code Schedule} to search and edit {@code Reminder} from.
     */
    public EditReminderCommand(Schedule schedule) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser(), new StandardDateWithTimeParser(), new TodayWithTimeParser(), new TomorrowWithTimeParser());
        this.editReminderArgumentParser = new EditReminderArgumentParser(this.timeParserManager);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);
        GenericParser parser = new GenericParser();
        GenericParser.GenericParserResult result = parser.parse(argument);

        if (result.getKeywords().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<ReminderSearchResult> results = new ArrayListUtil.ChainableArrayListUtil<>(this.schedule.getTaskList())
                .map(task -> new ReminderSearchResult(task, task.searchReminder(result.getKeywords())))
                .filter(r -> r.getReminders().size() > 0)
                .value();

        int totalResults = new ArrayListUtil.ChainableArrayListUtil<>(results)
                .map(ReminderSearchResult::getReminders)
                .map(ArrayList::size)
                .foldr((a, b) -> a + b, 0);

        if (totalResults == 0) {
            return SearchResults.makeReminderNotFoundResult(result.getKeywords());
        } else if (totalResults == 1) {
            ReminderSearchResult searchResult = results.get(0);
            return implementEditr(searchResult.getTask(), searchResult.getReminders().get(0), result);
        } else {
            setResponse(true, results, result);
            return PromptResults.makePromptReminderIndexResult(results);
        }
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.parseResult != null;
        assert this.schedule != null;
        assert this.searchResults != null;

        ArrayList<Reminder> remindersFound = new ArrayListUtil.ChainableArrayListUtil<>(searchResults)
                .map(ReminderSearchResult::getReminders)
                .foldr((r, l) -> {
                    l.addAll(r);
                    return l;
                }, new ArrayList<Reminder>())
                .value();

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);
            if (1 <= index && index <= remindersFound.size()) {
                Reminder reminder = remindersFound.get(index - 1);
                Task task = ReminderSearchResult.getTaskFromReminder(this.searchResults, reminder);

                CommandResult result = implementEditr(task, reminder, this.parseResult);
                setResponse(false, null, null);
                return result;
            } else {
                return PromptResults.makeInvalidReminderIndexResult(this.searchResults);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private CommandResult implementEditr(Task task, Reminder original, GenericParser.GenericParserResult parseResult) {
        Either<Reminder, CommandResult> result = editReminderArgumentParser.parse(original, parseResult);

        if (result.isLeft()) {
            Reminder newReminder = result.getLeft();
            Task newTask = task.removeReminder(original).addReminder(newReminder);
            this.schedule.updateTask(task, newTask);
            return makeEditedReminder(original, newReminder);
        } else {
            return result.getRight();
        }
    }

    /**
     * Updates the user response status.
     * @param requiresUserResponse Whether or not this {@code Command} is expecting user response.
     * @param results An {@code ArrayList} of {@code ReminderSearchResult} representing the search results.
     * @param result The result of parsing user argument.
     */
    private void setResponse(boolean requiresUserResponse, ArrayList<ReminderSearchResult> results, GenericParser.GenericParserResult result) {
        this.requiresUserResponse = requiresUserResponse;
        this.searchResults = results;
        this.parseResult = result;
    }

    /**
     * @return A {@code CommandResult} indicating that the user does not specify a keywords.
     */
    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @param original The {@code Reminder} before being edited.
     * @param reminder The updated {@code Reminder}.
     * @return A {@code CommandResult} informing the user that {@code original} has been updated to {@code reminder}.
     */
    private CommandResult makeEditedReminder(Reminder original, Reminder reminder) {
        return () -> "Edited \"" + original.getNote() + "\".\nNew reminder details: " + reminder.toString();
    }

    /**
     * @return A {@code CommandResult} indicating that the edit reminder operation is cancelled.
     */
    private CommandResult makeCancelledResult() {
        return () -> "OK! Not editing anything.";
    }

    /**
     * @param userInput A {@code String} representing the user response.
     * @return A {@code CommandResult} indicating that {@code userInput} is invalid.
     */
    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which reminder to edit.\n");
            builder.append(RemindersListUtil.displaySearchResults(this.searchResults));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/ExitCommand.java
``` java
/**
 * Exits the program.
 */
public class ExitCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "exit";
    private static final String DESCRIPTION = "Exits the program.";
    public static final String COMMAND_FORMAT = "exit";

    /**
     * Constructs an {@code ExitCommand}.
     */
    public ExitCommand() {
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());

        System.exit(0);
        return null;
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }
}
```
###### /java/linenux/command/filter/ListArgumentFilter.java
``` java
/**
 * Parser for the argument portion of list command.
 **/
public class ListArgumentFilter {
    public static String COMMAND_FORMAT;
    public static String CALLOUTS;

    private TimeParserManager timeParserManager;

    /**
     * Public constructor.
     * @param timeParserManager A {@code TimeParserManager} representing all accepted time format.
     * @param commandFormat A {@code String} representing the format of the command that is using this class.
     * @param callouts A {@code String} representing the extra message shown to the user in case of errors.
     */
    public ListArgumentFilter(TimeParserManager timeParserManager, String commandFormat, String callouts) {
        this.timeParserManager = timeParserManager;
        ListArgumentFilter.COMMAND_FORMAT = commandFormat;
        ListArgumentFilter.CALLOUTS = callouts;
    }

    /**
     * Filter the list of tasks based on argument specified by the user.
     * @param argument The argument, which is part of the user input.
     * @param tasks The search space.
     * @param doneOnly Set this to true if and only if we are interested in only done tasks.
     * @return An {@code Either}. If search was successful, the left slot will contain the list of filtered tasks.
     * Otherwise, the right slot will contain a {@code CommandResult} describing the failure.
     */
    public Either<ArrayList<Task>, CommandResult> filter(String argument, ArrayList<Task> tasks, Boolean doneOnly) {
        ArrayList<Task> filteredTasks = tasks;

        Either<LocalDateTime, CommandResult> startTime = extractStartTime(argument);
        if (startTime.isRight()) {
            return Either.right(startTime.getRight());
        }

        Either<LocalDateTime, CommandResult> endTime = extractEndTime(argument);
        if (endTime.isRight()) {

            return Either.right(endTime.getRight());
        }

        Either<ArrayList<String>, CommandResult> tags = extractTags(argument);
        if (tags.isRight()) {
            return Either.right(tags.getRight());
        }

        LocalDateTime actualStartTime = startTime.getLeft();
        LocalDateTime actualEndTime = endTime.getLeft();
        ArrayList<String> actualTags = tags.getLeft();

        if (actualStartTime != null && actualEndTime != null && actualEndTime.compareTo(actualStartTime) < 0) {
            return Either.right(makeEndTimeBeforeStartTimeResult());
        }

        if (doneOnly) {
            filteredTasks = new ArrayListUtil.ChainableArrayListUtil<>(filteredTasks)
                .filter(Task::isDone)
                .value();
        }

        //filter the tasks by the time parameters
        if (actualStartTime != null && actualEndTime != null) {
            filteredTasks = new ArrayListUtil.ChainableArrayListUtil<>(filteredTasks).filter(task -> {
                            boolean checker = task.isTodo()
                                    || task.getEndTime().isEqual(actualStartTime) || task.getEndTime().isEqual(actualEndTime)
                                    || (task.getEndTime().isAfter(actualStartTime) && task.getEndTime().isBefore(actualEndTime));
                            if (task.isEvent()) {
                                LocalDateTime taskStartTime = task.getStartTime();
                                return checker || taskStartTime.isEqual(actualStartTime) || taskStartTime.isEqual(actualEndTime)
                            || (taskStartTime.isAfter(actualStartTime) && taskStartTime.isBefore(actualEndTime))
                            || (taskStartTime.isBefore(actualStartTime) && task.getEndTime().isAfter(actualEndTime));
                            }
                            return checker; })
                        .value();
        } else if (actualStartTime != null) {
            filteredTasks = new ArrayListUtil.ChainableArrayListUtil<>(filteredTasks)
                    .filter(task -> task.isTodo() || task.getEndTime().isAfter(actualStartTime)
                            || task.getEndTime().isEqual(actualStartTime))
                    .value();
        } else if (actualEndTime != null) {
            filteredTasks = new ArrayListUtil.ChainableArrayListUtil<>(filteredTasks)
                    .filter(task -> {
                        boolean checker = task.isTodo() || task.getEndTime().isBefore(actualEndTime)
                            || task.getEndTime().isEqual(actualEndTime);
                        if (task.isEvent()) {
                            return checker || task.getStartTime().isBefore(actualEndTime) || task.getStartTime().isEqual(actualEndTime);
                        };

                        return checker; })
                    .value();
        }

        //filter tasks by tags
        if (!actualTags.isEmpty()) {
            for (String tag : actualTags) {
                filteredTasks = new ArrayListUtil.ChainableArrayListUtil<>(filteredTasks)
                        .filter(task -> task.hasTag(tag)).value();

            }
        }

        return Either.left(filteredTasks);
    }

    /**
     * Filter the list of reminders based on user argument.
     * @param argument A {@code String} representing the argument given by the user.
     * @param reminders The list of {@code Reminder} to search from. This is the search space.
     * @return An {@Either}. If search is successful, its left slot is a list of {@code Reminder}. Otherwise, its
     * right slot is a {@code CommandResult} describing the failure.
     */
    public Either<ArrayList<Reminder>, CommandResult> filterReminders(String argument, ArrayList<Reminder> reminders) {
        ArrayList<Reminder> filteredReminders = new ArrayListUtil.ChainableArrayListUtil<>(reminders)
                            .sortBy(Reminder::getTimeOfReminder)
                            .value();

        Either<LocalDateTime, CommandResult> startTime = extractStartTime(argument);
        if (startTime.isRight()) {
            return Either.right(startTime.getRight());
        }

        Either<LocalDateTime, CommandResult> endTime = extractEndTime(argument);
        if (endTime.isRight()) {
            return Either.right(endTime.getRight());
        }

        Either<ArrayList<String>, CommandResult> tags = extractTags(argument);
        if (tags.isRight()) {
            return Either.right(tags.getRight());
        }

        ArrayList<String> actualTags = tags.getLeft();
        if (!actualTags.isEmpty()) {
            return Either.left(new ArrayList<Reminder>());
        }

        LocalDateTime actualStartTime = startTime.getLeft();
        LocalDateTime actualEndTime = endTime.getLeft();

        //filter the reminders by the time parameters
        if (actualStartTime != null && actualEndTime != null) {
            filteredReminders = new ArrayListUtil.ChainableArrayListUtil<>(filteredReminders)
                    .filter(reminder -> reminder.getTimeOfReminder().isEqual(actualStartTime)
                    || (reminder.getTimeOfReminder().isAfter(actualStartTime) && reminder.getTimeOfReminder().isBefore(actualEndTime)))
                    .value();
        } else if (actualStartTime != null) {
            filteredReminders = new ArrayListUtil.ChainableArrayListUtil<>(filteredReminders)
                    .filter(reminder -> reminder.getTimeOfReminder().isAfter(actualStartTime)
                            || reminder.getTimeOfReminder().isEqual(actualStartTime))
                    .value();
        } else if (actualEndTime != null) {
            filteredReminders = new ArrayListUtil.ChainableArrayListUtil<>(filteredReminders)
                    .filter(reminder -> reminder.getTimeOfReminder().isBefore(actualEndTime)
                            || reminder.getTimeOfReminder().isEqual(actualEndTime))
                    .value();
        }

        return Either.left(filteredReminders);
    }

    /**
     * @param tasks An {@code ArrayList} of {@code Task}.
     * @return Tasks that are not marked as done
     */
    public ArrayList<Task> filterUndoneTasks(ArrayList<Task> tasks) {
        ArrayList<Task> undoneTasks = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isNotDone)
                .value();

        return undoneTasks;
    }

    /**
     * Attempts to parse a start time string.
     * @param argument The {@code String} to parse.
     * @return An {@code Either}. Its left slot is a {@code LocalDateTime} if {@code argument} can be parsed. Otherwise,
     * its right slot contains a {@code CommandResult} describing the failure.
     */
    private Either<LocalDateTime, CommandResult> extractStartTime(String argument) {
        Matcher matcher = Pattern.compile("(^|.*? )st/(?<startTime>.*?)(\\s+(#|et)/.*)?").matcher(argument);

        if (matcher.matches() && matcher.group("startTime") != null) {
            return parseDateTime(matcher.group("startTime").trim());
        } else {
            return Either.left(null);
        }
    }

    /**
     * Attempts to parse a end time string.
     * @param argument The {@code String} to parse.
     * @return An {@code Either}. Its left slot is a {@code LocalDateTime} if {@code argument} can be parsed. Otherwise,
     * its right slot contains a {@code CommandResult} describing the failure.
     */
    private Either<LocalDateTime, CommandResult> extractEndTime(String argument) {
        Matcher matcher = Pattern.compile("(^|.*? )et/(?<endTime>.*?)(\\s+(#|st)/.*)?$").matcher(argument);

        if (matcher.matches() && matcher.group("endTime") != null) {
            return parseDateTime(matcher.group("endTime").trim());
        } else {
            return Either.left(null);
        }
    }

    /**
     * Attempts to extract tags from user argument.
     * @param argument A {@code String} representing the argument given by the user.
     * @return An {@code Either}. Its left slot is a {@code ArrayList} of {@code String} representing the tags, if
     * parsing is successful. Otherwise, its right slot will contain a {@CommandResult} describing the failure.
     */
    private Either<ArrayList<String>, CommandResult> extractTags(String argument) {
        Matcher matcher = Pattern.compile("(?=(^|.*? )#/(?<tags>.*?)(\\s+(st|et|#)/.*)?$)").matcher(argument);
        ArrayList<String> tagList = new ArrayList<>();
        String input;

        while (matcher.find() && matcher.group("tags") != null) {
            input = matcher.group("tags").trim();
            if (input.isEmpty()) {
                return Either.right(makeInvalidArgumentResult());
            }
            if (!tagList.contains(input)) {
                tagList.add(input);
            }
        }

        return Either.left(tagList);
    }

    /**
     * A generic helper used to parse a date time string.
     * @param string A {@code string} to parse.
     * @return An {@Either}. Its left slot is a {@code LocalDateTime} if {@code string} can be parsed. Otherwise, its
     * right slot is a {@code CommandResult} describing the failure.
     */
    private Either<LocalDateTime, CommandResult> parseDateTime(String string) {
        if (this.timeParserManager.canParse(string)) {
            return Either.left(this.timeParserManager.delegateTimeParser(string));
        } else {
            return Either.right(makeInvalidDateTimeResult(string));
        }
    }

    /**
     * @return A {@code CommandResult} when the given argument is invalid.
     */
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @param dateTime A {@code String} extracted from user argument that is supposed to represent a date time.
     * @return A {@code CommandResult} when {@code dateTime} is not a valid date time {@code String}.
     */
    private CommandResult makeInvalidDateTimeResult(String dateTime) {
        return () -> "Cannot parse \"" + dateTime + "\".";
    }

    /**
     * @return A {@code CommandResult} when the end time specified by the user comes before the start time.
     */
    private CommandResult makeEndTimeBeforeStartTimeResult() {
        return () -> "End time cannot come before start time.";
    }
}
```
###### /java/linenux/command/HelpCommand.java
``` java
/**
 * Displays available command and their formats.
 */
public class HelpCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "help";
    private static final String DESCRIPTION = "Shows this help message.";
    private static final String COMMAND_FORMAT = "help";

    private ArrayList<Command> commands;

    /**
     * Instantiate the {@code HelpCommand}.
     * @param commands An {@code ArrayList} of supported {@code Command}.
     */
    public HelpCommand(ArrayList<Command> commands) {
        this.commands = commands;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());

        String keywords = extractArgument(userInput);
        Command commandRequested = null;

        if (keywords.trim().isEmpty()) {
            return () -> displayAllHelp();
        }

        String[] parts = keywords.split(" ");

        if (parts.length > 1) {
            return makeInvalidKeywordResponse();
        }

        for (Command command : this.commands) {
            if (command.getTriggerWord().equals(keywords)) {
                commandRequested = command;
                break;
            }
        }

        if (commandRequested == null) {
            return makeInvalidCommandResponse(keywords);
        }

        return displaySpecificHelp(commandRequested);
    }

    /**
     * @param commandRequested The {@code Command} that the user specified.
     * @return {@code CommandResult} containing help for {@code commandRequested}.
     */
    private CommandResult displaySpecificHelp(Command commandRequested) {
        return () -> makeHelpDescriptionForCommand(commandRequested);
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * @return Formatted help message for all {@code Command}.
     */
    private String displayAllHelp() {
        StringBuilder builder = new StringBuilder();
        for (Command command: this.commands) {
            builder.append(makeHelpDescriptionForCommand(command));
        }

        builder.append(CALLOUTS);

        return builder.toString();
    }

    /**
     * @param command The {@code Command} to display help message.
     * @return Formatted help message for {@code command}.
     */
    private String makeHelpDescriptionForCommand(Command command) {
        StringBuilder builder = new StringBuilder();
        Set<String> aliasList = command.getTriggerWords();


        builder.append(command.getTriggerWord());
        for (String alias : aliasList) {
            if (alias.equals(command.getTriggerWord())) {
                continue;
            }

            builder.append(", " + alias);
        }
        builder.append(" - ");
        builder.append("\n");

        builder.append("Description: ");
        builder.append(command.getDescription());
        builder.append('\n');

        builder.append("Format: ");
        builder.append(command.getCommandFormat());
        builder.append("\n\n");

        return builder.toString();
    }

    /**
     * @return {@code CommandResult} indicating that argument is invalid.
     */
    private CommandResult makeInvalidKeywordResponse() {
        return () -> "Too many arguments given. Please only search for one command at a time.";
    }

    /**
     * @param userInput The user response.
     * @return {@code CommandResult} indicating that {@code userInput} is not a valid response.
     */
    private CommandResult makeInvalidCommandResponse(String userInput) {
        assert (userInput.split(" ").length == 1);

        String userCommand = userInput;
        Command closestCommand = null;
        int bestScore = Integer.MAX_VALUE;

        for (Command command: this.commands) {
            int similarity = StringsSimilarity.compute(userCommand, command.getTriggerWord());
            if (similarity < bestScore) {
                closestCommand = command;
                bestScore = similarity;
            }
        }

        if (closestCommand == null) {
            return makeInvalidCommandResponse();
        } else {
            return makeResponseWithSuggestion(closestCommand.getTriggerWord());
        }
    }

    /**
     * @return {@code CommandResult} indicating that the specified command is invalid.
     */
    private CommandResult makeInvalidCommandResponse() {
        return () -> "Invalid command.";
    }

    /**
     * @param suggestion The suggested command.
     * @return {@code CommandResult} indicating that the specified command is invalid.
     */
    private CommandResult makeResponseWithSuggestion(String suggestion) {
        return () -> "Invalid command given for help. Did you mean \'" + suggestion + "\'?";
    }
}
```
###### /java/linenux/command/ListCommand.java
``` java
/**
 * Generates a list of tasks based on userInput.
 */
public class ListCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "list";
    private static final String DESCRIPTION = "Lists tasks and reminders.";
    private static final String COMMAND_FORMAT = "list [KEYWORDS...] [st/START_TIME] [et/END_TIME] [#/TAG]";
    private static final String VIEW_DONE_ONLY = "yes";
    private static final String VIEW_DONE = "all";

    private Schedule schedule;
    private TimeParserManager timeParserManager;
    private ListArgumentFilter listArgumentFilter;

    public ListCommand(Schedule schedule) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser(), new StandardDateWithTimeParser(), new TodayWithTimeParser(), new TomorrowWithTimeParser());
        this.listArgumentFilter = new ListArgumentFilter(this.timeParserManager, COMMAND_FORMAT, CALLOUTS);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        ArrayList<Task> tasks = this.schedule.getTaskList();
        ArrayList<Reminder> reminders = this.schedule.getReminderList();

        if (tasks.isEmpty() && reminders.isEmpty()) {
            return makeEmptyTaskListResult();
        }

        String arguments = extractArgument(userInput);
        GenericParser parser = new GenericParser();
        GenericParser.GenericParserResult result = parser.parse(arguments);
        Either<String, CommandResult> viewDone = extractViewDone(result);

        if (viewDone.isRight()) {
            return viewDone.getRight();
        }

        if (!result.getKeywords().isEmpty()) {
            tasks = this.schedule.search(result.getKeywords());
            reminders = this.schedule.searchReminder(result.getKeywords());
        }

        String actualViewDone = viewDone.getLeft();
        Boolean doneOnly = actualViewDone.equals(VIEW_DONE_ONLY);

        Either<ArrayList<Task>, CommandResult> filterTasks = this.listArgumentFilter.filter(arguments, tasks, doneOnly);
        if (filterTasks.isRight()) {
            return filterTasks.getRight();
        }

        ArrayList<Task> actualFilterTasks = filterTasks.getLeft();
        ArrayList<Reminder> actualFilterReminders = new ArrayList<Reminder>();

        //If users request for done tasks only, we will not show any reminders
        if (!doneOnly) {
            Either<ArrayList<Reminder>, CommandResult> filterReminders = this.listArgumentFilter.filterReminders(arguments, reminders);
            if (filterReminders.isRight()) {
                return filterReminders.getRight();
            }

            actualFilterReminders = filterReminders.getLeft();
        }

        //Remove all done tasks if field d/ is not yes amd all
        if (!actualViewDone.equals(VIEW_DONE) && !actualViewDone.equals(VIEW_DONE_ONLY)) {
            actualFilterTasks = this.listArgumentFilter.filterUndoneTasks(actualFilterTasks);
        }


        if (actualFilterTasks.size() == 0 && actualFilterReminders.size() == 0) {
            this.schedule.addFilterTasks(new ArrayList<>());
            return makeNoTasksAndRemindersFoundResult();
        } else {
            return makeResult(actualFilterTasks, actualFilterReminders);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private Either<String, CommandResult> extractViewDone(GenericParser.GenericParserResult result) {
        ArrayList<String> flags = result.getArguments("d");

        if (flags.size() == 0) {
            return Either.left("");
        } else {
            return parseViewDone(flags.get(0));
        }
    }

    private Either<String, CommandResult> parseViewDone(String string) {
        if (string.toLowerCase().equals(VIEW_DONE)) {
            return Either.left(VIEW_DONE);
        } else if (string.toLowerCase().equals(VIEW_DONE_ONLY)){
            return Either.left(VIEW_DONE_ONLY);
        }

        return Either.right(makeInvalidViewDoneResult(string));
    }

    private CommandResult makeInvalidViewDoneResult(String viewDone) {
        return () -> "Unable to parse \"" + viewDone + "\".\n" + "Did you mean:\n"
                + "d/" + VIEW_DONE + " - View all done and uncompleted tasks.\n"
                + "d/" + VIEW_DONE_ONLY + " - Show only tasks that are marked done.";
    }

    private CommandResult makeEmptyTaskListResult() {
        return () -> "You have no tasks and reminders to list!";
    }

    private CommandResult makeNoTasksAndRemindersFoundResult() {
        return () -> "There are no tasks and reminders found based on your given inputs!";
    }

    private CommandResult makeResult(ArrayList<Task> tasks, ArrayList<Reminder> reminders) {
        this.schedule.addFilterTasks(tasks);

        return () -> {
            if (reminders.isEmpty()) {
                return "";
            } else {
                return "Reminders:\n" + ArrayListUtil.display(reminders);
            }
        };
    }
}
```
###### /java/linenux/command/parser/EditReminderArgumentParser.java
``` java
/**
 * Parses new details of reminder to be edited.
 */
public class EditReminderArgumentParser extends BaseArgumentParser {
    private GenericParser.GenericParserResult parseResult;

    /**
     * The public constructor for {@code EditReminderArgumentParser}.
     * @param timeParserManager A {@code TimeParserManager} used to parse any date time string.
     */
    public EditReminderArgumentParser(TimeParserManager timeParserManager) {
        this.timeParserManager = timeParserManager;
    }

    /**
     * Attempts to parse an argument given by the user.
     * @param original A {@code Reminder}, the original {@code Reminder} object.
     * @param result A {@code GenericParserResult}, which is the output {@code GenericParser}.
     * @return An {@code Either}. Its left slot is a {@code Reminder}, updated from {@code original} based on
     * {@code argument}, if {@code argument} represents a valid instruction to edit a {@code Reminder}. Otherwise, its
     * right slot contains a {@code CommandResult} indicating the failure.
     */
    public Either<Reminder, CommandResult> parse(Reminder original, GenericParser.GenericParserResult result) {
        this.parseResult = result;

        return Either.<Reminder, CommandResult>left(original)
                .bind(this::ensureNeedsEdit)
                .bind(this::extractTime)
                .bind(this::extractNote);
    }

    /**
     * Attempts to extract the reminder time from the user argument.
     * @param original A {@code Reminder}, which is the original {@code Reminder} object.
     * @return An {@code Either}. If the user argument contains a valid date time string, the left slot will be
     * {@code original} with its time updated. Otherwise, its right slot is a {@code CommandResult} indicating the
     * failure.
     */
    private Either<Reminder, CommandResult> extractTime(Reminder original) {
        if (this.parseResult.getArguments("t").size() > 0) {
            return parseCancellableDateTime(this.parseResult.getArguments("t").get(0))
                    .bind(t -> Either.left(original.setTimeOfReminder(t)));
        } else {
            return Either.left(original);
        }
    }

    /**
     * Attempts to extract the reminder note from the user argument.
     * @param original A {@code Reminder}, which is the original {@code Reminder} object.
     * @return An {@code Either}. If the user argument contains a valid note, the left slot will be {@code original}
     * with its note updated. Otherwise, its right slot is a {@code CommandResult} indicating the failure.
     */
    private Either<Reminder, CommandResult> extractNote(Reminder original) {
        if (this.parseResult.getArguments("n").size() > 0) {
            return Either.left(original.setNote(this.parseResult.getArguments("n").get(0)));
        } else {
            return Either.left(original);
        }
    }

    /**
     * Ensures that the user argument contains some instructions to edit a reminder.
     * @param reminder The {@code Reminder} to edit.
     * @return An {@code Either}. If the user argument contains some edit instructions, its left slot is
     * {@code reminder}. Otherwise, its right slot is a {@code CommandResult}.
     */
    private Either<Reminder, CommandResult> ensureNeedsEdit(Reminder reminder) {
        boolean needsEdit = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"n", "t"})
                .map(this.parseResult::getArguments)
                .map(ArrayList::size)
                .map(s -> s > 0)
                .foldr(Boolean::logicalOr, false);

        if (needsEdit) {
            return Either.left(reminder);
        } else {
            return Either.right(makeNoArgumentsResult());
        }
    }

    /**
     * @return A {@code CommandResult} indicating that there is no instructions for change.
     */
    private CommandResult makeNoArgumentsResult() {
        return () -> "No changes to be made!";
    }
}
```
###### /java/linenux/command/parser/ReminderArgumentParser.java
``` java
/**
 * A parser used to parse the arguments for the remind command.
 */
public class ReminderArgumentParser extends BaseArgumentParser {
    private GenericParser.GenericParserResult parseResult;

    /**
     * The public constructor for {@code ReminderArgumentParser}.
     * @param timeParserManager A {@code TimeParserManager} used to parse any date time string.
     */
    public ReminderArgumentParser(TimeParserManager timeParserManager) {
        this.timeParserManager = timeParserManager;
    }

    /**
     * Attempts to parse an argument given by the user.
     * @param result A {@code GenericParserResult}, which is the output of {@code GenericParser}.
     * @return An {@code Either}. Its left slot is a {@code Reminder}, constructed based on {@code argument}, if
     * {@code argument} represents a valid {@code Reminder}. Otherwise, its right slot contains a {@code CommandResult}
     * indicating the failure.
     */
    public Either<Reminder, CommandResult> parse(GenericParser.GenericParserResult result) {
        this.parseResult = result;

        return Either.<Reminder, CommandResult>left(new Reminder())
                .bind(this::extractTime)
                .bind(this::extractNote);
    }

    /**
     * Attempts to extract the reminder time from the user argument.
     * @param reminder A {@code Reminder} to store the extracted time.
     * @return An {@code Either}. If the user argument contains a valid date time string, the left slot will be
     * {@code reminder} with its time updated. Otherwise, its right slot is a {@code CommandResult} indicating the
     * failure.
     */
    private Either<Reminder, CommandResult> extractTime(Reminder reminder) {
        if (this.parseResult.getArguments("t").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("t").get(0))
                    .bind(t -> Either.left(reminder.setTimeOfReminder(t)));
        } else {
            return Either.right(makeWithoutDateResult());
        }
    }

    /**
     * Attempts to extract the reminder note from the user argument.
     * @param reminder A {@code Reminder} to store the extracted time.
     * @return An {@code Either}. If the user argument contains a valid note, the left slot will be {@code original}
     * with its note updated. Otherwise, its right slot is a {@code CommandResult} indicating the failure.
     */
    private Either<Reminder, CommandResult> extractNote(Reminder reminder) {
        if (this.parseResult.getArguments("n").size() > 0) {
            return Either.left(reminder.setNote(this.parseResult.getArguments("n").get(0)));
        } else {
            return Either.right(makeWithoutNoteResult());
        }
    }

    /**
     * @return A {@code CommandResult} indicating that the user has not specified a date.
     */
    private CommandResult makeWithoutDateResult() {
        return () -> "Cannot create reminder without date.";
    }

    /**
     * @return A {@code CommandResult} indicating that the user has not specified a note.
     */
    private CommandResult makeWithoutNoteResult() {
        return () -> "Cannot create reminder without note.";
    }
}
```
###### /java/linenux/command/RemindCommand.java
``` java
/**
 * Adds a reminder to a task in the schedule
 */
public class RemindCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "remind";
    private static final String DESCRIPTION = "Adds a reminder to a task in the schedule.";
    public static final String COMMAND_FORMAT = "remind KEYWORDS t/TIME n/NOTE";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private GenericParser.GenericParserResult parseResult;
    private ArrayList<Task> foundTasks;
    private TimeParserManager timeParserManager;
    private ReminderArgumentParser reminderArgumentParser;

    public RemindCommand(Schedule schedule) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser(), new StandardDateWithTimeParser(), new TodayWithTimeParser(), new TomorrowWithTimeParser());
        this.reminderArgumentParser = new ReminderArgumentParser(this.timeParserManager);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);
        GenericParser parser = new GenericParser();
        GenericParser.GenericParserResult result = parser.parse(argument);

        if (result.getKeywords().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(result.getKeywords());

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(result.getKeywords());
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            return implementRemind(task, result);
        } else {
            setResponse(true, tasks, result);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.parseResult != null;
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                CommandResult result = implementRemind(task, this.parseResult);
                setResponse(false, null, null);
                return result;
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private CommandResult implementRemind(Task original, GenericParser.GenericParserResult parseResult) {
        Either<Reminder, CommandResult> result = reminderArgumentParser.parse(parseResult);

        if (result.isLeft()) {
            this.schedule.updateTask(original, original.addReminder(result.getLeft()));
            return makeResult(original, result.getLeft());
        } else {
            return result.getRight();
        }
    }

    /**
     * Updates the user response status.
     * @param requiresUserResponse Whether or not this {@code Command} is expecting user response.
     * @param foundTasks An {@code ArrayList} of {@code Task} matching some search criteria.
     * @param result The result of parsing user argument.
     */
    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks, GenericParser.GenericParserResult result) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
        this.parseResult = result;
    }

    /**
     * @return A {@code CommandResult} indicating that the user does not specify a keywords.
     */
    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeResult(Task task, Reminder reminder) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd h.mma");

        return () -> "Added reminder on " + reminder.getTimeOfReminder().format(formatter) + " for "
                + task.getTaskName();
    }

    /**
     * @return A {@code CommandResult} indicating that the remind operation is cancelled.
     */
    private CommandResult makeCancelledResult() {
        return () -> "OK! Not adding new reminder.";
    }

    /**
     * @param userInput A {@code String} representing the user response.
     * @return A {@code CommandResult} indicating that {@code userInput} is invalid.
     */
    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to add reminder to:\n");
            builder.append(ArrayListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/UndoneCommand.java
``` java
public class UndoneCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "undone";
    private static final String DESCRIPTION = "Marks a task as not done.";
    private static final String COMMAND_FORMAT = "undone KEYWORDS";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private ArrayList<Task> foundTasks;

    public UndoneCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = new ArrayListUtil.ChainableArrayListUtil<>(this.schedule.search(keywords))
                .filter(Task::isDone).value();

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            this.schedule.updateTask(task, task.markAsUndone());
            return makeUndoneTask(task);
        } else {
            setResponse(true, tasks);
            return PromptResults.makePromptIndexResult(tasks);
        }

    }

    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                this.schedule.updateTask(task, task.markAsUndone());

                setResponse(false, null);
                return makeUndoneTask(task);
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks) {
        this.foundTasks = foundTasks;
        this.requiresUserResponse = requiresUserResponse;
    }

    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeUndoneTask(Task task) {
        return () -> "\"" + task.getTaskName() + "\" is marked as undone.";
    }

    private CommandResult makeCancelledResult() {
        return () -> "OK! Not marking any task as undone.";
    }

    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to mark as undone.\n");
            builder.append(ArrayListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/control/CommandManager.java
``` java
/**
 * A collection class to contain all commands that the program can handle.
 */
public class CommandManager {
    private ArrayList<Command> commands = new ArrayList<>();
    private Command catchAllCommand = null;

    /**
     * Assigns the appropriate command to the user input. Contract: only 1
     * command should be awaiting user response at any point in time.
     */
    public CommandResult delegateCommand(String userInput) {
        for (Command command : this.commands) {
            if (command.isAwaitingUserResponse()) {
                return command.processUserResponse(userInput);
            }
        }

        for (Command command : this.commands) {
            if (command.respondTo(userInput)) {
                return command.execute(userInput);
            }
        }

        return this.catchAllCommand.execute(userInput);
    }

    /**
     * @return An {@code ArrayList} of {@code Command}.
     */
    public ArrayList<Command> getCommandList() {
        return this.commands;
    }

    /**
     * Add a new {@code Command} into the manager.
     * @param command The new {@code Command} to add.
     */
    public void addCommand(Command command) {
        this.commands.add(command);
    }

    /**
     * Set the catch all command which will be used when no other commands can handle some input.
     * @param command A {@code Command} that can handle any user input.
     */
    public void setCatchAllCommand(Command command) {
        this.catchAllCommand = command;
    }
}
```
###### /java/linenux/time/parser/TodayWithTimeParser.java
``` java
/**
 * Parse date and time in the form of "today 5.00pm"
 */
public class TodayWithTimeParser implements TimeParser {
    private static final String TODAY_TIME_PATTERN = "(?i)^today (1[012]|[1-9]).[0-5][0-9](\\s)?(am|pm)";

    private DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h.mma");
    private Clock clock = Clock.systemDefaultZone();

    /**
     * Checks if the user input corresponds to the format of the respective
     * time parser.
     *
     * @param input
     * @return true if format matches and false otherwise.
     */
    @Override
    public boolean respondTo(String input) {
        return input.matches(TODAY_TIME_PATTERN);
    }

    /**
     * Parses the userInput string to a time instance. This method assumes that {@code respondTo} returns {@code true}.
     * @param input The input to parse.
     * @return The {@code LocalDateTime}, which is the result of parsing {@code input}.
     */
    @Override
    public LocalDateTime parse(String input) {
        assert input.matches(TODAY_TIME_PATTERN);

        String todayDate = LocalDate.now(this.clock).toString();
        String time = input.split("\\s+")[1];
        String todayDateTime = todayDate + " " + time;

        return LocalDateTime.parse(todayDateTime.toUpperCase(), formatter);
    }

    public void setClock(Clock clock) {
        this.clock = clock;
    }
}
```
###### /java/linenux/util/RemindersListUtil.java
``` java
public class RemindersListUtil {
    /**
     * Display the list of {@code ReminderSearchResult}.
     * @param results An {@code ArrayList} of {@code ReminderSearchResult} to display.
     * @return A {@code String} representing {@code results}.
     */
    public static String displaySearchResults(ArrayList<ReminderSearchResult> results) {
        StringBuilder builder = new StringBuilder();

        int counter = 1;
        for (ReminderSearchResult result: results) {
            builder.append("Task: ");
            builder.append(result.getTask().getTaskName());
            builder.append("\n");

            for (int i = 0; i < result.getReminders().size(); i++, counter++) {
                builder.append(counter);
                builder.append(". ");
                builder.append(result.getReminders().get(i).toString());
                builder.append("\n");
            };
        }

        return builder.toString().trim();
    }
}
```
###### /java/linenux/util/TernarySearchTree.java
``` java
/**
 * Ternary Search Tree data structure.
 */
public class TernarySearchTree {
    private class Node {
        private char character;
        private boolean lastCharacter;
        private Node left;
        private Node center;
        private Node right;

        public Node(char character) {
            this.character = character;
        }
    }

    private Node root;
    private ArrayList<String> searchResult;

    /**
     * Constructs an {@code TernarySearchTree}.
     */
    public TernarySearchTree() {
        searchResult = new ArrayList<>();
    }

    /**
     * Adds a string to the {@code TernarySearchTree} according to TST rules.
     * @param s A {@code String} to add to the {@code TernarySearchTree}.
     */
    public void addString(String s) {
        if (s == null || s.isEmpty()) {
            return;
        }
        root = addStringHelper(root, 0, s.toLowerCase());
    }

    /**
     * @return A {@code ArrayList} of all strings in {@code TernarySearchTree}.
     */
    public ArrayList<String> getAllStrings() {
        return searchNode(root);
    }

    /**
     * Finds all strings with {@code prefix} in tree.
     * This method operates under the assumption that the {@code prefix} is not null or whitespace.
     * @param prefix A {@code String} representing the prefix.
     * @return An {@code ArrayList} representing a list of strings with the {@code prefix}.
     */
    public ArrayList<String> getAllStringsWithPrefix(String prefix) {
        assert prefix != null;
        assert !prefix.trim().isEmpty();

        String prefixLowerCase = prefix.toLowerCase();

        Node prefixLastNode = getPrefixLastNode(prefixLowerCase);

        if (prefixLastNode == null) {
            return ArrayListUtil.fromSingleton(prefixLowerCase);
        }

        ArrayList<String> prefixList = new ArrayListUtil.ChainableArrayListUtil<>(searchNode(prefixLastNode))
                .map(s -> prefixLowerCase + s)
                .value();
        return prefixList;
    }

    /**
     * Recursive method that adds each letter of a string {@code s} to the tree.
     * @param current The {@code current} node in the recursive call.
     * @param position The {@code position} represents the current character in string {@code s} in recursive call.
     * @param string The {@code s} to add to the {@code TernarySearchTree}.
     * @return A {@code Node} representing the character at the {@code position} of the string {@code s}.
     */
    private Node addStringHelper(Node current, int position, String s) {
        char c = s.charAt(position);

        if (current == null) {
            current = new Node(c);
        }

        if (c < current.character) {
            current.left = addStringHelper(current.left, position, s);
        } else if (c > current.character) {
            current.right = addStringHelper(current.right, position, s);
        } else if (position < s.length() - 1) {
            current.center = addStringHelper(current.center, position + 1, s);
        } else {
            current.lastCharacter = true;
        }
        return current;
    }

    /**
     * Traverses the {@code TernarySearchTree} starting from the {@code current} node.
     * @param current The {@code current} node is the starting node from which traversal begins.
     * @return An {@code ArrayList} representing the suffix of the {@code current} node.
     */
    private ArrayList<String> searchNode(Node current) {
        searchResult.clear();
        searchNodeHelper(current, "");
        return searchResult;
    }

    /**
     * Recursive depth-first search starting from {@code current} node.
     * @param current The {@code current} node is the starting node from which traversal begins.
     * @param s The suffix string.
     */
    private void searchNodeHelper(Node current, String s) {
        if (current != null) {
            if (current.lastCharacter) {
                searchResult.add(s + current.character);
            }
            searchNodeHelper(current.left, s);
            searchNodeHelper(current.center, s + current.character);
            searchNodeHelper(current.right, s);
        }
    }

    /**
     * Searches for the {@code Node} of the last character in the {@code prefix}.
     * @param prefix The prefix string.
     * @return The {@code Node} of the last character in the {@code prefix}.
     */
    private Node getPrefixLastNode(String prefix) {
        if (prefix == null || prefix.isEmpty()) {
            return null;
        }
        return getPrefixLastNodeHelper(root, 0, prefix);
    }

    /**
     * Recursive method that searches for the last character of the prefix.
     * @param current The {@code current} node in the recursive call.
     * @param position The {@code position} represents the current character in string {@code prefix} in recursive call.
     * @param prefix The {@code prefix} to search for in the {@code TernarySearchTree}.
     * @return A {@code Node} representing the character at the {@code position} of the string {@code s}.
     */
    private Node getPrefixLastNodeHelper(Node current, int position, String prefix) {
        if (current == null) {
            return null;
        }

        char c = prefix.charAt(position);

        if (c < current.character) {
            return getPrefixLastNodeHelper(current.left, position, prefix);
        } else if (c > current.character) {
            return getPrefixLastNodeHelper(current.right, position, prefix);
        } else if (position < prefix.length() - 1) {
            return getPrefixLastNodeHelper(current.center, position + 1, prefix);
        } else {
            return current.center;
        }
    }
}
```
###### /java/linenux/view/components/TodoCell.java
``` java
/**
 * View component used to display a single todo.
 */
public class TodoCell extends ListCell<Task> {
    @FXML
    private Label title;

    @FXML
    private Label tags;

    @FXML
    private AnchorPane container;

    private ListView<Task> parent;

    /**
     * Instantiate a {@code TodoCell}.
     * @param parent The {@code ListView} that uses this cell.
     */
    public TodoCell(ListView<Task> parent) {
        super();

        this.parent = parent;

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(TodoCell.class.getResource("/view/TodoCell.fxml"));
            loader.setController(this);
            AnchorPane result = loader.load();
            this.setGraphic(result);
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }

    /**
     * Callback when the {@code Task} is updated.
     * @param task The new {@code Task}.
     * @param empty Whether the cell is empty.
     */
    @Override
    public void updateItem(Task task, boolean empty) {
        super.updateItem(task, empty);

        this.container.getStyleClass().removeAll("no-tags", "empty", "done");

        if (empty || task == null) {
            this.container.getStyleClass().add("empty");
            this.title.setText("");
            this.tags.setText("");
        } else {
            ArrayList<String> tagsWithHash = new ArrayListUtil.ChainableArrayListUtil<>(task.getTags())
                    .map(tag -> "#" + tag)
                    .value();

            this.title.setText(task.getTaskName());
            this.tags.setText(String.join(", ", tagsWithHash));

            if (tagsWithHash.isEmpty()) {
                this.container.getStyleClass().add("no-tags");
            }

            if (task.isDone()) {
                this.container.getStyleClass().add("done");
            }
        }
    }

    /**
     * Callback to initialize the component when various children are ready.
     * Here we make sure that the container does not grow wider than the list.
     */
    @FXML
    private void initialize() {
        this.container.setMaxWidth(this.parent.getWidth());
        this.parent.widthProperty().addListener(change -> {
            this.container.setMaxWidth(this.parent.getWidth());
        });
    }
}
```
###### /java/linenux/view/DeadlineBoxController.java
``` java
/**
 * Controller for the deadline box, which displays all the deadlines
 */
public class DeadlineBoxController {
    @FXML
    private ListView<Task> deadlinesList;

    private ControlUnit controlUnit;
    private ObservableList<Task> deadlines = FXCollections.observableArrayList();

    /**
     * Initializes subviews.
     */
    @FXML
    private void initialize() {
        deadlinesList.itemsProperty().setValue(deadlines);
        deadlinesList.setCellFactory(DeadlineCell::new);
    }

    /**
     * Update the application {@code ControlUnit}.
     * @param controlUnit The new {@code ControlUnit}.
     */
    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        updateDeadlines();
        this.controlUnit.getSchedule().getStates().addListener((ListChangeListener<? super State>) c -> {
            updateDeadlines();
        });
        this.controlUnit.getSchedule().getFilteredTaskList().addListener((ListChangeListener<? super ArrayList<Task>>) c -> {
            updateFilteredDeadlines();
        });
    }

    /**
     * Render new deadlines.
     */
    private void updateDeadlines() {
        ArrayList<Task> tasks = this.controlUnit.getSchedule().getTaskList();
        ArrayList<Task> undoneTasks = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isNotDone)
                .value();
        ArrayList<Task> deadlines = filterDeadlines(undoneTasks);
        this.deadlines.setAll(deadlines);
    }

    /**
     * Render filtered deadlines.
     */
    private void updateFilteredDeadlines() {
        ArrayList<Task> filteredTasks = this.controlUnit.getSchedule().getFilteredTasks();
        ArrayList<Task> deadlines = filterDeadlines(filteredTasks);
        this.deadlines.setAll(deadlines);
    }

    /**
     * Sieve out only deadlines.
     * @param tasks The original {@code ArrayList} of {@code Task}.
     * @return An {@code ArrayList} of {@code Task} which are deadlines.
     */
    private ArrayList<Task> filterDeadlines(ArrayList<Task> tasks) {
        ArrayList<Task> deadlines = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isDeadline)
                .sortBy(Task::getTaskName)
                .sortBy(Task::getEndTime)
                .value();

        return deadlines;
    }
}
```
###### /resources/view/TodoCell.css
``` css
.todoCell {
    -fx-background-color: #83bdb8;
}

.todoCell .container {
    -fx-background-radius: 5px;
    -fx-background-color: rgba(255, 255, 255, .8);
    -fx-padding: 10px;
}

.todoCell.no-tags .container {
    -fx-padding: 10px 10px -5px 10px;
}

.todoCell.empty .container {
    -fx-background-color: #83bdb8;
}

.todoCell .name {
    -fx-font-size: 18.72px;
    -fx-font-weight: bold;
}

.todoCell.done .name .text {
    -fx-strikethrough: true;
}

.todoCell .tags {
    -fx-alignment: center-right;
    -fx-opacity: .5;
    -fx-font-size: 12px;
}

.todoCell.no-tags .tags {
    visibility: hidden;
}
```
