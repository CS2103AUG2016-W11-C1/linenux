# A0144915A
###### /java/linenux/command/AbstractCommand.java
``` java
public abstract class AbstractCommand implements Command {
    protected ArrayList<String> TRIGGER_WORDS = new ArrayList<>();

    @Override
    public boolean respondTo(String userInput) {
        return userInput.matches(getPattern());
    }

    @Override
    public void setAlias(String alias) {
        this.TRIGGER_WORDS.add(alias);
    }

    @Override
    public void removeAlias(String alias) {
        this.TRIGGER_WORDS.remove(alias);
    }

    @Override
    public String getPattern(){
        return "(?i)^\\s*(" + getTriggerWordsPattern() + ")(\\s+(?<keywords>.*))?$";
    }

    protected String getTriggerWordsPattern() {
        if (TRIGGER_WORDS.size() == 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder();

        builder.append(TRIGGER_WORDS.get(0));

        for (int i = 1; i < TRIGGER_WORDS.size(); i++) {
            builder.append('|');
            builder.append(TRIGGER_WORDS.get(i));
        }

        return builder.toString();
    }
}
```
###### /java/linenux/command/AddCommand.java
``` java
    public AddCommand(Schedule schedule) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser());
        this.addArgumentParser = new AddArgumentParser(this.timeParserManager, COMMAND_FORMAT, CALLOUTS);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);

        Either<Task, CommandResult> task = this.addArgumentParser.parse(argument);

        if (task.isLeft()) {
            this.schedule.addTask(task.getLeft());
            return makeResult(task.getLeft());
        } else {
            return task.getRight();
        }
    }

```
###### /java/linenux/command/AddCommand.java
``` java
    private String extractArgument(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords");
        } else {
            return "";
        }
    }

    private CommandResult makeResult(Task task) {
        return () -> "Added " + task.toString();
    }
}
```
###### /java/linenux/command/AliasCommand.java
``` java
    public AliasCommand(ArrayList<Command> commands) {
        this.commands = commands;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());

        String arguments = extractArguments(userInput);
        String[] commandNames = arguments.trim().split("\\s+");

        if (commandNames.length != 2) {
            return makeInvalidArgumentResult();
        }

        String command = commandNames[0];
        String alias = commandNames[1];

        if (!validCommand(command)) {
            return makeNoSuchCommandResult();
        }

        if (!validAlias(alias)) {
            return makeInvalidAliasResult();
        }

        if (!isAliasAvailable(alias)) {
            return makeAliasUsed(alias);
        }

        for (Command cmd: this.commands) {
            if (cmd.respondTo(command)) {
                cmd.setAlias(alias);
                break;
            }
        }

        return makeSuccessfulAliasResult(commandNames);
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    private boolean validCommand(String command) {
        for (Command cmd: this.commands) {
            if (cmd.respondTo(command)) {
                return true;
            }
        }
        return false;
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    private boolean isAliasAvailable(String alias) {
        for (Command cmd: this.commands) {
            if (cmd.respondTo(alias)) {
                return false;
            }
        }

        return true;
    }

```
###### /java/linenux/command/AliasCommand.java
``` java
    private CommandResult makeAliasUsed(String alias) {
        return () -> "\"" + alias + "\" is used for another command.";
    }

```
###### /java/linenux/command/Command.java
``` java
    /**
     * Checks if the user input corresponds to the format of the respective
     * command.
     *
     * @param userInput
     * @return true if format matches and false otherwise.
     */
    public boolean respondTo(String userInput);

    /**
     * Carries out the command.
     * Contract: use respondTo to check before calling execute
     * @param userInput
     * @return The result of the execution.
     */
    public CommandResult execute(String userInput);

    /**
     * Checks if command is waiting for user response.
     * @return true if command is waiting and false otherwise.
     */
    default public boolean awaitingUserResponse() {
        return false;
    }

    /**
     * Carries out the user response.
     * @param userInput
     * @return The result of the user response.
     */
    default public CommandResult userResponse(String userInput) {
        return null;
    }

    /**
     * Returns the command word.
     */
    public String getTriggerWord();

    /**
     * A brief description of what the command is about.
     * @return A string describing what the command is about.
     */
    public String getDescription();

```
###### /java/linenux/command/Command.java
``` java
    public void setAlias(String alias);

    public void removeAlias(String alias);
}
```
###### /java/linenux/command/DeleteCommand.java
``` java
    public DeleteCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractKeywords(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(keywords);

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            this.schedule.deleteTask(task);
            return makeDeletedTask(task);
        } else {
            setResponse(true, tasks);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

    @Override
    public boolean awaitingUserResponse() {
        return requiresUserResponse;
    }

    @Override
    public CommandResult userResponse(String userInput) {
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                this.schedule.deleteTask(task);

                setResponse(false, null);
                return makeDeletedTask(task);
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

```
###### /java/linenux/command/DeleteCommand.java
``` java
    private CommandResult makeDeletedTask(Task task) {
        return () -> "Deleted \"" + task.getTaskName() + "\".";
    }

    private CommandResult makeCancelledResult() {
        return () -> "OK! Not deleting anything.";
    }

    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to delete.\n");
            builder.append(TasksListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/DoneCommand.java
``` java
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractKeywords(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = new ArrayListUtil.ChainableArrayListUtil<>(this.schedule.search(keywords))
                .filter(Task::isNotDone)
                .value();

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            this.schedule.updateTask(task, task.markAsDone());
            return makeDoneTask(task);
        } else {
            setResponse(true, tasks);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

```
###### /java/linenux/command/DoneCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

```
###### /java/linenux/command/EditReminderCommand.java
``` java
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractKeywords(userInput);
        String argument = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<ReminderSearchResult> results = new ArrayListUtil.ChainableArrayListUtil<>(this.schedule.getTaskList())
                .map(task -> new ReminderSearchResult(task, task.searchReminder(keywords)))
                .filter(result -> result.getReminders().size() > 0)
                .value();

        int totalResults = new ArrayListUtil.ChainableArrayListUtil<>(results)
                .map(ReminderSearchResult::getReminders)
                .map(ArrayList::size)
                .foldr((a, b) -> a + b, 0);

        if (totalResults == 0) {
            return SearchResults.makeReminderNotFoundResult(keywords);
        } else if (totalResults == 1) {
            ReminderSearchResult result = results.get(0);
            return implementEditr(result.getTask(), result.getReminders().get(0), argument);
        } else {
            setResponse(true, results, argument);
            return PromptResults.makePromptReminderIndexResult(results);
        }
    }

```
###### /java/linenux/command/ExitCommand.java
``` java
    public ExitCommand() {
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

```
###### /java/linenux/command/ExitCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

```
###### /java/linenux/command/FreeTimeCommand.java
``` java
public class FreeTimeCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "freetime";
    private static final String DESCRIPTION = "Find a free time slot.";
    private static final String COMMAND_FORMAT = "freetime [st/START_TIME] et/END_TIME";

    private Schedule schedule;
    private TimeParserManager timeParserManager;
    private Clock clock;
    private FreeTimeArgumentParser argumentParser;

    public FreeTimeCommand(Schedule schedule) {
        this(schedule, Clock.systemDefaultZone());
    }

    public FreeTimeCommand(Schedule schedule, Clock clock) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser());
        this.argumentParser = new FreeTimeArgumentParser(this.timeParserManager, clock);
        this.clock = clock;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);
        Either<TimeInterval, CommandResult> queryInterval = this.argumentParser.parse(argument);

        if (queryInterval.isRight()) {
            return queryInterval.getRight();
        }

        ArrayList<TimeInterval> freetime = getFreeTime(queryInterval.getLeft());

        return makeResult(freetime);
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private String extractArgument(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords");
        } else {
            return "";
        }
    }

    private ArrayList<TimeInterval> getFreeTime(TimeInterval queryInterval) {
        ArrayList<TimeInterval> eventIntervals = eventIntervals(queryInterval, this.schedule.getTaskList());
        ArrayList<TimeInterval> busyIntervals = flattenIntervals(eventIntervals);
        return timeIntervalSubtraction(queryInterval, busyIntervals);
    }

    /**
     * Return the time intervals of all events happening within {@code queryInterval}. It is guaranteed that all
     * intervals are bounded by queryInterval, that is, for all x in output, x intersect queryInterval == x.
     * @param queryInterval The {@code TimeInterval} to bound the query.
     * @param tasks The {@code ArrayList} of tasks.
     * @return An {@code ArrayList} of {@code TimeInterval} for the events.
     */
    private ArrayList<TimeInterval> eventIntervals(TimeInterval queryInterval, ArrayList<Task> tasks) {
        return new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isEvent)
                .filter(task -> {
                    boolean endsBefore = task.getEndTime().compareTo(queryInterval.getFrom()) <= 0;
                    boolean startsAfter = task.getStartTime().compareTo(queryInterval.getTo()) >= 0;
                    return !(endsBefore || startsAfter);
                })
                .map(task -> {
                    LocalDateTime startTime = LocalDateTimeUtil.max(queryInterval.getFrom(), task.getStartTime());
                    LocalDateTime endTime = LocalDateTimeUtil.min(queryInterval.getTo(), task.getEndTime());
                    return new TimeInterval(startTime, endTime);
                })
                .value();
    }

    /**
     * Merge time intervals that intersect. The output is ordered.
     * @param input The input time intervals.
     * @return The output time intervals.
     */
    private ArrayList<TimeInterval> flattenIntervals(ArrayList<TimeInterval> input) {
        ArrayList<TimeInterval> sortedIntervals = new ArrayListUtil.ChainableArrayListUtil<>(input)
                .sortBy(TimeInterval::getFrom)
                .value();

        ArrayList<TimeInterval> output = new ArrayList<>();

        if (sortedIntervals.size() == 0) {
            return output;
        }

        TimeInterval interval = new TimeInterval(sortedIntervals.get(0).getFrom(), sortedIntervals.get(0).getTo());
        for (TimeInterval currentInterval: sortedIntervals) {
            if (interval.inInterval(currentInterval.getFrom())) {
                interval = new TimeInterval(interval.getFrom(),
                        LocalDateTimeUtil.max(interval.getTo(), currentInterval.getTo()));
            } else {
                output.add(interval);
                interval = new TimeInterval(currentInterval.getFrom(), currentInterval.getTo());
            }
        }
        output.add(interval);

        return output;
    }

    /**
     * Mathematically, returns {@code query} - {@code intervals}.
     * @param query The superset.
     * @param intervals The smaller subsets.
     * @return Return an {@code ArrayList} of time intervals that are not in {@code intervals} but in {@code query}.
     */
    private ArrayList<TimeInterval> timeIntervalSubtraction(TimeInterval query, ArrayList<TimeInterval> intervals) {
        if (intervals.size() == 0) {
            return ArrayListUtil.fromSingleton(query);
        }

        ArrayList<TimeInterval> output = new ArrayList<>();
        TimeInterval firstInterval = new TimeInterval(query.getFrom(), intervals.get(0).getFrom());
        if (!firstInterval.isTrivial()) {
            output.add(firstInterval);
        }
        for (int i = 1; i < intervals.size(); i++) {
            output.add(new TimeInterval(intervals.get(i-1).getTo(), intervals.get(i).getFrom()));
        }
        TimeInterval lastInterval = new TimeInterval(intervals.get(intervals.size() - 1).getTo(), query.getTo());
        if (!lastInterval.isTrivial()) {
            output.add(lastInterval);
        }
        return output;
    }

    private CommandResult makeResult(ArrayList<TimeInterval> freetimes) {
        return () -> {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd h:mma");
            StringBuilder builder = new StringBuilder();
            builder.append("You are free at the following time slots:\n");
            for (TimeInterval freetime: freetimes) {
                builder.append(" - ");
                builder.append(freetime.getFrom().format(formatter));
                builder.append(" - ");
                builder.append(freetime.getTo().format(formatter));
                builder.append("\n");
            }
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/HelpCommand.java
``` java
    public HelpCommand(ArrayList<Command> commands) {
        this.commands = commands;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

```
###### /java/linenux/command/InvalidCommand.java
``` java
    public InvalidCommand(ArrayList<Command> commands) {
        this.commands = commands;
    }

```
###### /java/linenux/command/InvalidCommand.java
``` java
    @Override
    public CommandResult execute(String userInput) {
        String userCommand = extractCommand(userInput);
        Command closestCommand = null;
        int bestScore = Integer.MAX_VALUE;

        for (Command command: this.commands) {
            int similarity = StringsSimilarity.compute(userCommand, command.getTriggerWord());
            if (similarity < bestScore) {
                closestCommand = command;
                bestScore = similarity;
            }
        }

        if (closestCommand == null) {
            return this.makeResponse();
        } else {
            return this.makeResponseWithSuggestion(closestCommand.getTriggerWord());
        }
    }

```
###### /java/linenux/command/InvalidCommand.java
``` java
    private String extractCommand(String userInput) {
        String[] parts = userInput.split(" ");

        if (parts.length > 0) {
            return parts[0];
        } else {
            return "";
        }
    }

    private CommandResult makeResponse() {
        return () -> "Invalid command.";
    }

    private CommandResult makeResponseWithSuggestion(String suggestion) {
        return () -> "Invalid command. Did you mean " + suggestion + "?";
    }
}
```
###### /java/linenux/command/ListCommand.java
``` java
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

```
###### /java/linenux/command/parser/AddArgumentParser.java
``` java
    public Either<Task, CommandResult> parse(String argument) {
        this.parseResult = this.genericParser.parse(argument);

        return Either.<Task, CommandResult>left(new Task(""))
                .bind(this::extractTaskName)
                .bind(this::extractStartTime)
                .bind(this::extractEndTime)
                .bind(this::extractTags)
                .bind(this::ensureValidDateCombination)
                .bind(this::ensureValidEventTimes);
    }

    private Either<Task, CommandResult> extractTaskName(Task task) {
        if (this.parseResult.getKeywords().length() > 0) {
            Task output = task.setTaskName(this.parseResult.getKeywords());
            return Either.left(output);
        } else {
            return Either.right(makeInvalidArgumentResult());
        }
    }

    private Either<Task, CommandResult> extractStartTime(Task task) {
        if (this.parseResult.getArguments("st").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("st").get(0))
                    .bind(t -> Either.left(task.setStartTime(t)));
        } else {
            return Either.left(task);
        }
    }

    private Either<Task, CommandResult> extractEndTime(Task task) {
        if (this.parseResult.getArguments("et").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("et").get(0))
                    .bind(t -> Either.left(task.setEndTime(t)));
        } else {
            return Either.left(task);
        }
    }

    private Either<Task, CommandResult> extractTags(Task task) {
        ArrayList<String> tags = ArrayListUtil.unique(this.parseResult.getArguments("#"));

        if (tags.indexOf("") == -1) {
            return Either.left(task.setTags(tags));
        } else {
            return Either.right(makeInvalidArgumentResult());
        }
    }

    private Either<Task, CommandResult> ensureValidDateCombination(Task task) {
        if (task.getStartTime() == null || task.getEndTime() != null) {
            return Either.left(task);
        } else {
            return Either.right(makeStartTimeWithoutEndTimeResult());
        }
    }

    private Either<Task, CommandResult> ensureValidEventTimes(Task task) {
        if (task.getStartTime() == null || task.getEndTime() == null || task.getEndTime().compareTo(task.getStartTime()) >= 0) {
            return Either.left(task);
        } else {
            return Either.right(makeEndTimeBeforeStartTimeResult());
        }
    }

    private Either<LocalDateTime, CommandResult> parseDateTime(String string) {
        if (this.timeParserManager.canParse(string)) {
            return Either.left(this.timeParserManager.delegateTimeParser(string));
        } else {
            return Either.right(makeInvalidDateTimeResult(string));
        }
    }

```
###### /java/linenux/command/parser/AddArgumentParser.java
``` java
    private CommandResult makeInvalidDateTimeResult(String dateTime) {
        return () -> "Cannot parse \"" + dateTime + "\".";
    }

    private CommandResult makeStartTimeWithoutEndTimeResult() {
        return () -> "Cannot create task with start time but without end time.";
    }

    private CommandResult makeEndTimeBeforeStartTimeResult() {
        return () -> "End time cannot come before start time.";
    }
}
```
###### /java/linenux/command/parser/EditArgumentParser.java
``` java
    public Either<Task, CommandResult> parse(Task original, String argument) {
        this.parseResult = this.genericParser.parse(argument);

        return Either.<Task, CommandResult>left(original)
                .bind(this::ensureNeedsEdit)
                .bind(this::updateTaskName)
                .bind(this::updateStartTime)
                .bind(this::updateEndTime)
                .bind(this::updateTags)
                .bind(this::ensureValidDateCombination)
                .bind(this::ensureValidEventTimes);
    }

    private Either<Task, CommandResult> updateTaskName(Task task) {
        if (this.parseResult.getArguments("n").size() > 0) {
            String taskName = this.parseResult.getArguments("n").get(0);

            if (taskName.length() > 0) {
                return Either.left(task.setTaskName(taskName));
            } else {
                return Either.right(makeInvalidArgumentResult());
            }
        } else {
            return Either.left(task);
        }
    }

    private Either<Task, CommandResult> updateStartTime(Task task) {
        if (this.parseResult.getArguments("st").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("st").get(0))
                    .bind(t -> Either.left(task.setStartTime(t)));
        } else {
            return Either.left(task);
        }
    }

    private Either<Task, CommandResult> updateEndTime(Task task) {
        if (this.parseResult.getArguments("et").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("et").get(0))
                    .bind(t -> Either.left(task.setEndTime(t)));
        } else {
            return Either.left(task);
        }
    }

    private Either<Task, CommandResult> updateTags(Task task) {
        ArrayList<String> tags = ArrayListUtil.unique(this.parseResult.getArguments("#"));

        if (tags.size() == 0) {
            return Either.left(task);
        } else if (tags.indexOf("") != -1) {
            return Either.right(makeInvalidArgumentResult());
        } else if (tags.indexOf("-") != -1) {
            return Either.left(task.setTags(new ArrayList<>()));
        } else {
            return Either.left(task.setTags(tags));
        }
    }

    private Either<Task, CommandResult> ensureNeedsEdit(Task task) {
        boolean needsEdit = new ArrayListUtil.ChainableArrayListUtil<>(new String[]{"n", "st", "et", "#"})
                .map(this.parseResult::getArguments)
                .map(ArrayList::size)
                .map(s -> s > 0)
                .foldr(Boolean::logicalOr, false);

        if (needsEdit) {
            return Either.left(task);
        } else {
            return Either.right(makeNoArgumentsResult());
        }
    }

    private Either<Task, CommandResult> ensureValidDateCombination(Task task) {
        if (task.getStartTime() == null || task.getEndTime() != null) {
            return Either.left(task);
        } else {
            return Either.right(makeStartTimeWithoutEndTimeResult());
        }
    }

    private Either<Task, CommandResult> ensureValidEventTimes(Task task) {
        if (task.getStartTime() == null || task.getEndTime() == null || task.getEndTime().compareTo(task.getStartTime()) >= 0) {
            return Either.left(task);
        } else {
            return Either.right(makeEndTimeBeforeStartTimeResult());
        }
    }

    private Either<LocalDateTime, CommandResult> parseDateTime(String string) {
        if (this.timeParserManager.canParse(string)) {
            return Either.left(this.timeParserManager.delegateTimeParser(string));
        } else if (string.matches("\\s*-\\s*")) {
            return Either.left(null);
        } else {
            return Either.right(makeInvalidDateTimeResult(string));
        }
    }

```
###### /java/linenux/command/parser/EditReminderArgumentParser.java
``` java
    public Either<Reminder, CommandResult> parse(Reminder original, String argument) {
        this.parseResult = this.genericParser.parse(argument);

        return Either.<Reminder, CommandResult>left(original)
                .bind(this::ensureNeedsEdit)
                .bind(this::extractTime)
                .bind(this::extractNote);
    }

    private Either<Reminder, CommandResult> extractTime(Reminder original) {
        if (this.parseResult.getArguments("t").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("t").get(0))
                    .bind(t -> Either.left(original.setTimeOfReminder(t)));
        } else {
            return Either.left(original);
        }
    }

    private Either<Reminder, CommandResult> extractNote(Reminder original) {
        if (this.parseResult.getArguments("n").size() > 0) {
            return Either.left(original.setNote(this.parseResult.getArguments("n").get(0)));
        } else {
            return Either.left(original);
        }
    }

    private Either<Reminder, CommandResult> ensureNeedsEdit(Reminder reminder) {
        boolean needsEdit = new ArrayListUtil.ChainableArrayListUtil<>(new String[] {"n", "t"})
                .map(this.parseResult::getArguments)
                .map(ArrayList::size)
                .map(s -> s > 0)
                .foldr(Boolean::logicalOr, false);

        if (needsEdit) {
            return Either.left(reminder);
        } else {
            return Either.right(makeNoArgumentsResult());
        }
    }

```
###### /java/linenux/command/parser/FreeTimeArgumentParser.java
``` java
public class FreeTimeArgumentParser {
    private TimeParserManager timeParserManager;
    private GenericParser genericParser;
    private GenericParser.GenericParserResult parseResult;
    private Clock clock;

    public FreeTimeArgumentParser(TimeParserManager timeParserManager, Clock clock) {
        this.timeParserManager = timeParserManager;
        this.genericParser = new GenericParser();
        this.clock = clock;
    }

    public Either<TimeInterval, CommandResult> parse(String argument) {
        this.parseResult = this.genericParser.parse(argument);

        return Either.<TimeInterval, CommandResult>left(new TimeInterval())
                .bind(this::parseStartTime)
                .bind(this::parseEndTime)
                .bind(this::ensureIntervalValidity);
    }

    private Either<TimeInterval, CommandResult> parseStartTime(TimeInterval interval) {
        if (this.parseResult.getArguments("st").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("st").get(0))
                    .bind(t -> Either.left(interval.setFrom(t)));
        } else {
            return Either.left(interval.setFrom(LocalDateTime.now(this.clock)));
        }
    }

    private Either<TimeInterval, CommandResult> parseEndTime(TimeInterval interval) {
        if (this.parseResult.getArguments("et").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("et").get(0))
                    .bind(t -> Either.left(interval.setTo(t)));
        } else {
            return Either.right(makeEndTimeNotSpecified());
        }
    }

    private Either<TimeInterval, CommandResult> ensureIntervalValidity(TimeInterval interval) {
        if (interval.getFrom().compareTo(interval.getTo()) <= 0) {
            return Either.left(interval);
        } else {
            return Either.right(makeEndTimeBeforeStartTimeResult());
        }
    }

    private Either<LocalDateTime, CommandResult> parseDateTime(String string) {
        if (this.timeParserManager.canParse(string)) {
            return Either.left(this.timeParserManager.delegateTimeParser(string));
        } else {
            return Either.right(makeCannotParseTimeResult(string));
        }
    }

    private CommandResult makeCannotParseTimeResult(String string) {
        return () -> "Cannot parse \"" + string + "\"." ;
    }

    private CommandResult makeEndTimeBeforeStartTimeResult() {
        return () -> "End time must be after start time.";
    }

    private CommandResult makeEndTimeNotSpecified() {
        return () -> "End time must be specified.";
    }
}
```
###### /java/linenux/command/parser/GenericParser.java
``` java
public class GenericParser {
    private static final Pattern FIRST_FLAG_PATTERN = Pattern.compile("(^|\\s+)\\S+/");
    private static final Pattern FLAG_PATTERN = Pattern.compile("\\S+/");
    private static final Pattern NEXT_FLAG_PATTERN = Pattern.compile("\\s+\\S+/");

    public GenericParserResult parse(String input) {
        GenericParserResult output = new GenericParserResult();

        String keywords = this.extractKeywords(input);
        output.setKeywords(keywords.trim());

        this.extractFlags(input, keywords.length(), output);

        return output;
    }

    private String extractKeywords(String input) {
        Matcher matcher = FIRST_FLAG_PATTERN.matcher(input);

        // Find the first flag. If there is no flag, the end index is at the end of string.
        int earliestIndex = input.length();
        if (matcher.find()) {
            earliestIndex = matcher.start();
        }

        return input.substring(0, earliestIndex);
    }

    private void extractFlags(String input, int index, GenericParserResult result) {
        for (int i = index; i < input.length(); ) {
            // Find where the next flag starts. This is necessary as i might be pointing to a
            // space.
            int startingIndex = input.length();
            Matcher matcher = FLAG_PATTERN.matcher(input);
            if (matcher.find(i)) {
                startingIndex = matcher.start();
            }

            if (startingIndex >= input.length()) {
                return;
            }

            int endingIndex = input.length();
            matcher = NEXT_FLAG_PATTERN.matcher(input);
            if (matcher.find(startingIndex + 1)) {
                endingIndex = matcher.start();
            }

            String chunk = input.substring(startingIndex, endingIndex);
            String[] chunks = chunk.split("/", 2);
            result.addArgument(chunks[0], chunks[1].trim());

            i = endingIndex + 1;
        }
    }

    public static class GenericParserResult {
        // Perhaps we can use Optionals to signal the presence of these values.
        private String keywords;
        private HashMap<String, ArrayList<String>> arguments = new HashMap<>();

        public String getKeywords() {
            return this.keywords;
        }

        public void setKeywords(String keywords) {
            this.keywords = keywords;
        }

        public ArrayList<String> getArguments(String flag) {
            return this.arguments.getOrDefault(flag, new ArrayList<>());
        }

        public void addArgument(String flag, String value) {
            if (!this.arguments.containsKey(flag)) {
                this.arguments.put(flag, new ArrayList<>());
            }

            this.arguments.get(flag).add(value);
        }
    }
}
```
###### /java/linenux/command/parser/ReminderArgumentParser.java
``` java
    public Either<Reminder, CommandResult> parse(String argument) {
        this.parseResult = this.genericParser.parse(argument);

        return Either.<Reminder, CommandResult>left(new Reminder())
                .bind(this::extractTime)
                .bind(this::extractNote);
    }

    private Either<Reminder, CommandResult> extractTime(Reminder reminder) {
        if (this.parseResult.getArguments("t").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("t").get(0))
                    .bind(t -> Either.left(reminder.setTimeOfReminder(t)));
        } else {
            return Either.right(makeWithoutDateResult());
        }
    }

    private Either<Reminder, CommandResult> extractNote(Reminder reminder) {
        if (this.parseResult.getArguments("n").size() > 0) {
            return Either.left(reminder.setNote(this.parseResult.getArguments("n").get(0)));
        } else {
            return Either.right(makeWithoutNoteResult());
        }
    }

    private Either<LocalDateTime, CommandResult> parseDateTime(String string) {
        if (this.timeParserManager.canParse(string)) {
            return Either.left(this.timeParserManager.delegateTimeParser(string));
        } else {
            return Either.right(makeInvalidDateTimeResult(string));
        }
    }

    private CommandResult makeInvalidDateTimeResult(String dateTime) {
        return () -> "Cannot parse \"" + dateTime + "\".";
    }

    private CommandResult makeWithoutDateResult() {
        return () -> "Cannot create reminder without date.";
    }

    private CommandResult makeWithoutNoteResult() {
        return () -> "Cannot create reminder without note.";
    }
}
```
###### /java/linenux/command/result/PromptResults.java
``` java
public class PromptResults {
    public static CommandResult makePromptIndexResult(ArrayList<Task> tasks) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("Which one? (1-");
            builder.append(tasks.size());
            builder.append(")\n");

            builder.append(TasksListUtil.display(tasks));

            return builder.toString();
        };
    }

    public static CommandResult makePromptReminderIndexResult(ArrayList<ReminderSearchResult> results) {
        return () -> {
            int totalResults = ReminderSearchResult.totalReminders(results);

            StringBuilder builder = new StringBuilder();
            builder.append("Which one? (1-");
            builder.append(totalResults);
            builder.append(")\n");
            builder.append(RemindersListUtil.displaySearchResults(results));

            return builder.toString().trim();
        };
    }

    public static CommandResult makeInvalidIndexResult(ArrayList<Task> tasks) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("That's not a valid index. Enter a number between 1 and ");
            builder.append(tasks.size());
            builder.append(":\n");
            builder.append(TasksListUtil.display(tasks));
            return builder.toString();
        };
    }

    public static CommandResult makeInvalidReminderIndexResult(ArrayList<ReminderSearchResult> results) {
        return () -> {
            int totalReminders = ReminderSearchResult.totalReminders(results);

            StringBuilder builder = new StringBuilder();
            builder.append("That's not a valid index. Enter a number between 1 and ");
            builder.append(totalReminders);
            builder.append(":\n");
            builder.append(RemindersListUtil.displaySearchResults(results));

            return builder.toString().trim();
        };
    }
}
```
###### /java/linenux/command/result/SearchResults.java
``` java
    public static CommandResult makeNotFoundResult(String keywords) {
        return () -> "Cannot find task names with \"" + keywords + "\".";
    }

```
###### /java/linenux/command/TodayCommand.java
``` java
public class TodayCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "today";
    private static final String DESCRIPTION = "Lists tasks and reminders for today.";
    private static final String COMMAND_FORMAT = "today";

    private Schedule schedule;
    private Clock clock;
    private ListCommand listCommand;

    public TodayCommand(Schedule schedule) {
        this(schedule, Clock.systemDefaultZone());
    }

    public TodayCommand(Schedule schedule, Clock clock) {
        this.schedule = schedule;
        this.clock = clock;
        this.listCommand = new ListCommand(this.schedule);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h:mma");
        LocalDateTime now = LocalDateTime.now(this.clock);
        LocalDateTime startOfToday = now.withHour(0).withMinute(0).withSecond(0);
        LocalDateTime endOfToday = now.withHour(23).withMinute(59).withSecond(59);

        return this.listCommand.execute("list st/" + startOfToday.format(formatter) + " et/" + endOfToday.format(formatter));
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }
}
```
###### /java/linenux/command/TomorrowCommand.java
``` java
public class TomorrowCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "tomorrow";
    private static final String DESCRIPTION = "Lists tasks and reminders for tomorrow.";
    private static final String COMMAND_FORMAT = "tomorrow";

    private Schedule schedule;
    private Clock clock;
    private ListCommand listCommand;

    public TomorrowCommand(Schedule schedule) {
        this(schedule, Clock.systemDefaultZone());
    }

    public TomorrowCommand(Schedule schedule, Clock clock) {
        this.schedule = schedule;
        this.clock = clock;
        this.listCommand = new ListCommand(this.schedule);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h:mma");
        LocalDateTime now = LocalDateTime.now(this.clock);
        LocalDateTime startOfTomorrow = now.withHour(0).withMinute(0).withSecond(0).plusDays(1);
        LocalDateTime endOfTomorrow = now.withHour(23).withMinute(59).withSecond(59).plusDays(1);

        return this.listCommand.execute("list st/" + startOfTomorrow.format(formatter) + " et/" + endOfTomorrow.format(formatter));
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }
}
```
###### /java/linenux/command/UnaliasCommand.java
``` java
public class UnaliasCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "unalias";
    private static final String DESCRIPTION = "Removes an alias.";
    private static final String COMMAND_FORMAT = "unalias ALIAS";

    private ArrayList<Command> commands;

    public UnaliasCommand(ArrayList<Command> commands) {
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
        this.commands = commands;
    }

    @Override
    public CommandResult execute(String userInput) {
        String argument = extractArgument(userInput);

        for (Command command: this.commands) {
            if (command.getTriggerWord().equals(argument)) {
                return makeUnaliasDefaultResult(argument);
            } else if (command.respondTo(argument)) {
                command.removeAlias(argument);
                return makeUnaliasResult(argument);
            }
        }

        return makeInvalidAliasResult(argument);
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private String extractArgument(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("keywords") != null) {
            return matcher.group("keywords");
        } else {
            return "";
        }
    }

    private CommandResult makeUnaliasResult(String alias) {
        return () -> "\"" + alias + "\" is removed as an alias.";
    }

    private CommandResult makeInvalidAliasResult(String alias) {
        return () -> "\"" + alias + "\" is not an alias.";
    }

    private CommandResult makeUnaliasDefaultResult(String alias) {
        return () -> "\"" + alias + "\" cannot be removed as an alias.";
    }
}
```
###### /java/linenux/control/CommandManager.java
``` java
    public CommandManager(Schedule schedule) {
        this.schedule = schedule;
        commandList = new ArrayList<>();
        initializeCommands();
    }

    /**
     * Adds all supported commands to the commandList.
     */
    private void initializeCommands() {
        commandList.add(new AddCommand(this.schedule));
        commandList.add(new EditReminderCommand(this.schedule));
        commandList.add(new EditCommand(this.schedule));
        commandList.add(new DoneCommand(this.schedule));
        commandList.add(new RemindCommand(this.schedule));
        commandList.add(new DeleteCommand(this.schedule));
        commandList.add(new ClearCommand(this.schedule));

        commandList.add(new ListCommand(this.schedule));
        commandList.add(new ViewCommand(this.schedule));
        commandList.add(new TodayCommand(this.schedule));
        commandList.add(new TomorrowCommand(this.schedule));

        commandList.add(new UndoCommand(this.schedule));
        commandList.add(new FreeTimeCommand(this.schedule));
        commandList.add(new HelpCommand(this.commandList));
        commandList.add(new AliasCommand(this.commandList));
        commandList.add(new UnaliasCommand(this.commandList));
        commandList.add(new ExitCommand());

        this.catchAllCommand = new InvalidCommand(this.commandList);
    }

```
###### /java/linenux/control/ControlUnit.java
``` java
    public Schedule getSchedule() {
        return this.schedule;
    }

    public ObjectProperty<CommandResult> getLastCommandResultProperty() {
        return this.lastCommandResult;
    }
}
```
###### /java/linenux/control/TimeParserManager.java
``` java
    /**
     * Check if the manager can parse some string
     * @param userInput The string to check
     * @return {@code true} if and only if at least one of the parsers can parse {@code userInput}
     */
    public boolean canParse(String userInput) {
        for (TimeParser parser: parserList) {
            if (parser.respondTo(userInput)) {
                return true;
            }
        }

        return false;
    }

```
###### /java/linenux/Main.java
``` java
    private void setupMainWindow(Stage primaryStage) {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(Main.class.getResource("/view/MainWindow.fxml"));
            primaryStage.setTitle(APP_NAME);
            primaryStage.getIcons().add(new Image("/images/terminal.png"));

            loader.setController(new MainWindowController(this.config));
            Scene scene = new Scene(loader.load(), INITIAL_CONSOLE_WIDTH, INITIAL_CONSOLE_HEIGHT);
            primaryStage.setScene(scene);
            primaryStage.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
###### /java/linenux/model/Reminder.java
``` java
    public Reminder() {
        this(null, null);
    }

```
###### /java/linenux/model/Reminder.java
``` java
    public Reminder(Reminder other) {
        this.note = other.note;
        this.timeOfReminder = other.timeOfReminder;
    }

```
###### /java/linenux/model/Reminder.java
``` java
    public Reminder setNote(String newNote) {
        Reminder output = new Reminder(this);
        output.note = newNote;
        return output;
    }

    public Reminder setTimeOfReminder(LocalDateTime newTimeOfReminder) {
        Reminder output = new Reminder(this);
        output.timeOfReminder = newTimeOfReminder;
        return output;
    }
}
```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Constructs an empty schedule
     */
    public Schedule() {
        this.states.add(new State());
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Replace {@code originalTask} with {@code newTask}.
     * @param originalTask The original task.
     * @param newTask The new ask.
     */
    public void updateTask(Task originalTask, Task newTask) {
        addState(getMostRecentState().updateTask(originalTask, newTask));
    }

```
###### /java/linenux/model/Schedule.java
``` java
    public ArrayList<Task> search(String keywords) {
        return search(keywords.split("\\s+"));
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Remove the last state if there are more than one.
     *
     * @return {@code true} if and only if a state is removed.
     */
    public boolean popState() {
        if (states.size() > 1) {
            states.remove(states.size() - 1);
            return true;
        }
        return false;
    }

```
###### /java/linenux/model/Schedule.java
``` java
    /**
     * Returns the most recent state of schedule
     */
    private State getMostRecentState() {
        return states.get(states.size() - 1);
    }

    /**
     * Adds a new state to states.
     * @param state
     */
    private void addState(State state) {
        while (states.size() + 1 > MAX_STATES && states.size() > 1) {
            states.remove(0);
        }
        states.add(state);
    }
}
```
###### /java/linenux/model/Task.java
``` java
    /**
     * Copy constructor.
     * @param other The other {@code Task} to copy from.
     */
    public Task(Task other) {
        this.taskName = other.taskName;
        this.isDone = other.isDone;
        this.startTime = other.startTime;
        this.endTime = other.endTime;
        this.tags = new ArrayList<>(other.tags);
        this.reminders = new ArrayList<>(other.reminders);
    }

    @Override
    public String toString() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd h:mma");

        if (this.isDeadline()) {
            return taskName + " (Due " + this.endTime.format(formatter) + ")" + tagsToString();
        } else if (this.isEvent()) {
            return taskName + " (" + this.startTime.format(formatter) + " - " + this.endTime.format(formatter) + ")"
                    + tagsToString();
        } else {
            return taskName + tagsToString();
        }
    }

```
###### /java/linenux/model/Task.java
``` java
    public boolean isTodo() {
        return startTime == null && endTime == null;
    }

    public boolean isDeadline() {
        return startTime == null && endTime != null;
    }

    public boolean isEvent() {
        return startTime != null && endTime != null;
    }

```
###### /java/linenux/model/Task.java
``` java
    public Task setTaskName(String taskName) {
        Task output = new Task(this);
        output.taskName = taskName;
        return output;
    }

    public Task setStartTime(LocalDateTime startTime) {
        Task output = new Task(this);
        output.startTime = startTime;
        return output;
    }

    public Task setEndTime(LocalDateTime endTime) {
        Task output = new Task(this);
        output.endTime = endTime;
        return output;
    }

    public Task markAsDone() {
        Task output = new Task(this);
        output.isDone = true;
        return output;
    }

```
###### /java/linenux/model/Task.java
``` java
    public Task addReminder(Reminder reminder) {
        Task output = new Task(this);
        output.reminders.add(reminder);
        return output;
    }

```
###### /java/linenux/model/Task.java
``` java
    public Task setTags(ArrayList<String> tags) {
        Task output = new Task(this);
        output.tags = tags;
        return output;
    }

```
###### /java/linenux/time/parser/ISODateWithTimeParser.java
``` java
/**
 * Parse date and time in the form of "2016-10-01 2:00PM"
 */
public class ISODateWithTimeParser implements TimeParser {
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h:mma");

    @Override
    public boolean respondTo(String input) {
        try {
            parse(input);
            return true;
        } catch (DateTimeParseException e) {
            return false;
        }
    }

    @Override
    public LocalDateTime parse(String input) {
        return LocalDateTime.parse(input.toUpperCase(), formatter);
    }
}
```
###### /java/linenux/util/ArrayListUtil.java
``` java
/**
 * A set of utility functions for {@code ArrayList}.
 */
public class ArrayListUtil {
    /**
     * A layer of abstraction on top of ArrayListUtil to allow chainable calls.
     * For example, instead of writing
     *
     * <pre><code>
     * String[] numbers = {"1", "2", "3"};
     * ArrayList&lt;Integer&gt; listOfNumbers = ArrayListUtil.map(Integer.parseInt, ArrayListUtil.fromArray(numbers));
     * </code></pre>
     *
     * We can do
     *
     * <pre><code>
     * String[] numbers = {"1", "2", "3"};
     * ArrayList&lt;Integer&gt; listOfNumbers = new ChainableArrayListUtil&lt;String&gt;(numbers)
     *      .map(Integer.parseInt)
     *      .value();
     * </code></pre>
     *
     * Inspired by Lodash.
     *
     * @param <T> Any type that ArrayList allows.
     */
    public static class ChainableArrayListUtil<T> {
        private ArrayList<T> list;

        /**
         * Make a {@code ChainableArrayListUtil} out of an array.
         * @param arr The array to wrap.
         */
        public ChainableArrayListUtil(T[] arr) {
            this(ArrayListUtil.fromArray(arr));
        }

        /**
         * Make a {@code ChainableArrayListUtil} out of a {@code List}.
         * @param list The {@code list} to wrap.
         */
        public ChainableArrayListUtil(List<T> list) {
            this.list = new ArrayList<T>(list);
        }

        /**
         * @param fn The mapper function.
         * @param <R> Any type that ArrayList accepts.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public <R> ChainableArrayListUtil<R> map(Function<T, R> fn) {
            return new ChainableArrayListUtil<R>(ArrayListUtil.map(fn, this.list));
        }

        /**
         * @param fn The filter predicate.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public ChainableArrayListUtil<T> filter(Predicate<T> fn) {
            return new ChainableArrayListUtil<T>(ArrayListUtil.filter(fn, this.list));
        }

        /**
         * Sort the {@code ArrayList} by the {@code comparator}.
         * @param comparator The comparator used to determine the weak ordering of the elements.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public ChainableArrayListUtil<T> sort(Comparator<T> comparator) {
            ArrayList<T> copy = new ArrayList<>(this.list);
            Collections.sort(copy, comparator);
            return new ChainableArrayListUtil<>(copy);
        }

        /**
         * Sort the {@code ArrayList} according to the value given by the specified function.
         * @param fn A pure function taking in elements of the array list and returning some {@code Comparable}.
         * @param <R> Any type implementing {@code Comparable}.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public <R extends Comparable<R>> ChainableArrayListUtil<T> sortBy(Function<T, R> fn) {
            return this.sort((a, b) -> fn.apply(a).compareTo(fn.apply(b)));
        }

        /**
         * Performs right fold on the current list. Notice that this method breaks the chain as it does not return
         * another instance of {@code ChainableArrayListUtil}.
         * @param reducer The reducer function.
         * @param initialValue The initial value fed into {@code reducer}.
         * @param <R> The output type.
         * @return The fold result.
         */
        public <R> R foldr(BiFunction<T, R, R> reducer, R initialValue) {
            return ArrayListUtil.foldr(reducer, initialValue, this.list);
        }

        /**
         * A special case of {@code foldr}, that is, when the output is also an {@code ArrayList}. We can wrap the
         * output in a {@code ChainableArrayListUtil}.
         * @param reducer The reducer function.
         * @param initialList The initial value fed into {@code reducer}. In this case, it must be an {@code ArrayList}.
         * @param <R> The type of the output list.
         * @return A {@code ChainableArrayListUtil} wrapping the fold result.
         */
        public <R> ChainableArrayListUtil<R> foldr(BiFunction<T, ArrayList<R>, ArrayList<R>> reducer, ArrayList<R> initialList) {
            ArrayList<R> result = ArrayListUtil.foldr(reducer, initialList, this.list);
            return new ChainableArrayListUtil<>(result);
        }

        /**
         * Reverse the list.
         * @return The reversed list wrapped in {@ChainableArrayListUtil}.
         */
        public ChainableArrayListUtil<T> reverse() {
            ArrayList<T> reversed = ArrayListUtil.reverse(this.list);
            return new ChainableArrayListUtil<>(reversed);
        }

        /**
         * Returns the underlying {@code ArrayList}.
         * @return The underlying {@code ArrayList}.
         */
        public ArrayList<T> value() {
            return this.list;
        }
    }

    /**
     * Transform the input {@code ArrayList} using {@code fn}.
     * @param fn The stateless mapper function.
     * @param list The input {@code ArrayList}.
     * @param <T> The type of the input {@code ArrayList}.
     * @param <R> The type of the output {@code ArrayList}.
     * @return The transformed {@code ArrayList}.
     */
    public static <T, R> ArrayList<R> map(Function<T, R> fn, ArrayList<T> list) {
        return list.stream().map(fn).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    }

    /**
     * Filter the input {@code ArrayList} based on the output of {@code fn}.
     * @param fn The predicate function.
     * @param list The input {@code ArrayList}.
     * @param <T> The type of the {@code ArrayList}.
     * @return The filtered {@code ArrayList}.
     */
    public static <T> ArrayList<T> filter(Predicate<T> fn, ArrayList<T> list) {
        return list.stream().filter(fn).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    }

    /**
     * Performs right fold on {@code list}.
     * @param reducer The reducer function.
     * @param initialValue The initial value fed to {@code reducer}. If {@code list} is empty, this value is returned.
     * @param list The {@code ArrayList} to fold.
     * @param <T> The type of the {@code ArrayList}.
     * @param <R> The output type.
     * @return The result of the fold.
     */
    public static <T, R> R foldr(BiFunction<T, R, R> reducer, R initialValue, ArrayList<T> list) {
        R output = initialValue;

        for (int i = list.size() - 1; i >= 0; i--) {
            output = reducer.apply(list.get(i), output);
        }

        return output;
    }

    /**
     * Reverse a list.
     * @param list The {@code ArrayList} to reverse.
     * @param <T> The type of the {@code ArrayList}.
     * @return The reversed list.
     */
    public static <T> ArrayList<T> reverse(ArrayList<T> list) {
        return foldr((x, xs) -> {
            xs.add(x);
            return xs;
        }, new ArrayList<T>(), list);
    }

    /**
     * Returns a new list by removing repeated elements in {@code list}.
     * @param list The input list.
     * @param <T> The type of the list.
     * @return The list with repeated elements removed.
     */
    public static <T> ArrayList<T> unique(ArrayList<T> list) {
        HashSet<T> set = new HashSet<>();
        ArrayList<T> output = new ArrayList<>();

        for (T val: list) {
            if (!set.contains(val)) {
                set.add(val);
                output.add(val);
            }
        }

        return output;
    }

    /**
     * Make an {@code ArrayList} out of an array.
     * @param arr The input array.
     * @param <T> The type of the array.
     * @return An {@code ArrayList} containing the same elements as {@code arr}.
     */
    public static <T> ArrayList<T> fromArray(T[] arr) {
        return new ArrayList<T>(Arrays.asList(arr));
    }

    /**
     * Make an {@code ArrayList} with only one element.
     * @param elem The only element in the array list.
     * @param <T> The type of the element.
     * @return An {@code ArrayList} containing only {@code elem}.
     */
    public static <T> ArrayList<T> fromSingleton(T elem) {
        ArrayList<T> output = new ArrayList<>();
        output.add(elem);
        return output;
    }
}
```
###### /java/linenux/util/Either.java
``` java
/**
 * A data structure inspired by the FP world. Can be used to represent an operation that can have two possible
 * outcomes. For example, when parsing something, the output is either the result, or an error.
 *
 * Instances of {@code Either} are immutable. The left and right values are wrapped by {@code Optional}.
 * Exactly one of them must be empty and the other present. To enforce this restriction, {@code Either} must
 * be built using the static factory methods.
 */
public class Either<L, R> {
    /**
     * A custom implementation of the {@code Optional} class. The default Java implementation does not
     * allow {@code null}, which is a good thing, but is not suitable in this context since an
     * {@code Either} should be able to store {@code null} values too.
     * @param <T> Any type.
     */
    private static class NullableOptional<T> {
        public static <T> NullableOptional<T> empty() {
            NullableOptional<T> output = new NullableOptional<>();
            output.isPresent = false;
            return output;
        }

        public static <T> NullableOptional<T> of(T value) {
            NullableOptional<T> output = new NullableOptional<>();
            output.isPresent = true;
            output.value = value;
            return output;
        }

        private boolean isPresent;
        private T value;

        public boolean isPresent() {
            return this.isPresent;
        }

        public T get() {
            if (!this.isPresent()) {
                throw new NoSuchElementException();
            }

            return this.value;
        }
    }

    private NullableOptional<L> left;
    private NullableOptional<R> right;

    /**
     * Make an {@code Either} with a left value.
     * @param <L> The left type.
     * @param <R> The right type.
     * @return An instance of {@code Either} with a left value.
     */
    public static <L, R> Either<L, R> left(L left) {
        return new Either<>(NullableOptional.of(left), NullableOptional.empty());
    }

    /**
     * Make an {@code Either} with a right value.
     * @param right The right value.
     * @param <L> The left type.
     * @param <R> The right type.
     * @return An instance of {@code Either} with a right value.
     */
    public static <L, R> Either<L, R> right(R right) {
        return new Either<>(NullableOptional.empty(), NullableOptional.of(right));
    }

    /**
     * Construct an {@code Either}. Exactly one of {@code left} and {@code right} must be empty.
     * @param left The left optional.
     * @param right The right optional.
     */
    private Either(NullableOptional<L> left, NullableOptional<R> right) {
        this.left = left;
        this.right = right;
    }

    /**
     * Returns true if and only if the left value is not empty.
     * @return True if left is not empty.
     */
    public boolean isLeft() {
        return this.left.isPresent();
    }

    /**
     * Return true if and only if the right value is not empty.
     * @return True if right is not empty.
     */
    public boolean isRight() {
        return this.right.isPresent();
    }

    /**
     * Return the left value.
     * @return The left value. If the left value is empty, {@code NoSuchElementException} will be thrown.
     */
    public L getLeft() throws NoSuchElementException {
        return this.left.get();
    }

    /**
     * Return the right value.
     * @return The right value. If the right value is empty, {@code NoSuchElementException} will be thrown.
     */
    public R getRight() {
        return this.right.get();
    }

    /**
     * Execute a function with the left value skip otherwise.
     * @param function The function to execute.
     * @param <T> The normal return type of {@code function}.
     * @return An {@code Either}.
     */
    public <T> Either<T, R> bind(Function<L, Either<T, R>> function) {
        if (this.isRight()) {
            return Either.right(this.getRight());
        } else {
            return function.apply(this.getLeft());
        }
    }
}
```
###### /java/linenux/util/LocalDateTimeUtil.java
``` java
public class LocalDateTimeUtil {
    /**
     * Return the earlier of two instances of {@code LocalDateTime}.
     * @param a The first {@code LocalDateTime}.
     * @param b The second {@code LocalDateTime}.
     * @return The earlier of {@code a} and {@code b}.
     */
    public static LocalDateTime min(LocalDateTime a, LocalDateTime b) {
        return a.compareTo(b) < 0 ? a : b;
    }

    /**
     * Returns the later of two instances of {@code LocalDateTime}.
     * @param a The first {@code LocalDateTime}.
     * @param b The second {@code LocalDateTime}.
     * @return The later of {@code a} and {@code b}.
     */
    public static LocalDateTime max(LocalDateTime a, LocalDateTime b) {
        return a.compareTo(b) > 0 ? a : b;
    }
}
```
###### /java/linenux/util/StringsSimilarity.java
``` java
/**
 * Computes the similarity between two strings.
 */
public class StringsSimilarity {
    /**
     * Computes the similarity between two strings.
     * @param a The first string.
     * @param b The second string.
     * @return The Levenshtein distance between {@code a} and {@code b}.
     */
    public static int compute(String a, String b) {
        int l1 = a.length();
        int l2 = b.length();
        int[][] dp = new int[l1+1][l2+1];

        for (int i = 1; i <= l1; i++) {
            dp[i][0] = i;
        }

        for (int i = 1; i <= l2; i++) {
            dp[0][i] = i;
        }

        for (int i = 1; i <= l1; i++) {
            for (int j = 1; j <= l2; j++) {
                int add = dp[i-1][j] + 1;
                int delete = dp[i][j-1] + 1;
                int swap = dp[i-1][j-1] + (a.charAt(i-1) == b.charAt(j-1) ? 0 : 2);
                dp[i][j] = Math.min(Math.min(add, delete), swap);
            }
        }

        return dp[l1][l2];
    }
}
```
###### /java/linenux/util/TasksListUtil.java
``` java
public class TasksListUtil {
    /**
     * Display the list of tasks as a string.
     *
     * @param tasks
     *            The list of tasks to display.
     * @return A string representing the tasks.
     */
    public static String display(ArrayList<Task> tasks) {
        StringBuilder builder = new StringBuilder();

        for (int i = 0; i < tasks.size(); i++) {
            builder.append(i + 1);
            builder.append(". ");
            builder.append(tasks.get(i).toString());
            builder.append('\n');
        }

        return builder.toString().trim();
    }

    /**
     * Display the list of tasks and reminders as a string.
     * @param tasks The list of tasks to display.
     * @param reminders The list of reminders to display.
     * @return A string representing the tasks and reminders.
     */
    public static String display(ArrayList<Task> tasks, ArrayList<Reminder> reminders) {
        StringBuilder builder = new StringBuilder();

        builder.append(TasksListUtil.display(tasks));

        if (reminders.size() > 0) {
            builder.append("Reminders:\n");
            builder.append(RemindersListUtil.display(reminders));
        }

        return builder.toString().trim();
    }
}
```
###### /java/linenux/util/TimeInterval.java
``` java
/**
 * Represents a time interval represented by a pair of {@code LocalDateTime}.
 */
public class TimeInterval {
    private LocalDateTime from, to;

    public TimeInterval() {
        this(null, null);
    }

    public TimeInterval(TimeInterval other) {
        this(other.from, other.to);
    }

    public TimeInterval(LocalDateTime from, LocalDateTime to) {
        this.from = from;
        this.to = to;
    }

    public LocalDateTime getFrom() {
        return this.from;
    }

    public LocalDateTime getTo() {
        return this.to;
    }

    public TimeInterval setFrom(LocalDateTime from) {
        return new TimeInterval(from, this.to);
    }

    public TimeInterval setTo(LocalDateTime to) {
        return new TimeInterval(this.from, to);
    }

    /**
     * Check if {@code query} is in this time interval.
     * @param query The {@code LocalDateTime} to check.
     * @return {@code true} if and only if {@code query} is in the current interval.
     */
    public boolean inInterval(LocalDateTime query) {
        return this.from.compareTo(query) <= 0 && query.compareTo(this.to) <= 0;
    }

    /**
     * Check if the current interval is trivial.
     * @return {@code true} if and only if the interval is trivial.
     */
    public boolean isTrivial() {
        return this.from.compareTo(this.to) == 0;
    }
}
```
###### /java/linenux/view/CommandBoxController.java
``` java
public class CommandBoxController {
    @FXML
    private TextField textField;

    private ControlUnit controlUnit;
    private ArrayList<String> history = new ArrayList<>();
    int historyIndex = -1;

    @FXML
    private void initialize() {
        Platform.runLater(() -> textField.requestFocus());

        this.textField.setOnKeyReleased(event -> {
            if (event.getCode().equals(KeyCode.UP) && historyIndex > 0) {
                historyIndex--;
                this.textField.setText(this.history.get(historyIndex));
            }

            if (event.getCode().equals(KeyCode.DOWN)) {
                if (historyIndex < this.history.size() - 1) {
                    historyIndex++;
                    this.textField.setText(this.history.get(historyIndex));
                } else if (historyIndex == this.history.size() - 1) {
                    historyIndex++;
                    this.textField.setText("");
                }
            }
        });
    }

    @FXML
    private void onCommand() {
        String command = textField.getText();
        this.history.add(command);
        this.historyIndex = this.history.size();
        this.controlUnit.execute(command);
        textField.setText("");
    }

    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
    }
}
```
###### /java/linenux/view/DeadlineBoxController.java
``` java
public class DeadlineBoxController {
    @FXML
    private ListView<Task> deadlinesList;

    private ControlUnit controlUnit;
    private ObservableList<Task> deadlines = FXCollections.observableArrayList();

    @FXML
    private void initialize() {
        deadlinesList.itemsProperty().setValue(deadlines);
    }

    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        updateDeadlines();
        this.controlUnit.getSchedule().getStates().addListener((ListChangeListener<? super State>) c -> {
            updateDeadlines();
        });
        this.controlUnit.getSchedule().getFilteredTaskList().addListener((ListChangeListener<? super ArrayList<Task>>) c -> {
            updateFilteredDeadlines();
        });
    }

    private void updateDeadlines() {
        ArrayList<Task> tasks = this.controlUnit.getSchedule().getTaskList();
        ArrayList<Task> deadlines = filterDeadlines(tasks);
        this.deadlines.setAll(deadlines);
    }

    private void updateFilteredDeadlines() {
        ArrayList<Task> filteredTasks = this.controlUnit.getSchedule().getFilteredTasks();
        ArrayList<Task> deadlines = filterDeadlines(filteredTasks);
        this.deadlines.setAll(deadlines);
    }

    private ArrayList<Task> filterDeadlines(ArrayList<Task> tasks) {
        ArrayList<Task> deadlines = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isDeadline)
                .filter(((Predicate<Task>) Task::isDone).negate())
                .sortBy(Task::getTaskName)
                .sortBy(Task::getEndTime)
                .value();

        return deadlines;
    }
}
```
###### /java/linenux/view/EventBoxController.java
``` java
public class EventBoxController {
    @FXML
    private ListView<Task> eventsList;

    private ControlUnit controlUnit;
    private ObservableList<Task> events = FXCollections.observableArrayList();

    @FXML
    private void initialize() {
        eventsList.itemsProperty().setValue(events);
    }

    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        updateEvents();
        this.controlUnit.getSchedule().getStates().addListener((ListChangeListener<? super State>) c -> {
            updateEvents();
        });
        this.controlUnit.getSchedule().getFilteredTaskList().addListener((ListChangeListener<? super ArrayList<Task>>) c -> {
            updateFilteredEvents();
        });
    }

    private void updateEvents() {
        ArrayList<Task> tasks = this.controlUnit.getSchedule().getTaskList();
        ArrayList<Task> events = filterEvents(tasks);
        this.events.setAll(events);
    }

    private void updateFilteredEvents() {
        ArrayList<Task> filteredTasks = this.controlUnit.getSchedule().getFilteredTasks();
        ArrayList<Task> events = filterEvents(filteredTasks);
        this.events.setAll(events);
    }

    private ArrayList<Task> filterEvents(ArrayList<Task> tasks) {
        ArrayList<Task> events = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isEvent)
                .filter(((Predicate<Task>) Task::isDone).negate())
                .sortBy(Task::getTaskName)
                .sortBy(Task::getStartTime)
                .value();

        return events;
    }
}
```
###### /java/linenux/view/MainWindowController.java
``` java
public class MainWindowController {
    @FXML
    private SplitPane splitPane;
    @FXML
    private AnchorPane commandBoxContainer;

    private ControlUnit controlUnit;

    public MainWindowController(Config config) {
        this.controlUnit = new ControlUnit(config);
    }

    @FXML
    private void initialize() {
        setupTodoBox();
        setupDeadlineBox();
        setupEventBox();
        setupResultBox();
        splitPane.setDividerPositions(0.25, 0.50, 0.75);
        setupCommandBox();
    }

    private void setupTodoBox() {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/TodoBox.fxml"));
            AnchorPane todoBox = loader.load();
            splitPane.getItems().add(todoBox);
            TodoBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void setupDeadlineBox() {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/DeadlineBox.fxml"));
            AnchorPane deadlineBox = loader.load();
            splitPane.getItems().add(deadlineBox);
            DeadlineBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void setupEventBox() {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/EventBox.fxml"));
            AnchorPane eventBox = loader.load();
            splitPane.getItems().add(eventBox);
            EventBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void setupResultBox() {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/ResultBox.fxml"));
            AnchorPane resultBox = loader.load();
            splitPane.getItems().add(resultBox);
            ResultBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
            controller.displayReminder();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void setupCommandBox() {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/CommandBox.fxml"));
            TextField field = loader.load();
            AnchorPane.setTopAnchor(field, 2.0);
            AnchorPane.setRightAnchor(field, 5.0);
            AnchorPane.setBottomAnchor(field, 5.0);
            AnchorPane.setLeftAnchor(field, 5.0);
            commandBoxContainer.getChildren().add(field);

            CommandBoxController controller = loader.getController();
            controller.setControlUnit(this.controlUnit);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
###### /java/linenux/view/ResultBoxController.java
``` java
public class ResultBoxController {
    @FXML
    private Label commandResultLabel;

    private ControlUnit controlUnit;
    private Clock clock = Clock.systemDefaultZone();

    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;

        this.controlUnit.getLastCommandResultProperty().addListener((change) -> {
            CommandResult lastResult = this.controlUnit.getLastCommandResultProperty().getValue();
            commandResultLabel.setText(lastResult.getFeedback());
        });
    }

    public void setClock(Clock clock) {
        this.clock = clock;
    }

    // TODO Write tests for this when we can finally save the tasks.
    public void displayReminder() {
        ArrayList<String> reminders = new ArrayListUtil.ChainableArrayListUtil<>(this.controlUnit.getSchedule().getTaskList())
                .filter(((Predicate<Task>) Task::isDone).negate())
                .map(task -> remindersForTodayAsStrings(task))
                .foldr((x, xs) -> {
                    xs.addAll(x);
                    return xs;
                }, new ArrayList<String>())
                .reverse()
                .value();

        for (int i = 0; i < reminders.size(); i++) {
            String str = Integer.toString(i + 1) + ". " + reminders.get(i);
            reminders.set(i, str);
        }

        String displayString = new ArrayListUtil.ChainableArrayListUtil<>(reminders)
            .foldr(String::concat, "");

        commandResultLabel.setText(displayString);
    }

    private boolean isToday(LocalDateTime dateTime) {
        LocalDateTime now = LocalDateTime.now(this.clock);
        return now.getYear() == dateTime.getYear() && now.getDayOfYear() == dateTime.getDayOfYear();
    }

    private ArrayList<String> remindersForTodayAsStrings(Task task) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h:mma");

        return new ArrayListUtil.ChainableArrayListUtil<>(task.getReminders())
                .filter(reminder -> isToday(reminder.getTimeOfReminder()))
                .map(reminder -> {
                    String output = task.getTaskName() + " - " + reminder.getTimeOfReminder().format(formatter) + "\n";

                    if (reminder.getNote() != null && reminder.getNote().length() > 0) {
                        output += "    " + reminder.getNote() + "\n";
                    }

                    return output;
                })
                .value();
    }
}
```
###### /java/linenux/view/TodoBoxController.java
``` java
public class TodoBoxController {
    @FXML
    private ListView<Task> todosList;

    private ControlUnit controlUnit;
    private ObservableList<Task> todos = FXCollections.observableArrayList();

    @FXML
    private void initialize() {
        todosList.itemsProperty().setValue(todos);
    }

    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        updateTodos();
        this.controlUnit.getSchedule().getStates().addListener((ListChangeListener<? super State>) c -> {
            updateTodos();
        });
        this.controlUnit.getSchedule().getFilteredTaskList().addListener((ListChangeListener<? super ArrayList<Task>>) c -> {
            updateFilteredTodos();
        });
    }

    private void updateTodos() {
        ArrayList<Task> tasks = this.controlUnit.getSchedule().getTaskList();
        ArrayList<Task> todos = filterToDos(tasks);
        this.todos.setAll(todos);
    }

    private void updateFilteredTodos() {
        ArrayList<Task> filteredTasks = this.controlUnit.getSchedule().getFilteredTasks();
        ArrayList<Task> todos = filterToDos(filteredTasks);
        this.todos.setAll(todos);
    }

    private ArrayList<Task> filterToDos(ArrayList<Task> tasks) {
        ArrayList<Task> todos = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isTodo)
                .filter(((Predicate<Task>) Task::isDone).negate())
                .sortBy(Task::getTaskName)
                .value();

        return todos;
    }
}
```
