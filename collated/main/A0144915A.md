# A0144915A
###### /java/linenux/command/AbstractCommand.java
``` java
/**
 * A convenient super class that can be used by all classes implementing {@code Command}. Please do not use this class
 * to declare variables. Use the {@code Command} interface instead.
 */
public abstract class AbstractCommand implements Command {
    protected HashSet<String> TRIGGER_WORDS = new HashSet<>();

    /**
     * @param userInput A {@code String} representing user input.
     * @return {@code true} if and only if this {@code Command} can handle {@code userInput}.
     */
    @Override
    public boolean respondTo(String userInput) {
        return userInput.matches(getPattern());
    }

    /**
     * Make this {@code Command} respond to {@code alias}
     * @param alias A {@code String} representing the new alias.
     */
    @Override
    public void setAlias(String alias) {
        this.TRIGGER_WORDS.add(alias);
    }

    /**
     * Make this {@code Command} respond to {@code aliases}
     * @param aliases A {@code String} representing the new aliases.
     */
    @Override
    public void setAliases(Collection<String> aliases) {
        this.TRIGGER_WORDS = new HashSet<>(aliases);
        this.TRIGGER_WORDS.add(this.getTriggerWord());
    }

    /**
     * Make this {@code Command} to stop responding to {@code alias}.
     * @param alias A {@code String} representing the alias to remove.
     */
    @Override
    public void removeAlias(String alias) {
        this.TRIGGER_WORDS.remove(alias);
    }

    /**
     * @return A {@code Set} of all trigger words.
     */
    @Override
    public Set<String> getTriggerWords() {
        return TRIGGER_WORDS;
    }

    /**
     * @return A {@code String} representing a regular expression for this {@code Command}.
     */
    @Override
    public String getPattern(){
        return "(?i)^\\s*(" + getTriggerWordsPattern() + ")(\\s+(?<argument>.*))?$";
    }

    /**
     * @return A {@code String} representing a regular expression that matches all aliases.
     */
    protected String getTriggerWordsPattern() {
        return String.join("|", this.TRIGGER_WORDS);
    }

    /**
     * Extract the user argument from user input.
     * @param userInput A {@code String} to extract the argument from.
     * @return The user argument.
     */
    protected String extractArgument(String userInput) {
        Matcher matcher = Pattern.compile(getPattern()).matcher(userInput);

        if (matcher.matches() && matcher.group("argument") != null) {
            return matcher.group("argument").trim();
        } else {
            return "";
        }
    }
}
```
###### /java/linenux/command/AddCommand.java
``` java
/**
 * Adds a task to the schedule.
 */
public class AddCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "add";
    private static final String DESCRIPTION = "Adds a task to the schedule.";
    private static final String COMMAND_FORMAT = "add TASK_NAME [st/START_TIME] [et/END_TIME] [#/TAG...]...";

    private Schedule schedule;
    private TimeParserManager timeParserManager;
    private AddArgumentParser addArgumentParser;

    /**
     * Constructs an {@code AddCommand}.
     * @param schedule The {@code Schedule} to add new {@code Task} to.
     */
    public AddCommand(Schedule schedule) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser(), new StandardDateWithTimeParser(), new TodayWithTimeParser(), new TomorrowWithTimeParser());
        this.addArgumentParser = new AddArgumentParser(this.timeParserManager, COMMAND_FORMAT, CALLOUTS);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);

        Either<Task, CommandResult> task = this.addArgumentParser.parse(argument);

        if (task.isRight()) {
            return task.getRight();
        }

        Task actualTask = task.getLeft();

        if (this.schedule.isUniqueTask(actualTask)) {
            this.schedule.addTask(actualTask);
            return makeResult(actualTask);
        } else {
            return makeDuplicateTaskResult(actualTask);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * @param task The newly created {@code Task}.
     * @return A {@code CommandResult} indicating that a new {@code Task} is created.
     */
    private CommandResult makeResult(Task task) {
        return () -> "Added " + task.toString();
    }

    /**
     * @param task The {@code Task} that the user wants to create.
     * @return A {@code CommandResult} indicating that {@code task} is duplicated.
     */
    private CommandResult makeDuplicateTaskResult(Task task) {
        return () -> task.toString() + " already exists in the schedule!";
    }
}
```
###### /java/linenux/command/FreeTimeCommand.java
``` java
public class FreeTimeCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "freetime";
    private static final String DESCRIPTION = "Find a free time slot.";
    private static final String COMMAND_FORMAT = "freetime [st/START_TIME] et/END_TIME";

    private Schedule schedule;
    private TimeParserManager timeParserManager;
    private FreeTimeArgumentParser argumentParser;

    /**
     * Constructs an {@code FreeTimeCommand}.
     * @param schedule The {@code Schedule} to look for free time.
     */
    public FreeTimeCommand(Schedule schedule) {
        this(schedule, Clock.systemDefaultZone());
    }

    /**
     * Constructs an {@code FreeTimeCommand}.
     * @param schedule The {@code Schedule} to look for free time.
     * @param clock The {@code Clock} used to determine the current time.
     */
    public FreeTimeCommand(Schedule schedule, Clock clock) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser(), new StandardDateWithTimeParser(), new TodayWithTimeParser(), new TomorrowWithTimeParser());
        this.argumentParser = new FreeTimeArgumentParser(this.timeParserManager, clock);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);
        Either<TimeInterval, CommandResult> queryInterval = this.argumentParser.parse(argument);

        if (queryInterval.isRight()) {
            return queryInterval.getRight();
        }

        ArrayList<TimeInterval> freetime = getFreeTime(queryInterval.getLeft());

        if (freetime.isEmpty()) {
            return this.makeNoFreeTimeResult();
        } else {
            return makeResult(freetime);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Compute available free time in the {@code queryInterval}.
     * @param queryInterval The {@code TimeInterval} to look for free time.
     * @return An {@code ArrayList} of free time represented by {@code TimeInterval}.
     */
    private ArrayList<TimeInterval> getFreeTime(TimeInterval queryInterval) {
        ArrayList<TimeInterval> eventIntervals = eventIntervals(queryInterval, this.schedule.getTaskList());
        ArrayList<TimeInterval> busyIntervals = flattenIntervals(eventIntervals);
        return timeIntervalSubtraction(queryInterval, busyIntervals);
    }

    /**
     * Return the time intervals of all events happening within {@code queryInterval}. It is guaranteed that all
     * intervals are bounded by queryInterval, that is, for all x in output, x intersect queryInterval == x.
     * @param queryInterval The {@code TimeInterval} to bound the query.
     * @param tasks The {@code ArrayList} of tasks.
     * @return An {@code ArrayList} of {@code TimeInterval} for the events.
     */
    private ArrayList<TimeInterval> eventIntervals(TimeInterval queryInterval, ArrayList<Task> tasks) {
        return new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isEvent)
                .filter(task -> {
                    boolean endsBefore = task.getEndTime().compareTo(queryInterval.getFrom()) <= 0;
                    boolean startsAfter = task.getStartTime().compareTo(queryInterval.getTo()) >= 0;
                    return !(endsBefore || startsAfter);
                })
                .map(task -> {
                    LocalDateTime startTime = LocalDateTimeUtil.max(queryInterval.getFrom(), task.getStartTime());
                    LocalDateTime endTime = LocalDateTimeUtil.min(queryInterval.getTo(), task.getEndTime());
                    return new TimeInterval(startTime, endTime);
                })
                .value();
    }

    /**
     * Merge time intervals that intersect. The output is ordered.
     * @param input The input time intervals.
     * @return The output time intervals.
     */
    private ArrayList<TimeInterval> flattenIntervals(ArrayList<TimeInterval> input) {
        ArrayList<TimeInterval> sortedIntervals = new ArrayListUtil.ChainableArrayListUtil<>(input)
                .sortBy(TimeInterval::getFrom)
                .value();

        ArrayList<TimeInterval> output = new ArrayList<>();

        if (sortedIntervals.size() == 0) {
            return output;
        }

        TimeInterval interval = new TimeInterval(sortedIntervals.get(0).getFrom(), sortedIntervals.get(0).getTo());
        for (TimeInterval currentInterval: sortedIntervals) {
            if (interval.inInterval(currentInterval.getFrom())) {
                interval = new TimeInterval(interval.getFrom(),
                        LocalDateTimeUtil.max(interval.getTo(), currentInterval.getTo()));
            } else {
                output.add(interval);
                interval = new TimeInterval(currentInterval.getFrom(), currentInterval.getTo());
            }
        }
        output.add(interval);

        return output;
    }

    /**
     * Mathematically, returns {@code query} - {@code intervals}.
     * @param query The superset.
     * @param intervals The smaller subsets.
     * @return Return an {@code ArrayList} of time intervals that are not in {@code intervals} but in {@code query}.
     */
    private ArrayList<TimeInterval> timeIntervalSubtraction(TimeInterval query, ArrayList<TimeInterval> intervals) {
        if (intervals.size() == 0) {
            return ArrayListUtil.fromSingleton(query);
        }

        ArrayList<TimeInterval> output = new ArrayList<>();
        TimeInterval firstInterval = new TimeInterval(query.getFrom(), intervals.get(0).getFrom());
        if (!firstInterval.isTrivial()) {
            output.add(firstInterval);
        }
        for (int i = 1; i < intervals.size(); i++) {
            output.add(new TimeInterval(intervals.get(i-1).getTo(), intervals.get(i).getFrom()));
        }
        TimeInterval lastInterval = new TimeInterval(intervals.get(intervals.size() - 1).getTo(), query.getTo());
        if (!lastInterval.isTrivial()) {
            output.add(lastInterval);
        }
        return output;
    }

    /**
     * @param freetimes The {@code ArrayList} of free time.
     * @return A {@code CommandResult} displaying {@code freetimes}.
     */
    private CommandResult makeResult(ArrayList<TimeInterval> freetimes) {
        return () -> {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd h.mma");
            StringBuilder builder = new StringBuilder();
            builder.append("You are free at the following time slots:\n");
            for (TimeInterval freetime: freetimes) {
                builder.append(" - ");
                builder.append(freetime.getFrom().format(formatter));
                builder.append(" - ");
                builder.append(freetime.getTo().format(formatter));
                builder.append("\n");
            }
            return builder.toString();
        };
    }

    /**
     * @return A {@code CommandResult} indicating that the user has no free time.
     */
    private CommandResult makeNoFreeTimeResult() {
        return () -> "You don't have any free time in that period.";
    }
}
```
###### /java/linenux/command/InvalidCommand.java
``` java
/**
 * Act as a fail-safe for invalid or unrecognized commands.
 */
public class InvalidCommand extends AbstractCommand {
    private ControlUnit controlUnit;

    private CommandResult lastCommandResult = null;
    private String lastCorrectedCommand = null;

    public InvalidCommand(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        this.controlUnit.addPostExecuteListener((userInput, commandResult) -> {
            if (commandResult != lastCommandResult) {
                lastCorrectedCommand = null;
            }
        });
    }

    /**
     * @return true for all user inputs.
     */
    @Override
    public boolean respondTo(String userInput) {
        return true;
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        if (userInput.trim().toLowerCase().equals("yes") && this.lastCorrectedCommand != null) {
            CommandResult output = this.controlUnit.execute(this.lastCorrectedCommand);
            this.lastCorrectedCommand = null;
            this.lastCommandResult = null;
            return output;
        }

        String userCommand = extractCommand(userInput);
        String userArgument = parseArgument(userInput);
        String suggestion = null;
        int bestScore = Integer.MAX_VALUE;

        for (Command command: this.controlUnit.getCommandList()) {
            for (String triggerWord: command.getTriggerWords()) {
                int similarity = StringsSimilarity.compute(userCommand, command.getTriggerWord());
                if (similarity < bestScore) {
                    suggestion = triggerWord;
                    bestScore = similarity;
                }
            }
        }

        if (suggestion == null) {
            this.lastCommandResult = this.makeResponse();
        } else {
            this.lastCorrectedCommand = suggestion + " " + userArgument;
            this.lastCommandResult = this.makeResponseWithSuggestion(suggestion);
        }

        return this.lastCommandResult;
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return null;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return null;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return null;
    }

    @Override
    public String getPattern() {
        return null;
    }

    /**
     * Extract the command trigger word from {@code userInput}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code String}, which is the command trigger word.
     */
    private String extractCommand(String userInput) {
        String[] parts = userInput.split(" ");

        if (parts.length > 0) {
            return parts[0];
        } else {
            return "";
        }
    }

    private String parseArgument(String userInput) {
        String[] parts = userInput.split("\\s+", 2);

        if (parts.length == 2) {
            return parts[1];
        } else {
            return "";
        }
    }

    private CommandResult makeResponse() {
        return () -> "Invalid command.";
    }

    private CommandResult makeResponseWithSuggestion(String suggestion) {
        return () -> "Invalid command. Did you mean " + suggestion + "?";
    }
}
```
###### /java/linenux/command/LoadCommand.java
``` java
public class LoadCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "load";
    private static final String DESCRIPTION = "Load schedule from the specified path.";
    private static final String COMMAND_FORMAT = "load PATH";

    private ControlUnit controlUnit;
    private Path basePath;

    /**
     * Instantiate a {@code LoadCommand} using a {@code ControlUnit}.
     * @param controlUnit The application {@code ControlUnit}.
     */
    public LoadCommand(ControlUnit controlUnit) {
        this(controlUnit, Paths.get("").toAbsolutePath());
    }

    /**
     * Instantiate a {@code LoadCommand} using a {@code ControlUnit} and the current directory.
     * @param controlUnit The application {@code ControlUnit}.
     * @param basePath The current working directory.
     */
    public LoadCommand(ControlUnit controlUnit, Path basePath) {
        this.controlUnit = controlUnit;
        this.basePath = basePath;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        String relativePath = this.extractArgument(userInput);

        if (relativePath.isEmpty()) {
            return this.makeInvalidArgumentResult();
        }

        String path = this.basePath.resolve(relativePath).toString();
        File f = new File(path);

        if (!f.exists()) {
            return this.makeFileNotFoundResult(path);
        } else if (!f.isFile()) {
            return this.makeNotAFileResult(path);
        } else if (!f.canRead()) {
            return this.makeFileNotReadableResult(path);
        } else {
            this.controlUnit.setScheduleFilePath(path);
            this.controlUnit.loadSchedule();
        }

        return this.makeResult(path);
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * @param path The loaded path.
     * @return A {@code CommandResult} indicating that {@code Schedule} is loaded.
     */
    private CommandResult makeResult(String path) {
        return () -> "Loaded from " + path;
    }

    /**
     * @param path The path that the user wants to load.
     * @return A {@code CommandResult} indicating the {@code path} cannot be found.
     */
    private CommandResult makeFileNotFoundResult(String path) {
        return () -> path + " does not exist.";
    }

    /**
     * @param path The path that the user wants to load.
     * @return A {@code CommandResult} indicating the {@code path} cannot be read.
     */
    private CommandResult makeFileNotReadableResult(String path) {
        return () -> path + " is not readable.";
    }

    /**
     * @param path The path that the user wants to load.
     * @return A {@code CommandResult} indicating the {@code path} is not a file.
     */
    private CommandResult makeNotAFileResult(String path) {
        return () -> path + " is not a file.";
    }

    /**
     * @return A {@code CommandResult} indicating that the argument is invalid.
     */
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }
}
```
###### /java/linenux/command/parser/AddArgumentParser.java
``` java
/**
 * Parser for the argument portion of add command.
 **/
public class AddArgumentParser extends BaseArgumentParser {
    private GenericParser genericParser = new GenericParser();
    private GenericParser.GenericParserResult parseResult;
    public String commandFormat;
    public String callouts;

    /**
     * The public constructor for {@code AddArgumentParser}.
     * @param timeParserManager A {@code TimeParserManager} used to parse any date time string.
     * @param commandFormat A {@code String} representing the format of the command using this class.
     * @param callouts A {@code String}, which is an extra message added to the command result when argument is invalid.
     */
    public AddArgumentParser(TimeParserManager timeParserManager, String commandFormat, String callouts) {
        this.timeParserManager = timeParserManager;
        this.commandFormat = commandFormat;
        this.callouts = callouts;
    }

    /**
     * Attempts to parse an argument given by the user.
     * @param argument A {@code String}, which is part of the user input.
     * @return An {@code Either}. Its left slot is a {@code Task} if {@code argument} represents a valid {@code Task}.
     */
    public Either<Task, CommandResult> parse(String argument) {
        this.parseResult = this.genericParser.parse(argument);

        return Either.<Task, CommandResult>left(new Task(""))
                .bind(this::extractTaskName)
                .bind(this::extractStartTime)
                .bind(this::extractEndTime)
                .bind(this::extractTags)
                .bind(this::ensureValidDateCombination)
                .bind(this::ensureValidEventTimes);
    }

    /**
     * Attempts to extract the name of task from user argument.
     * @param task An existing {@code Task}.
     * @return An {@code Either}. If the name of the task can be extracted, its left slot is {@code task} with its name
     * set to the name specified by the user. Otherwise, its right slot is a {@code CommandResult} describing the
     * failure.
     */
    private Either<Task, CommandResult> extractTaskName(Task task) {
        if (this.parseResult.getKeywords().length() > 0) {
            Task output = task.setTaskName(this.parseResult.getKeywords());
            return Either.left(output);
        } else {
            return Either.right(makeInvalidArgumentResult());
        }
    }

    /**
     * Attempts to extract the start time of task from user argument.
     * @param task An existing {@code Task}.
     * @return An {@code Either}. If the name of the task can be extracted, its left slot is {@code task} with its
     * start time set to the start time specified by the user. Otherwise, its right slot is a {@code CommandResult}
     * describing the failure.
     */
    private Either<Task, CommandResult> extractStartTime(Task task) {
        if (this.parseResult.getArguments("st").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("st").get(0))
                    .bind(t -> Either.left(task.setStartTime(t)));
        } else {
            return Either.left(task);
        }
    }

    /**
     * Attempts to extract the end time of task from user argument.
     * @param task An existing {@code Task}.
     * @return An {@code Either}. If the name of the task can be extracted, its left slot is {@code task} with its
     * end time set to the end time specified by the user. Otherwise, its right slot is a {@code CommandResult}
     * describing the failure.
     */
    private Either<Task, CommandResult> extractEndTime(Task task) {
        if (this.parseResult.getArguments("et").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("et").get(0))
                    .bind(t -> Either.left(task.setEndTime(t)));
        } else {
            return Either.left(task);
        }
    }

    /**
     * Attempts to extract the tags of task from user argument.
     * @param task An existing {@code Task}.
     * @return An {@code Either}. If the name of the task can be extracted, its left slot is {@code task} with its
     * tags set to the tags specified by the user. Otherwise, its right slot is a {@code CommandResult} describing
     * the failure.
     */
    private Either<Task, CommandResult> extractTags(Task task) {
        ArrayList<String> tags = ArrayListUtil.unique(this.parseResult.getArguments("#"));

        if (tags.indexOf("") == -1) {
            return Either.left(task.setTags(tags));
        } else {
            return Either.right(makeInvalidArgumentResult());
        }
    }

    /**
     * Makes sure that {@code task} has a valid start time/end time combination. In particular, we do not allow
     * a {@code Task} to have a start time but not an end time.
     * @param task The {@code Task} to validate.
     * @return An {@code Either}. Its left slot is {@code task} if {@code task} is valid (in context). Otherwise,
     * its right slot contains a {@code CommandResult} describing the error.
     */
    private Either<Task, CommandResult> ensureValidDateCombination(Task task) {
        if (task.getStartTime() == null || task.getEndTime() != null) {
            return Either.left(task);
        } else {
            return Either.right(makeStartTimeWithoutEndTimeResult());
        }
    }

    /**
     * Makes sure that {@code task} has valid start time/end time. In particular, end time cannot come before start
     * time.
     * @param task The {@code Task} to validate.
     * @return An {@code Either}. Its left slot is {@code task} if {@code task} is valid (in context). Otherwise,
     * its right slot contains a {@code CommandResult} describing the error.
     */
    private Either<Task, CommandResult> ensureValidEventTimes(Task task) {
        if (task.getStartTime() == null || task.getEndTime() == null || task.getEndTime().compareTo(task.getStartTime()) >= 0) {
            return Either.left(task);
        } else {
            return Either.right(makeEndTimeBeforeStartTimeResult());
        }
    }

    /**
     * @return A {@code CommandResult} when the user argument is invalid.
     */
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + commandFormat + "\n\n" + callouts;
    }

    /**
     * @return A {@code CommandResult} describing that a {@code Task} cannot have a start time without an end time.
     */
    private CommandResult makeStartTimeWithoutEndTimeResult() {
        return () -> "Cannot create task with start time but without end time.";
    }

    /**
     * @return A {@code CommandResult} describing that the end time of a {@code Task} cannot come before its start time.
     */
    private CommandResult makeEndTimeBeforeStartTimeResult() {
        return () -> "End time cannot come before start time.";
    }
}
```
###### /java/linenux/command/parser/BaseArgumentParser.java
``` java
/**
 * Provides common methods for various parsers.
 */
public abstract class BaseArgumentParser {
    protected TimeParserManager timeParserManager;

    /**
     * Attempts to parse a date time string.
     * @param string The {@code String} to parse.
     * @return An {@code Either}. Its left slot is a {@code LocalDateTime} if {@code string} can be parsed. Otherwise,
     * its right slot contains a {@code CommandResult} describing the error.
     */
    public Either<LocalDateTime, CommandResult> parseDateTime(String string) {
        if (this.timeParserManager.canParse(string)) {
            return Either.left(this.timeParserManager.delegateTimeParser(string));
        } else {
            return Either.right(makeInvalidDateTimeResult(string));
        }
    }

    public Either<LocalDateTime, CommandResult> parseCancellableDateTime(String string) {
        if (this.timeParserManager.canParse(string)) {
            return Either.left(this.timeParserManager.delegateTimeParser(string));
        } else if (string.matches("\\s*-\\s*")) {
            return Either.left(null);
        } else {
            return Either.right(makeInvalidDateTimeResult(string));
        }
    }

    /**
     * @param dateTime A {@code String} given by the user.
     * @return A {@code CommandResult} describing that {@code dateTime} cannot be parsed.
     */
    private CommandResult makeInvalidDateTimeResult(String dateTime) {
        return () -> "Cannot parse \"" + dateTime + "\".";
    }
}
```
###### /java/linenux/command/parser/FreeTimeArgumentParser.java
``` java
/**
 * A helper class used to parse the arguments to the free time command.
 */
public class FreeTimeArgumentParser extends BaseArgumentParser {
    private GenericParser genericParser;
    private GenericParser.GenericParserResult parseResult;
    private Clock clock;

    /**
     * The public constructor for {@code FreeTimeArgumentParser}.
     * @param timeParserManager A {@code TimeParserManager} used to parse any date time string.
     * @param clock A {@code Clock}. This is used to determine the current time. Helpful when doing DI in tests.
     */
    public FreeTimeArgumentParser(TimeParserManager timeParserManager, Clock clock) {
        this.timeParserManager = timeParserManager;
        this.genericParser = new GenericParser();
        this.clock = clock;
    }

    /**
     * Attempts to parse an argument given by the user.
     * @param argument A {@code String}, which is part of the user input.
     * @return An {@code Either}. Its left slot is a {@code TimeInterval} representing the query range if
     * {@code argument} is valid. Otherwise, its right slot is a {@code CommandResult} indicating the failure.
     */
    public Either<TimeInterval, CommandResult> parse(String argument) {
        this.parseResult = this.genericParser.parse(argument);

        return Either.<TimeInterval, CommandResult>left(new TimeInterval())
                .bind(this::parseStartTime)
                .bind(this::parseEndTime)
                .bind(this::ensureIntervalValidity);
    }

    /**
     * Attempts to extract the start of the query interval.
     * @param interval An existing {@code TimeInterval}.
     * @return An {@code Either}. If the start time can be extracted, its left slot is {@code interval} with its start
     * time set to the start time specified by the user. Otherwise, its right slot is a {@code CommandResult} describing
     * the failure.
     */
    private Either<TimeInterval, CommandResult> parseStartTime(TimeInterval interval) {
        if (this.parseResult.getArguments("st").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("st").get(0))
                    .bind(t -> Either.left(interval.setFrom(t)));
        } else {
            return Either.left(interval.setFrom(LocalDateTime.now(this.clock)));
        }
    }

    /**
     * Attempts to extract the end the query interval.
     * @param interval An existing {@code TimeInterval}.
     * @return An {@code Either}. If the end time can be extracted, its left slot is {@code interval} with its end time
     * set to the end time specified by the user. Otherwise, its right slot is a {@code CommandResult} describing the
     * failure.
     */
    private Either<TimeInterval, CommandResult> parseEndTime(TimeInterval interval) {
        if (this.parseResult.getArguments("et").size() > 0) {
            return parseDateTime(this.parseResult.getArguments("et").get(0))
                    .bind(t -> Either.left(interval.setTo(t)));
        } else {
            return Either.right(makeEndTimeNotSpecified());
        }
    }

    /**
     * Makes sure that {@code interval} represents a valid time interval.
     * @param interval The {@code TimeInterval} to validate.
     * @return An {@code Either}. If {@code interval} is valid, its left slot is {@code interval}. Otherwise, its right
     * slot is a {@code CommandResult} indicating the error.
     */
    private Either<TimeInterval, CommandResult> ensureIntervalValidity(TimeInterval interval) {
        if (interval.getFrom().compareTo(interval.getTo()) <= 0) {
            return Either.left(interval);
        } else {
            return Either.right(makeEndTimeBeforeStartTimeResult());
        }
    }

    /**
     * @return A {@code CommandResult} indicating that the specified end time comes before the speicifed start time.
     */
    private CommandResult makeEndTimeBeforeStartTimeResult() {
        return () -> "End time must be after start time.";
    }

    /**
     * @return A {@code CommandResult} indicating that end time is not specified.
     */
    private CommandResult makeEndTimeNotSpecified() {
        return () -> "End time must be specified.";
    }
}
```
###### /java/linenux/command/result/PromptResults.java
``` java
/**
 * A collection of helper functions related to prompting user for more information.
 */
public class PromptResults {
    /**
     * Prompts the user to choose from an {@code ArrayList} of {@code Task}.
     * @param tasks The {@code ArrayList} of {@code Task} that the user can choose from.
     * @return A {@code CommandResult} prompting the user to choose a {@code Task} from {@code tasks}.
     */
    public static CommandResult makePromptIndexResult(ArrayList<Task> tasks) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("Which one? (1-");
            builder.append(tasks.size());
            builder.append(", \"cancel\" to cancel the current operation)\n");

            builder.append(ArrayListUtil.display(tasks));

            return builder.toString();
        };
    }

    /**
     * Prompts the user to choose from an {@code ArrayList} of {@code Reminder}.
     * @param results The {@code ArrayList} of {@code Reminder} that the user can choose from.
     * @return A {@code CommandResult} prompting the user to choose a {@code Reminder} from {@code results}.
     */
    public static CommandResult makePromptReminderIndexResult(ArrayList<ReminderSearchResult> results) {
        return () -> {
            int totalResults = ReminderSearchResult.totalReminders(results);

            StringBuilder builder = new StringBuilder();
            builder.append("Which one? (1-");
            builder.append(totalResults);
            builder.append(", \"cancel\" to cancel the current operation)\n");
            builder.append(RemindersListUtil.displaySearchResults(results));

            return builder.toString().trim();
        };
    }

    /**
     * Make a {@code CommandResult} indicating that the index the user chose is invalid.
     * @param tasks The {@code ArrayList} of {@code Task} that the user can choose from.
     * @return A {@code CommandResult} prompting the user to choose again.
     */
    public static CommandResult makeInvalidIndexResult(ArrayList<Task> tasks) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("That's not a valid index. Enter a number between 1 and ");
            builder.append(tasks.size());
            builder.append(", or \"cancel\" to cancel the current operation:\n");
            builder.append(ArrayListUtil.display(tasks));
            return builder.toString();
        };
    }

    /**
     * Make a {@code CommandResult} indicating that the index the user chose is invalid.
     * @param results The {@code ArrayList} of {@code Reminder} that the user can choose from.
     * @return A {@code CommandResult} prompting the user to choose again.
     */
    public static CommandResult makeInvalidReminderIndexResult(ArrayList<ReminderSearchResult> results) {
        return () -> {
            int totalReminders = ReminderSearchResult.totalReminders(results);

            StringBuilder builder = new StringBuilder();
            builder.append("That's not a valid index. Enter a number between 1 and ");
            builder.append(totalReminders);
            builder.append(", or \"cancel\" to cancel the current operation:\n");
            builder.append(RemindersListUtil.displaySearchResults(results));

            return builder.toString().trim();
        };
    }
}
```
###### /java/linenux/command/SaveCommand.java
``` java
public class SaveCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "save";
    private static final String DESCRIPTION = "Save the schedule into the specified file.";
    private static final String COMMAND_FORMAT = "save PATH";

    private ControlUnit controlUnit;
    private Path basePath;
    private boolean requiresUserResponse = false;
    private String pendingSavePath = null;

    /**
     * Instantiate a {@code SaveCommand} using a {@code ControlUnit}.
     * @param controlUnit The application {@code ControlUnit}.
     */
    public SaveCommand(ControlUnit controlUnit) {
        this(controlUnit, Paths.get("").toAbsolutePath());
    }

    /**
     * Instantiate a {@code SaveCommand} using a {@code ControlUnit} and the current directory.
     * @param controlUnit The application {@code ControlUnit}.
     * @param basePath The current working directory.
     */
    public SaveCommand(ControlUnit controlUnit, Path basePath) {
        this.controlUnit = controlUnit;
        this.basePath = basePath;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        String relativePath = this.extractArgument(userInput);

        if (relativePath.isEmpty()) {
            return this.makeInvalidArgumentResult();
        }

        Path targetPath = this.basePath.resolve(relativePath);
        Path parentPath = targetPath.getParent();
        String path = this.basePath.resolve(relativePath).toString();
        File file = new File(path);

        try {
            new File(parentPath.toString()).mkdirs();

            if (file.exists()) {
                this.requiresUserResponse = true;
                this.pendingSavePath = path;
                return this.makeFileExistsResult(path);
            } else {
                new FileOutputStream(file).close();
            }
        } catch (Exception e) {
        }

        return this.validateAndUpdate(file);
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return this.requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        if (userInput.trim().toLowerCase().equals("yes")) {
            this.requiresUserResponse = false;
            File file = new File(this.pendingSavePath);
            return this.validateAndUpdate(file);
        } else if (userInput.trim().toLowerCase().equals("no")) {
            this.requiresUserResponse = false;
            return this.makeCancelResult();
        } else {
            return this.makeInvalidUserResponse();
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Ensure that {@code file} can be written. If so, asks the control unit to write to {@code file}.
     * @param file The {@code File} to write to.
     * @return A {@code CommandResult} indicating the result.
     */
    private CommandResult validateAndUpdate(File file) {
        if (file.canWrite()) {
            this.controlUnit.setScheduleFilePath(file.toString());
            this.controlUnit.saveSchedule();
            return makeResult(file.toString());
        } else {
            return makeNotWritableResult(file.toString());
        }
    }

    /**
     * @param path The saved path.
     * @return A {@code CommandResult} indicating that {@code Schedule} is saved.
     */
    private CommandResult makeResult(String path) {
        return () -> "Saved to " + path;
    }

    /**
     * @param path The path that the user wants to save to.
     * @return A {@code CommandResult} indicating that {@code path} is not writable.
     */
    private CommandResult makeNotWritableResult(String path) {
        return () -> "Cannot save to " + path;
    }

    /**
     * @param path The path that the user wants to save to.
     * @return A {@code CommandResult} indicating that {@code path} is an existing file.
     */
    private CommandResult makeFileExistsResult(String path) {
        return () -> path + " already exists.\n" +
                "Do you want to overwrite it? (yes/no)";
    }

    /**
     * @return A {@code CommandResult} indicating that the save operation is cancelled.
     */
    private CommandResult makeCancelResult() {
        return () -> "OK! Not overwriting " + this.pendingSavePath;
    }

    /**
     * @return A {@code CommandResult} indicating that the argument is invalid.
     */
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @return A {@code CommandResult} indicating that the user response is invalid.
     */
    private CommandResult makeInvalidUserResponse() {
        return () -> "I don't understand that. Do you want to overwrite " + this.pendingSavePath + "? (yes/no)";
    }
}
```
###### /java/linenux/command/UnaliasCommand.java
``` java
public class UnaliasCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "unalias";
    private static final String DESCRIPTION = "Removes an alias.";
    private static final String COMMAND_FORMAT = "unalias ALIAS";

    private ArrayList<Command> commands;

    public UnaliasCommand(ArrayList<Command> commands) {
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
        this.commands = commands;
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        String argument = extractArgument(userInput);

        for (Command command: this.commands) {
            if (command.getTriggerWord().equals(argument)) {
                return makeUnaliasDefaultResult(argument);
            } else if (command.respondTo(argument)) {
                command.removeAlias(argument);
                return makeUnaliasResult(argument);
            }
        }

        return makeInvalidAliasResult(argument);
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private CommandResult makeUnaliasResult(String alias) {
        return () -> "\"" + alias + "\" is removed as an alias.";
    }

    private CommandResult makeInvalidAliasResult(String alias) {
        return () -> "\"" + alias + "\" is not an alias.";
    }

    private CommandResult makeUnaliasDefaultResult(String alias) {
        return () -> "\"" + alias + "\" cannot be removed as an alias.";
    }
}
```
###### /java/linenux/command/util/ReminderSearchResult.java
``` java
/**
 * The class of an object used to represent the result of searching for {@code Reminder}.
 */
public class ReminderSearchResult {
    private Task task;
    private ArrayList<Reminder> reminders;

    /**
     * From an {@code ArrayList} of {@code ReminderSearchResult}, return the {@code Task} that {@code reminder} belongs
     * to.
     * @param results An {@code ArrayList} of {@code ReminderSearchResult}.
     * @param reminder The {@code Reminder} that we are interested in.
     * @return A {@code Task} such that {@code reminder} is one of its reminders.
     */
    public static Task getTaskFromReminder(ArrayList<ReminderSearchResult> results, Reminder reminder) {
        for (ReminderSearchResult result : results) {
            if (result.getReminders().contains(reminder)) {
                return result.getTask();
            }
        }
        return null;
    }

    /**
     * Given an {@code ArrayList} of {@code ReminderSearchResult}, count the total number of {@code Reminder}.
     * @param results The {@code ArrayList} of {@code ReminderSearchResult}.
     * @return The total number of {@code Reminder} that {@code results} have.
     */
    public static int totalReminders(ArrayList<ReminderSearchResult> results) {
        return new ArrayListUtil.ChainableArrayListUtil<>(results)
                .map(ReminderSearchResult::getReminders)
                .map(ArrayList::size)
                .foldr((a, b) -> a + b, 0);
    }

    /**
     * Construct a {@code ReminderSearchResult} from a {@code Task} and an {@code ArrayList} of {@code Reminder}.
     * @param task A {@code Task}.
     * @param reminders An {@code ArrayList} of {@code Reminder} such that each element is a reminder of {@code task}
     *                  matching some search criteria.
     */
    public ReminderSearchResult(Task task, ArrayList<Reminder> reminders) {
        this.task = task;
        this.reminders = reminders;
    }

    /**
     * @return The {@code Task} that this {@code ReminderSearchResult} is wrapping.
     */
    public Task getTask() {
        return this.task;
    }

    /**
     * @return An {@code ArrayList} of {@code Reminder} that match some search criteria.
     */
    public ArrayList<Reminder> getReminders() {
        return this.reminders;
    }
}
```
###### /java/linenux/config/Config.java
``` java
public interface Config {
    /**
     * @return The version of the program that created the config file.
     */
    public String getVersionNo();

    /**
     * @return The absolute path to the current schedule file.
     */
    public String getScheduleFilePath();

    /**
     * @param path The absolute path to the new schedule file.
     */
    public void setScheduleFilePath(String path);

    /**
     * @return Whether or not the config file is present.
     */
    public boolean hasConfigFile();

    /**
     * @param triggerWord The original trigger word of a command.
     * @return A {@code Collection} of aliases for that command.
     */
    public Collection<String> getAliases(String triggerWord);

    /**
     * @param triggerWord The original trigger word of a command.
     * @param aliases A {@code Collection} of aliases for that command.
     */
    public void setAliases(String triggerWord, Collection<String> aliases);
}
```
###### /java/linenux/time/parser/ISODateWithTimeParser.java
``` java
/**
 * Parse date and time in the form of "2016-10-01 2:00pm"
 */
public class ISODateWithTimeParser implements TimeParser {
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h.mma");

    /**
     * Checks if the user input corresponds to the format of the respective
     * time parser.
     *
     * @param input
     * @return true if format matches and false otherwise.
     */
    @Override
    public boolean respondTo(String input) {
        try {
            parse(input);
            return true;
        } catch (DateTimeParseException e) {
            return false;
        }
    }

    /**
     * Parses the userInput string to a time instance. This method assumes that {@code respondTo} returns {@code true}.
     * @param input The input to parse.
     * @return The {@code LocalDateTime}, which is the result of parsing {@code input}.
     */
    @Override
    public LocalDateTime parse(String input) {
        return LocalDateTime.parse(input.toUpperCase(), formatter);
    }
}
```
###### /java/linenux/util/ArrayListUtil.java
``` java
/**
 * A set of utility functions for {@code ArrayList}.
 */
public class ArrayListUtil {
    /**
     * A layer of abstraction on top of ArrayListUtil to allow chainable calls.
     * For example, instead of writing
     *
     * <pre><code>
     * String[] numbers = {"1", "2", "3"};
     * ArrayList&lt;Integer&gt; listOfNumbers = ArrayListUtil.map(Integer.parseInt, ArrayListUtil.fromArray(numbers));
     * </code></pre>
     *
     * We can do
     *
     * <pre><code>
     * String[] numbers = {"1", "2", "3"};
     * ArrayList&lt;Integer&gt; listOfNumbers = new ChainableArrayListUtil&lt;String&gt;(numbers)
     *      .map(Integer.parseInt)
     *      .value();
     * </code></pre>
     *
     * Inspired by Lodash.
     *
     * @param <T> Any type that ArrayList allows.
     */
    public static class ChainableArrayListUtil<T> {
        private ArrayList<T> list;

        /**
         * Make a {@code ChainableArrayListUtil} out of an array.
         * @param arr The array to wrap.
         */
        public ChainableArrayListUtil(T[] arr) {
            this(ArrayListUtil.fromArray(arr));
        }

        /**
         * Make a {@code ChainableArrayListUtil} out of a {@code List}.
         * @param list The {@code list} to wrap.
         */
        public ChainableArrayListUtil(List<T> list) {
            this.list = new ArrayList<T>(list);
        }

        /**
         * @param fn The mapper function.
         * @param <R> Any type that ArrayList accepts.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public <R> ChainableArrayListUtil<R> map(Function<T, R> fn) {
            return new ChainableArrayListUtil<R>(ArrayListUtil.map(fn, this.list));
        }

        /**
         * @param fn The mapper function. The second argument is the index of each element.
         * @param <R> Any type that ArrayList accepts.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public <R> ChainableArrayListUtil<R> mapWithIndex(BiFunction<T, Integer, R> fn) {
            return new ChainableArrayListUtil<>(ArrayListUtil.mapWithIndex(fn, this.list));
        }

        /**
         * @param fn The filter predicate.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public ChainableArrayListUtil<T> filter(Predicate<T> fn) {
            return new ChainableArrayListUtil<T>(ArrayListUtil.filter(fn, this.list));
        }

        /**
         * Sort the {@code ArrayList} by the {@code comparator}.
         * @param comparator The comparator used to determine the weak ordering of the elements.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public ChainableArrayListUtil<T> sort(Comparator<T> comparator) {
            ArrayList<T> copy = new ArrayList<>(this.list);
            Collections.sort(copy, comparator);
            return new ChainableArrayListUtil<>(copy);
        }

        /**
         * Sort the {@code ArrayList} according to the value given by the specified function.
         * @param fn A pure function taking in elements of the array list and returning some {@code Comparable}.
         * @param <R> Any type implementing {@code Comparable}.
         * @return A new {@code ChainableArrayListUtil} wrapping the new {@code ArrayList}.
         */
        public <R extends Comparable<R>> ChainableArrayListUtil<T> sortBy(Function<T, R> fn) {
            return this.sort((a, b) -> fn.apply(a).compareTo(fn.apply(b)));
        }

        /**
         * Performs right fold on the current list. Notice that this method breaks the chain as it does not return
         * another instance of {@code ChainableArrayListUtil}.
         * @param reducer The reducer function.
         * @param initialValue The initial value fed into {@code reducer}.
         * @param <R> The output type.
         * @return The fold result.
         */
        public <R> R foldr(BiFunction<T, R, R> reducer, R initialValue) {
            return ArrayListUtil.foldr(reducer, initialValue, this.list);
        }

        /**
         * A special case of {@code foldr}, that is, when the output is also an {@code ArrayList}. We can wrap the
         * output in a {@code ChainableArrayListUtil}.
         * @param reducer The reducer function.
         * @param initialList The initial value fed into {@code reducer}. In this case, it must be an {@code ArrayList}.
         * @param <R> The type of the output list.
         * @return A {@code ChainableArrayListUtil} wrapping the fold result.
         */
        public <R> ChainableArrayListUtil<R> foldr(BiFunction<T, ArrayList<R>, ArrayList<R>> reducer, ArrayList<R> initialList) {
            ArrayList<R> result = ArrayListUtil.foldr(reducer, initialList, this.list);
            return new ChainableArrayListUtil<>(result);
        }

        /**
         * Reverse the list.
         * @return The reversed list wrapped in {@ChainableArrayListUtil}.
         */
        public ChainableArrayListUtil<T> reverse() {
            ArrayList<T> reversed = ArrayListUtil.reverse(this.list);
            return new ChainableArrayListUtil<>(reversed);
        }

        /**
         * Returns the underlying {@code ArrayList}.
         * @return The underlying {@code ArrayList}.
         */
        public ArrayList<T> value() {
            return this.list;
        }
    }

    /**
     * Transform the input {@code ArrayList} using {@code fn}.
     * @param fn The stateless mapper function.
     * @param list The input {@code ArrayList}.
     * @param <T> The type of the input {@code ArrayList}.
     * @param <R> The type of the output {@code ArrayList}.
     * @return The transformed {@code ArrayList}.
     */
    public static <T, R> ArrayList<R> map(Function<T, R> fn, ArrayList<T> list) {
        return mapWithIndex((x, i) -> fn.apply(x), list);
    }

    /**
     * Transform the input {@code ArrayList} using {@code fn}.
     * @param fn The stateless mapper function. The second argument of {@code fn} is the index.
     * @param list The input {@code ArrayList}.
     * @param <T> The type of the input {@code ArrayList}.
     * @param <R> The type of the output {@code ArrayList}.
     * @return The transformed {@code ArrayList}.
     */
    public static <T, R> ArrayList<R> mapWithIndex(BiFunction<T, Integer, R> fn, ArrayList<T> list) {
        ArrayList<R> output = new ArrayList<>();

        for (int i = 0; i < list.size(); i++) {
            output.add(fn.apply(list.get(i), i));
        }

        return output;
    }

    /**
     * Filter the input {@code ArrayList} based on the output of {@code fn}.
     * @param fn The predicate function.
     * @param list The input {@code ArrayList}.
     * @param <T> The type of the {@code ArrayList}.
     * @return The filtered {@code ArrayList}.
     */
    public static <T> ArrayList<T> filter(Predicate<T> fn, ArrayList<T> list) {
        return list.stream().filter(fn).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    }

    /**
     * Performs right fold on {@code list}.
     * @param reducer The reducer function.
     * @param initialValue The initial value fed to {@code reducer}. If {@code list} is empty, this value is returned.
     * @param list The {@code ArrayList} to fold.
     * @param <T> The type of the {@code ArrayList}.
     * @param <R> The output type.
     * @return The result of the fold.
     */
    public static <T, R> R foldr(BiFunction<T, R, R> reducer, R initialValue, ArrayList<T> list) {
        R output = initialValue;

        for (int i = list.size() - 1; i >= 0; i--) {
            output = reducer.apply(list.get(i), output);
        }

        return output;
    }

    /**
     * Reverse a list.
     * @param list The {@code ArrayList} to reverse.
     * @param <T> The type of the {@code ArrayList}.
     * @return The reversed list.
     */
    public static <T> ArrayList<T> reverse(ArrayList<T> list) {
        return foldr((x, xs) -> {
            xs.add(x);
            return xs;
        }, new ArrayList<T>(), list);
    }

    /**
     * Returns a new list by removing repeated elements in {@code list}.
     *
     * @param list The Input list
     * @return The list with repeated elements removed.
     */
    public static <T> ArrayList<T> unique(ArrayList<T> list) {
        HashSet<T> set = new HashSet<>();
        ArrayList<T> output = new ArrayList<>();

        for (T val : list) {
            if (!set.contains(val)) {
                set.add(val);
                output.add(val);
            }
        }

        return output;
    }

    /**
     * Make an {@code ArrayList} out of an array.
     * @param arr The input array.
     * @param <T> The type of the array.
     * @return An {@code ArrayList} containing the same elements as {@code arr}.
     */
    public static <T> ArrayList<T> fromArray(T[] arr) {
        return new ArrayList<T>(Arrays.asList(arr));
    }

    /**
     * Make an {@code ArrayList} with only one element.
     * @param elem The only element in the array list.
     * @param <T> The type of the element.
     * @return An {@code ArrayList} containing only {@code elem}.
     */
    public static <T> ArrayList<T> fromSingleton(T elem) {
        ArrayList<T> output = new ArrayList<>();
        output.add(elem);
        return output;
    }

    /**
     * Display a list of {@code Object}.
     * @param list The {@code ArrayList} to display.
     * @return The formatted {@code String}.
     */
    public static String display(ArrayList<? extends Object> list) {
        StringBuilder builder = new StringBuilder();

        for (int i = 0; i < list.size(); i++) {
            builder.append(i + 1);
            builder.append(". ");
            builder.append(list.get(i).toString());
            builder.append('\n');
        }

        return builder.toString().trim();
    }
}
```
###### /java/linenux/util/Either.java
``` java
/**
 * A data structure inspired by the FP world. Can be used to represent an operation that can have two possible
 * outcomes. For example, when parsing something, the output is either the result, or an error.
 *
 * Instances of {@code Either} are immutable. The left and right values are wrapped by {@code Optional}.
 * Exactly one of them must be empty and the other present. To enforce this restriction, {@code Either} must
 * be built using the static factory methods.
 */
public class Either<L, R> {
    /**
     * A custom implementation of the {@code Optional} class. The default Java implementation does not
     * allow {@code null}, which is a good thing, but is not suitable in this context since an
     * {@code Either} should be able to store {@code null} values too.
     * @param <T> Any type.
     */
    private static class NullableOptional<T> {
        public static <T> NullableOptional<T> empty() {
            NullableOptional<T> output = new NullableOptional<>();
            output.isPresent = false;
            return output;
        }

        public static <T> NullableOptional<T> of(T value) {
            NullableOptional<T> output = new NullableOptional<>();
            output.isPresent = true;
            output.value = value;
            return output;
        }

        private boolean isPresent;
        private T value;

        public boolean isPresent() {
            return this.isPresent;
        }

        public T get() {
            if (!this.isPresent()) {
                throw new NoSuchElementException();
            }

            return this.value;
        }
    }

    private NullableOptional<L> left;
    private NullableOptional<R> right;

    /**
     * Make an {@code Either} with a left value.
     * @param <L> The left type.
     * @param <R> The right type.
     * @return An instance of {@code Either} with a left value.
     */
    public static <L, R> Either<L, R> left(L left) {
        return new Either<>(NullableOptional.of(left), NullableOptional.empty());
    }

    /**
     * Make an {@code Either} with a right value.
     * @param right The right value.
     * @param <L> The left type.
     * @param <R> The right type.
     * @return An instance of {@code Either} with a right value.
     */
    public static <L, R> Either<L, R> right(R right) {
        return new Either<>(NullableOptional.empty(), NullableOptional.of(right));
    }

    /**
     * Construct an {@code Either}. Exactly one of {@code left} and {@code right} must be empty.
     * @param left The left optional.
     * @param right The right optional.
     */
    private Either(NullableOptional<L> left, NullableOptional<R> right) {
        this.left = left;
        this.right = right;
    }

    /**
     * Returns true if and only if the left value is not empty.
     * @return True if left is not empty.
     */
    public boolean isLeft() {
        return this.left.isPresent();
    }

    /**
     * Return true if and only if the right value is not empty.
     * @return True if right is not empty.
     */
    public boolean isRight() {
        return this.right.isPresent();
    }

    /**
     * Return the left value.
     * @return The left value. If the left value is empty, {@code NoSuchElementException} will be thrown.
     */
    public L getLeft() throws NoSuchElementException {
        return this.left.get();
    }

    /**
     * Return the right value.
     * @return The right value. If the right value is empty, {@code NoSuchElementException} will be thrown.
     */
    public R getRight() {
        return this.right.get();
    }

    /**
     * Execute a function with the left value skip otherwise.
     * @param function The function to execute.
     * @param <T> The normal return type of {@code function}.
     * @return An {@code Either}.
     */
    public <T> Either<T, R> bind(Function<L, Either<T, R>> function) {
        if (this.isRight()) {
            return Either.right(this.getRight());
        } else {
            return function.apply(this.getLeft());
        }
    }
}
```
###### /java/linenux/util/LocalDateTimeUtil.java
``` java
/**
 * Static functions for LocalDateTime.
 */
public class LocalDateTimeUtil {
    /**
     * Return the earlier of two instances of {@code LocalDateTime}.
     * @param a The first {@code LocalDateTime}.
     * @param b The second {@code LocalDateTime}.
     * @return The earlier of {@code a} and {@code b}.
     */
    public static LocalDateTime min(LocalDateTime a, LocalDateTime b) {
        return a.compareTo(b) < 0 ? a : b;
    }

    /**
     * Returns the later of two instances of {@code LocalDateTime}.
     * @param a The first {@code LocalDateTime}.
     * @param b The second {@code LocalDateTime}.
     * @return The later of {@code a} and {@code b}.
     */
    public static LocalDateTime max(LocalDateTime a, LocalDateTime b) {
        return a.compareTo(b) > 0 ? a : b;
    }

    /**
     * Formats a LocalDateTime of format "dd MMM yyyy h.mma".
     */
    public static String toString(LocalDateTime time) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd MMM yyyy h.mma");
        return time.format(formatter);
    }

}
```
###### /java/linenux/util/StringsSimilarity.java
``` java
/**
 * Computes the similarity between two strings.
 */
public class StringsSimilarity {
    /**
     * Computes the similarity between two strings.
     * @param a The first string.
     * @param b The second string.
     * @return The Levenshtein distance between {@code a} and {@code b}.
     */
    public static int compute(String a, String b) {
        int l1 = a.length();
        int l2 = b.length();
        int[][] dp = new int[l1+1][l2+1];

        for (int i = 1; i <= l1; i++) {
            dp[i][0] = i;
        }

        for (int i = 1; i <= l2; i++) {
            dp[0][i] = i;
        }

        for (int i = 1; i <= l1; i++) {
            for (int j = 1; j <= l2; j++) {
                int add = dp[i-1][j] + 1;
                int delete = dp[i][j-1] + 1;
                int swap = dp[i-1][j-1] + (a.charAt(i-1) == b.charAt(j-1) ? 0 : 2);
                dp[i][j] = Math.min(Math.min(add, delete), swap);
            }
        }

        return dp[l1][l2];
    }
}
```
###### /java/linenux/util/ThrowableUtil.java
``` java
public class ThrowableUtil {
    /**
     * Display the stack trace of {@code throwable} as a {@code String}.
     * @param throwable The {@code Throwable} to display.
     * @return The {@code String} representing the stack trace.
     */
    public static String getStackTrace(Throwable throwable) {
        StringWriter stringWriter = new StringWriter();
        PrintWriter printWriter = new PrintWriter(stringWriter);
        throwable.printStackTrace(printWriter);
        return stringWriter.toString();
    }
}
```
###### /java/linenux/view/Alerts.java
``` java
/**
 * Helper functions to show alert.
 */
public class Alerts {
    /**
     * Show an alert.
     * @param title The title of the alert.
     * @param contentText The content of the alert.
     */
    public static void alert(String title, String contentText) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setContentText(contentText);
        alert.showAndWait();
    }

    /**
     * Show an alert and end the program.
     * @param title The title of the alert.
     * @param contentText The content of the alert.
     */
    public static void alertAndDie(String title, String contentText) {
        alert(title, contentText);
        System.exit(1);
    }

    /**
     * Asks the user a yes/no question.
     * @param title The title of the alert.
     * @param contentText the content of the alert.
     * @return {@code true} if and only if the user chose yes.
     */
    public static boolean alertAndConfirm(String title, String contentText) {
        Alert alert = new Alert(Alert.AlertType.ERROR, contentText, ButtonType.YES, ButtonType.NO);
        alert.setTitle(title);
        return alert.showAndWait().orElse(ButtonType.NO) == ButtonType.YES;

    }
}
```
###### /java/linenux/view/components/Result.java
``` java
/**
 * A view component to display a {@code CommandResult}.
 */
public class Result {
    private HBox root;

    @FXML
    private Label label;

    private String result;
    private Runnable onClose;

    /**
     * Instantiate {@code Result} with the string to display and a callback.
     * @param result The {@code String} to display.
     * @param onClose A callback that will be executed when the close button is clicked.
     */
    public Result(String result, Runnable onClose) {
        this.result = result;
        this.onClose = onClose;
        this.setupView();
    }

    /**
     * Load and setup the subview components.
     */
    private void setupView() {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainWindowController.class.getResource("/view/Result.fxml"));
            loader.setController(this);
            this.root = loader.load();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Display the text when the subviews are ready.
     */
    @FXML
    private void initialize() {
        this.label.setText(this.result);
    }

    /**
     * Callback when the close button is clicked.
     */
    @FXML
    private void onCloseButtonClicked() {
        this.onClose.run();
    }

    /**
     * @return The root container.
     */
    public HBox getRoot() {
        return this.root;
    }
}
```
###### /java/linenux/view/ResultsOverlayController.java
``` java
/**
 * Controller for the overlay results, which is the set of shorter {@code CommandResult}.
 */
public class ResultsOverlayController {
    @FXML
    private VBox container;

    private Timer timer = new Timer();
    private ControlUnit controlUnit;
    private ObservableList<String> messages = FXCollections.observableArrayList();
    private ArrayList<TimerTask> pendingTasks = new ArrayList<>();

    /**
     * Update the application {@code ControlUnit}.
     * @param controlUnit The new {@code ControlUnit}.
     */
    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        this.controlUnit.getLastCommandResultProperty().addListener((change) -> {
            CommandResult lastResult = this.controlUnit.getLastCommandResultProperty().get();
            String feedback = lastResult.getFeedback().trim();

            if (!feedback.contains("\n") && feedback.length() > 0) {
                this.messages.add(lastResult.getFeedback());

                TimerTask task = this.autoRemovalTask();
                this.timer.schedule(task, 5000);
                this.pendingTasks.add(task);
            }
        });
    }

    /**
     * Initializes subviews.
     */
    @FXML
    private void initialize() {
        this.messages.addListener((ListChangeListener<? super String>) (change) -> {
            this.render();
        });
    }

    /**
     * Ensure that the UI is in the correct state.
     */
    private void render() {
        ArrayList<HBox> children = new ArrayListUtil.ChainableArrayListUtil<>(new ArrayList<>(messages))
                .mapWithIndex((message, i) -> {
                    Runnable runnable = () -> {
                        ResultsOverlayController.this.pendingTasks.get(i).run();
                        ResultsOverlayController.this.pendingTasks.get(i).cancel();
                    };
                    return new Result(message, runnable);
                })
                .map(Result::getRoot)
                .value();

        this.container.getChildren().setAll(children);
    }

    /**
     * @return A {@code TimerTask} that will remove the latest {@code CommandResult} when executed.
     */
    private TimerTask autoRemovalTask() {
        return new TimerTask() {
            @Override
            public void run() {
                Platform.runLater(() -> {
                    ResultsOverlayController.this.messages.remove(0);
                    ResultsOverlayController.this.pendingTasks.remove(0);
                });
            }
        };
    }
}
```
###### /resources/view/Result.css
``` css
.result {
    -fx-background-color: #00838f;
    -fx-background-radius: 5px;
}

.result .label {
    -fx-text-fill: white;
}

.result .btn-close {
    -fx-background-color: white;
    -fx-text-fill: #00838f;
    -fx-background-radius: 2px;
    -fx-padding: 0 3px;
}
```
