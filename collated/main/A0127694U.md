# A0127694U
###### /java/linenux/command/DeleteCommand.java
``` java
/**
 * Deletes a task from the schedule.
 */
public class DeleteCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "delete";
    private static final String DESCRIPTION = "Deletes a task from the schedule.";
    private static final String COMMAND_FORMAT = "delete KEYWORDS";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private ArrayList<Task> foundTasks;

    /**
     * Constructs a {@code DeleteCommand}.
     * @param schedule The {@code Schedule} to search and delete {@code Task} from.
     */
    public DeleteCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(keywords);

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(keywords);
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            this.schedule.deleteTask(task);
            return makeDeletedTask(task);
        } else {
            setResponse(true, tasks);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                this.schedule.deleteTask(task);

                setResponse(false, null);
                return makeDeletedTask(task);
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Updates the user response status.
     * @param requiresUserResponse Whether or not this {@code Command} is expecting user response.
     * @param foundTasks An {@code ArrayList} of {@code Task} matching some search criteria.
     */
    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
    }

    /**
     * @return A {@code CommandResult} indicating that the user does not specify a keywords.
     */
    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @param task The deleted {@code Task}.
     * @return A {@code CommandResult} indicating that {@code task} is deleted.
     */
    private CommandResult makeDeletedTask(Task task) {
        return () -> "Deleted \"" + task.getTaskName() + "\".";
    }

    /**
     * @return A {@code CommandResult} indicating that the delete operation is cancelled.
     */
    private CommandResult makeCancelledResult() {
        return () -> "OK! Not deleting anything.";
    }

    /**
     * @param userInput A {@code String} representing the user response.
     * @return A {@code CommandResult} indicating that {@code userInput} is invalid.
     */
    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to delete.\n");
            builder.append(ArrayListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/DeleteReminderCommand.java
``` java
/**
 * Handles deletion of reminders from schedule.
 */
public class DeleteReminderCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "deleter";
    private static final String DESCRIPTION = "Deletes a task reminder from the schedule.";
    private static final String COMMAND_FORMAT = "deleter KEYWORDS";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private ArrayList<ReminderSearchResult> foundReminders;

    /**
     * Constructs a {@code DeleteReminderCommand}.
     * @param schedule The {@code Schedule} to search and delete {@code Reminder} from.
     */
    public DeleteReminderCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String keywords = extractArgument(userInput);

        if (keywords.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<ReminderSearchResult> results = new ArrayListUtil.ChainableArrayListUtil<>(
                this.schedule.getTaskList()).map(task -> new ReminderSearchResult(task, task.searchReminder(keywords)))
                        .filter(result -> result.getReminders().size() > 0).value();

        int totalResults = new ArrayListUtil.ChainableArrayListUtil<>(results).map(ReminderSearchResult::getReminders)
                .map(ArrayList::size).foldr((a, b) -> a + b, 0);

        if (totalResults == 0) {
            return SearchResults.makeReminderNotFoundResult(keywords);
        } else if (totalResults == 1) {
            ReminderSearchResult result = results.get(0);
            this.schedule.deleteReminder(result);
            return makeDeletedReminder(result);
        } else {
            setResponse(true, results);
            return PromptResults.makePromptReminderIndexResult(results);
        }
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.foundReminders != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundReminders.size()) {
                ReminderSearchResult reminder = this.foundReminders.get(index - 1);
                this.schedule.deleteReminder(reminder);

                setResponse(false, null);
                return makeDeletedReminder(reminder);
            } else {
                return PromptResults.makeInvalidReminderIndexResult(this.foundReminders);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Updates the user response status.
     * @param requiresUserResponse Whether or not this {@code Command} is expecting user response.
     * @param reminders An {@code ArrayList} of {@code Reminder} matching some search criteria.
     */
    private void setResponse(boolean requiresUserResponse, ArrayList<ReminderSearchResult> reminders) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundReminders = reminders;
    }

    /**
     * @return A {@code CommandResult} indicating that the user does not specify a keywords.
     */
    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @param remind The {@code ReminderSearchResult} indicated the deleted result.
     * @return A {@code CommandResult} indicating that {@code task} is deleted.
     */
    private CommandResult makeDeletedReminder(ReminderSearchResult remind) {
        return () -> "Deleted reminder \"" + remind.getReminders().get(0).toString() + "\" from task \""
                + remind.getTask().getTaskName() + "\".";
    }

    /**
     * @return A {@code CommandResult} indicating that the delete operation is cancelled.
     */
    private CommandResult makeCancelledResult() {
        return () -> "OK! Not deleting anything.";
    }

    /**
     * @param userInput A {@code String} representing the user response.
     * @return A {@code CommandResult} indicating that {@code userInput} is invalid.
     */
    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which reminder to delete.\n");
            builder.append(RemindersListUtil.displaySearchResults(this.foundReminders));
            return builder.toString();
        };
    }
}
```
###### /java/linenux/command/EditCommand.java
``` java
/**
 * Edits a task in the schedule.
 */
public class EditCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "edit";
    private static final String DESCRIPTION = "Edits a task in the schedule.";
    public static final String COMMAND_FORMAT = "edit KEYWORDS... [n/NEW_NAME][st/START_TIME][et/END_TIME][#/TAG...]...";

    private static final String NUMBER_PATTERN = "^\\d+$";
    private static final String CANCEL_PATTERN = "^cancel$";

    private Schedule schedule;
    private boolean requiresUserResponse;
    private GenericParser.GenericParserResult parseResult;
    private ArrayList<Task> foundTasks;
    private TimeParserManager timeParserManager;
    private EditArgumentParser editArgumentParser;

    /**
     * Constructs an {@code EditCommand}.
     * @param schedule The {@code Schedule} to search and edit {@code Task} from.
     */
    public EditCommand(Schedule schedule) {
        this.schedule = schedule;
        this.timeParserManager = new TimeParserManager(new ISODateWithTimeParser(), new StandardDateWithTimeParser(), new TodayWithTimeParser(), new TomorrowWithTimeParser());
        this.editArgumentParser = new EditArgumentParser(this.timeParserManager, COMMAND_FORMAT, CALLOUTS);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);
        GenericParser parser = new GenericParser();
        GenericParser.GenericParserResult result = parser.parse(argument);

        if (result.getKeywords().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> tasks = this.schedule.search(result.getKeywords());

        if (tasks.size() == 0) {
            return SearchResults.makeNotFoundResult(result.getKeywords());
        } else if (tasks.size() == 1) {
            Task task = tasks.get(0);
            return implementEdit(task, result);
        } else {
            setResponse(true, tasks, result);
            return PromptResults.makePromptIndexResult(tasks);
        }
    }

    /**
     * @return {@code true} if and only if this {@code Command} is awaiting for user response.
     */
    @Override
    public boolean isAwaitingUserResponse() {
        return requiresUserResponse;
    }

    /**
     * Process the response given by the user.
     * @param userInput {@code String} representing the user response.
     * @return A {@code CommandResult}, which is the result of processing {@code userInput}.
     */
    @Override
    public CommandResult processUserResponse(String userInput) {
        assert this.parseResult != null;
        assert this.foundTasks != null;
        assert this.schedule != null;

        if (userInput.matches(NUMBER_PATTERN)) {
            int index = Integer.parseInt(userInput);

            if (1 <= index && index <= this.foundTasks.size()) {
                Task task = this.foundTasks.get(index - 1);
                CommandResult result = implementEdit(task, this.parseResult);
                setResponse(false, null, null);
                return result;
            } else {
                return PromptResults.makeInvalidIndexResult(this.foundTasks);
            }
        } else if (userInput.matches(CANCEL_PATTERN)) {
            setResponse(false, null, null);
            return makeCancelledResult();
        } else {
            return makeInvalidUserResponse(userInput);
        }
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * Performs the actual editing.
     * @param original The original {@code Task} to edit.
     * @param parseResult The result of parsing user argument.
     * @return A {@code CommandResult} for the operation.
     */
    private CommandResult implementEdit(Task original, GenericParser.GenericParserResult parseResult) {
        Either<Task, CommandResult> result = editArgumentParser.parse(original, parseResult);

        if (result.isRight()) {
            return result.getRight();
        }

        Task editedTask = result.getLeft();

        // Will still allow edit if the edited task is equals to the original
        // task.
        if (this.schedule.isUniqueTask(editedTask) || editedTask.equals(original)) {
            this.schedule.updateTask(original, result.getLeft());
            return makeEditedTask(original, result.getLeft());
        } else {
            return makeDuplicateTaskResult(editedTask);
        }
    }

    /**
     * Updates the user response status.
     * @param requiresUserResponse Whether or not this {@code Command} is expecting user response.
     * @param foundTasks An {@code ArrayList} of {@code Task} matching some search criteria.
     * @param result The result of parsing the user argument.
     */
    private void setResponse(boolean requiresUserResponse, ArrayList<Task> foundTasks, GenericParser.GenericParserResult result) {
        this.requiresUserResponse = requiresUserResponse;
        this.foundTasks = foundTasks;
        this.parseResult = result;
    }

    /**
     * @return A {@code CommandResult} indicating that the user does not specify a keywords.
     */
    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    /**
     * @param original The {@code Task} before being edited.
     * @param task The updated {@code Task}.
     * @return A {@code CommandResult} informing the user that {@code original} has been updated to {@code task}.
     */
    private CommandResult makeEditedTask(Task original, Task task) {
        return () -> "Edited \"" + original.getTaskName() + "\".\nNew task details: " + task.toString();
    }

    /**
     * @return A {@code CommandResult} indicating that the edit operation is cancelled.
     */
    private CommandResult makeCancelledResult() {
        return () -> "OK! Not editing anything.";
    }

    /**
     * @param userInput A {@code String} representing the user response.
     * @return A {@code CommandResult} indicating that {@code userInput} is invalid.
     */
    private CommandResult makeInvalidUserResponse(String userInput) {
        return () -> {
            StringBuilder builder = new StringBuilder();
            builder.append("I don't understand \"" + userInput + "\".\n");
            builder.append("Enter a number to indicate which task to edit.\n");
            builder.append(ArrayListUtil.display(this.foundTasks));
            return builder.toString();
        };
    }

    // A0140702X
    /**
     * @param task The updated {@code Task}.
     * @return A {@code CommandResult} indicating that {@code task} is duplicated.
     */
    private CommandResult makeDuplicateTaskResult(Task task) {
        return () -> task.toString() + " already exists in the schedule!";
    }
}
```
###### /java/linenux/command/InformationCommand.java
``` java
/**
 * Displays current working information about Linenux.
 */
public class InformationCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "information";
    private static final String DESCRIPTION = "Displays current working information about Linenux.";
    private static final String COMMAND_FORMAT = "information";

    private Config config;

    /**
     * Instantiate an {@code InformationCommand}.
     * @param config The application config.
     */
    public InformationCommand(Config config) {
        this.config = config;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        return makeConfigDetails();
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    /**
     * @return A {@code String} representing a regular expression for this {@code Command}.
     */
    @Override
    public String getPattern() {
        return "(?i)^\\s*(" + getTriggerWordsPattern() + ")\\s*";
    }

    /**
     * @return A {@code CommandResult} representing the current app config.
     */
    private CommandResult makeConfigDetails() {
        StringBuilder builder = new StringBuilder();

        builder.append("Version: ");
        builder.append(config.getVersionNo() + "\n");
        builder.append("\n");

        builder.append("Current Working Directory: \n");
        builder.append(Paths.get("").toAbsolutePath().toString() + "\n");
        builder.append("\n");

        builder.append("Current Schedule Location: \n");
        builder.append(config.getScheduleFilePath() + "\n");
        builder.append("\n");

        return () -> builder.toString().trim();
    }
}

```
###### /java/linenux/command/parser/EditArgumentParser.java
``` java
/**
 * Parses new details of task to be edited.
 */
public class EditArgumentParser extends BaseArgumentParser {
    private GenericParser.GenericParserResult parseResult;
    public String commandFormat;
    public String callouts;

    /**
     * The public constructor for {@code EditArgumentParser}.
     * @param timeParserManager A {@code TimeParserManager} used to parse any date time string.
     * @param commandFormat A {@code String} representing the format of the command using this class.
     * @param callouts A {@code String}, which is an extra message added to the command result when argument is invalid.
     */
    public EditArgumentParser(TimeParserManager timeParserManager, String commandFormat, String callouts) {
        this.timeParserManager = timeParserManager;
        this.commandFormat = commandFormat;
        this.callouts = callouts;
    }

    /**
     * Attempts to parse an argument given by the user.
     * @param original A {@code Task}, the original {@code Task} object.
     * @param result A {@code GenericParserResult}, which is the output of {@code GenericParser}.
     * @return An {@code Either}. Its left slot is a {@code Task}, updated from {@code original} based on
     * {@code argument}, if {@code argument} represents a valid instruction to edit a {@code Task}. Otherwise, its
     * right slot contains a {@code CommandResult} indicating the failure.
     */
    public Either<Task, CommandResult> parse(Task original, GenericParser.GenericParserResult result) {
        this.parseResult = result;

        return Either.<Task, CommandResult>left(original)
                .bind(this::ensureNeedsEdit)
                .bind(this::updateTaskName)
                .bind(this::updateStartTime)
                .bind(this::updateEndTime)
                .bind(this::updateTags)
                .bind(this::ensureValidDateCombination)
                .bind(this::ensureValidEventTimes);
    }

    /**
     * Attempts to extract the new task name from the user argument.
     * @param task A {@code Task}, which is the original {@code Task} object.
     * @return An {@code Either}. If the user argument contains a valid task name, the left slot will be {@code task}
     * with its name updated. Otherwise, its right slot is a {@code CommandResult} indicating the failure.
     */
    private Either<Task, CommandResult> updateTaskName(Task task) {
        if (this.parseResult.getArguments("n").size() > 0) {
            String taskName = this.parseResult.getArguments("n").get(0);

            if (taskName.length() > 0) {
                return Either.left(task.setTaskName(taskName));
            } else {
                return Either.right(makeInvalidArgumentResult());
            }
        } else {
            return Either.left(task);
        }
    }

    /**
     * Attempts to extract the new start time from the user argument.
     * @param task A {@code Task}, which is the original {@code Task} object.
     * @return An {@code Either}. If the user argument contains a valid start time, the left slot will be {@code task}
     * with its start time updated. Otherwise, its right slot is a {@code CommandResult} indicating the failure.
     */
    private Either<Task, CommandResult> updateStartTime(Task task) {
        if (this.parseResult.getArguments("st").size() > 0) {
            return parseCancellableDateTime(this.parseResult.getArguments("st").get(0))
                    .bind(t -> Either.left(task.setStartTime(t)));
        } else {
            return Either.left(task);
        }
    }

    /**
     * Attempts to extract the new end time from the user argument.
     * @param task A {@code Task}, which is the original {@code Task} object.
     * @return An {@code Either}. If the user argument contains a valid end time, the left slot will be {@code task}
     * with its end time updated. Otherwise, its right slot is a {@code CommandResult} indicating the failure.
     */
    private Either<Task, CommandResult> updateEndTime(Task task) {
        if (this.parseResult.getArguments("et").size() > 0) {
            return parseCancellableDateTime(this.parseResult.getArguments("et").get(0))
                    .bind(t -> Either.left(task.setEndTime(t)));
        } else {
            return Either.left(task);
        }
    }

    /**
     * Attempts to extract the new tags from the user argument.
     * @param task A {@code Task}, which is the original {@code Task} object.
     * @return An {@code Either}. If the user argument contains valid new tags, the left slot will be {@code task}
     * with its tags updated. Otherwise, its right slot is a {@code CommandResult} indicating the failure.
     */
    private Either<Task, CommandResult> updateTags(Task task) {
        ArrayList<String> tags = ArrayListUtil.unique(this.parseResult.getArguments("#"));

        if (tags.size() == 0) {
            return Either.left(task);
        } else if (tags.indexOf("") != -1) {
            return Either.right(makeInvalidArgumentResult());
        } else if (tags.indexOf("-") != -1) {
            return Either.left(task.setTags(new ArrayList<>()));
        } else {
            return Either.left(task.setTags(tags));
        }
    }

    /**
     * Ensures that the user argument contains some instructions to edit a task.
     * @param task The {@code Task} to edit.
     * @return An {@code Either}. If the user argument contains some edit instructions, its left slot is {@code task}.
     * Otherwise, its right slot is a {@code CommandResult}.
     */
    private Either<Task, CommandResult> ensureNeedsEdit(Task task) {
        boolean needsEdit = new ArrayListUtil.ChainableArrayListUtil<>(new String[]{"n", "st", "et", "#"})
                .map(this.parseResult::getArguments)
                .map(ArrayList::size)
                .map(s -> s > 0)
                .foldr(Boolean::logicalOr, false);

        if (needsEdit) {
            return Either.left(task);
        } else {
            return Either.right(makeNoArgumentsResult());
        }
    }

    /**
     * Makes sure that {@code task} has a valid start time/end time combination. In particular, we do not allow
     * a {@code Task} to have a start time but not an end time.
     * @param task The {@code Task} to validate.
     * @return An {@code Either}. Its left slot is {@code task} if {@code task} is valid (in context). Otherwise,
     * its right slot contains a {@code CommandResult} describing the error.
     */
    private Either<Task, CommandResult> ensureValidDateCombination(Task task) {
        if (task.getStartTime() == null || task.getEndTime() != null) {
            return Either.left(task);
        } else {
            return Either.right(makeStartTimeWithoutEndTimeResult());
        }
    }

    /**
     * Makes sure that {@code task} has valid start time/end time. In particular, end time cannot come before start
     * time.
     * @param task The {@code Task} to validate.
     * @return An {@code Either}. Its left slot is {@code task} if {@code task} is valid (in context). Otherwise,
     * its right slot contains a {@code CommandResult} describing the error.
     */
    private Either<Task, CommandResult> ensureValidEventTimes(Task task) {
        if (task.getStartTime() == null || task.getEndTime() == null || task.getEndTime().compareTo(task.getStartTime()) >= 0) {
            return Either.left(task);
        } else {
            return Either.right(makeEndTimeBeforeStartTimeResult());
        }
    }

    /**
     * @return A {@code CommandResult} indicating that there is no instructions for change.
     */
    private CommandResult makeNoArgumentsResult() {
        return () -> "No changes to be made!";
    }

    /**
     * @return A {@code CommandResult} when the user argument is invalid.
     */
    private CommandResult makeInvalidArgumentResult() {
        return () -> "Invalid arguments.\n\n" + this.commandFormat + "\n\n" + this.callouts;
    }

    /**
     * @return A {@code CommandResult} describing that a {@code Task} cannot have a start time without an end time.
     */
    private CommandResult makeStartTimeWithoutEndTimeResult() {
        return () -> "Cannot create task with start time but without end time.";
    }

    /**
     * @return A {@code CommandResult} describing that the end time of a {@code Task} cannot come before its start time.
     */
    private CommandResult makeEndTimeBeforeStartTimeResult() {
        return () -> "End time cannot come before start time.";
    }
}
```
###### /java/linenux/command/parser/GenericParser.java
``` java
/**
 * A generic parser. This parser is supposed to be command-agnostic.
 */
public class GenericParser {
    private static final Pattern FIRST_FLAG_PATTERN = Pattern.compile("(^|\\s+)\\S+/");
    private static final Pattern FLAG_PATTERN = Pattern.compile("\\S+/");
    private static final Pattern NEXT_FLAG_PATTERN = Pattern.compile("\\s+\\S+/");

    /**
     * Parse {@code input}.
     * @param input A {@code String} representing the user input.
     * @return A {@code GenericParserResult} representing the parse result.
     */
    public GenericParserResult parse(String input) {
        GenericParserResult output = new GenericParserResult();

        String keywords = this.extractKeywords(input);
        output.setKeywords(keywords.trim());

        this.extractFlags(input, keywords.length(), output);

        return output;
    }

    /**
     * Attempts to extract keywords from {@code input}.
     * @param input A {@code String} representing the user input.
     * @return A {@code String}, the keywords.
     */
    private String extractKeywords(String input) {
        Matcher matcher = FIRST_FLAG_PATTERN.matcher(input);

        // Find the first flag. If there is no flag, the end index is at the end of string.
        int earliestIndex = input.length();
        if (matcher.find()) {
            earliestIndex = matcher.start();
        }

        return input.substring(0, earliestIndex);
    }

    /**
     * Extract the flags from {@code input}, updated {@code result}.
     * @param input A {@code String} to extract flags from.
     * @param index An {@code int} indicating the starting position in {@code input}.
     * @param result The {@code GenericParserResult} to mutate.
     */
    private void extractFlags(String input, int index, GenericParserResult result) {
        for (int i = index; i < input.length(); ) {
            // Find where the next flag starts. This is necessary as i might be pointing to a
            // space.
            int startingIndex = input.length();
            Matcher matcher = FLAG_PATTERN.matcher(input);
            if (matcher.find(i)) {
                startingIndex = matcher.start();
            }

            if (startingIndex >= input.length()) {
                return;
            }

            int endingIndex = input.length();
            matcher = NEXT_FLAG_PATTERN.matcher(input);
            if (matcher.find(startingIndex + 1)) {
                endingIndex = matcher.start();
            }

            String chunk = input.substring(startingIndex, endingIndex);
            String[] chunks = chunk.split("/", 2);
            result.addArgument(chunks[0], chunks[1].trim());

            i = endingIndex + 1;
        }
    }

    /**
     * A class representing the result of parsing user argument using {@code GenericParser}.
     */
    public static class GenericParserResult {
        // Perhaps we can use Optionals to signal the presence of these values.
        private String keywords;
        private HashMap<String, ArrayList<String>> arguments = new HashMap<>();

        /**
         * @return The keywords extracted from the user input.
         */
        public String getKeywords() {
            return this.keywords;
        }

        /**
         * Sets the keywords given by the user.
         * @param keywords A {@code String} representing the new keywords.
         */
        public void setKeywords(String keywords) {
            this.keywords = keywords;
        }

        /**
         * Returns the arguments for a {@code flag}.
         * @param flag A {@code String} representing the flag that we are interested in.
         * @return A {@code ArrayList} of arguments for {@code flag}.
         */
        public ArrayList<String> getArguments(String flag) {
            return this.arguments.getOrDefault(flag, new ArrayList<>());
        }

        /**
         * Add an argument for {@code flag}.
         * @param flag A {@code String} representing the flag.
         * @param value A {@code String} representing the argument for {@code flag}.
         */
        public void addArgument(String flag, String value) {
            if (!this.arguments.containsKey(flag)) {
                this.arguments.put(flag, new ArrayList<>());
            }

            this.arguments.get(flag).add(value);
        }
    }
}
```
###### /java/linenux/command/RenameCommand.java
``` java
/**
 * Renames all instances of a specified tag in schedule.
 */
public class RenameCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "rename";
    private static final String DESCRIPTION = "Changes the name of specified tag in all tasks.";
    public static final String COMMAND_FORMAT = "rename TAG_NAME... #/TAG...";

    private Schedule schedule;

    public RenameCommand(Schedule schedule) {
        this.schedule = schedule;
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    @Override
    public CommandResult execute(String userInput) {
        assert userInput.matches(getPattern());
        assert this.schedule != null;

        String argument = extractArgument(userInput);
        GenericParser parser = new GenericParser();
        GenericParser.GenericParserResult result = parser.parse(argument);
        String tagName = result.getKeywords();
        String newName = result.getArguments("#").size() > 0 ? result.getArguments("#").get(0) : "";

        if (tagName.trim().isEmpty() || newName.trim().isEmpty()) {
            return makeNoKeywordsResult();
        }

        ArrayList<Task> results = this.schedule.searchTag(tagName);

        if (results.size() == 0) {
            return SearchResults.makeTagNotFoundResult(tagName);
        } else {
            return implementRename(results, tagName, newName);
        }
    }

    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }

    private CommandResult implementRename(ArrayList<Task> original, String originalName, String newName) {
        ArrayList<Task> originalTasks = original;
        ArrayList<Task> modifiedTasks = new ArrayList<Task>();

        for (Task t : original) {
            assert (t.hasTag(originalName));
            for (int i = 0; i < t.getTags().size(); i++) {
                if (t.getTags().get(i).equalsIgnoreCase(originalName)) {
                    t.getTags().set(i, newName);
                    break;
                }
            }
            modifiedTasks.add(t);
        }

        this.schedule.updateTask(originalTasks, modifiedTasks);
        return makeRenameTag(originalName, newName);
    }

    private CommandResult makeNoKeywordsResult() {
        return () -> "Invalid arguments.\n\n" + COMMAND_FORMAT + "\n\n" + CALLOUTS;
    }

    private CommandResult makeRenameTag(String original, String newTag) {
        return () -> "Edited tag \"" + original + "\".\nNew tag name: " + newTag;
    }

}
```
###### /java/linenux/command/result/SearchResults.java
``` java
/**
 * A collection of helper functions related to searches.
 */
public class SearchResults {
    /**
     * @param keywords The keywords that the user is searching with.
     * @return A {@code CommandResult} informing that there is no tasks that match {@code keywords}.
     */
    public static CommandResult makeNotFoundResult(String keywords) {
        return () -> "Cannot find task names with \"" + keywords + "\".";
    }

    /**
     * @param keywords The keywords that the user is searching with.
     * @return A {@code CommandResult} informing that there is no reminders that match {@code keywords}.
     */
    public static CommandResult makeReminderNotFoundResult(String keywords) {
        return () -> "Cannot find reminders with \"" + keywords + "\".";
    }

    public static CommandResult makeTagNotFoundResult(String keywords) {
        return () -> "Cannot find tasks with tag \"" + keywords + "\".";
    }
}
```
###### /java/linenux/command/TodayCommand.java
``` java
public class TodayCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "today";
    private static final String DESCRIPTION = "Lists tasks and reminders for today.";
    private static final String COMMAND_FORMAT = "today";

    private Schedule schedule;
    private Clock clock;
    private ListCommand listCommand;

    public TodayCommand(Schedule schedule) {
        this(schedule, Clock.systemDefaultZone());
    }

    public TodayCommand(Schedule schedule, Clock clock) {
        this.schedule = schedule;
        this.clock = clock;
        this.listCommand = new ListCommand(this.schedule);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h.mma");
        LocalDateTime now = LocalDateTime.now(this.clock);
        LocalDateTime startOfToday = now.withHour(0).withMinute(0).withSecond(0);
        LocalDateTime endOfToday = now.withHour(23).withMinute(59).withSecond(59);

        return this.listCommand.execute("list et/" + endOfToday.format(formatter));
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }
}
```
###### /java/linenux/command/TomorrowCommand.java
``` java
public class TomorrowCommand extends AbstractCommand {
    private static final String TRIGGER_WORD = "tomorrow";
    private static final String DESCRIPTION = "Lists tasks and reminders for tomorrow.";
    private static final String COMMAND_FORMAT = "tomorrow";

    private Schedule schedule;
    private Clock clock;
    private ListCommand listCommand;

    public TomorrowCommand(Schedule schedule) {
        this(schedule, Clock.systemDefaultZone());
    }

    public TomorrowCommand(Schedule schedule, Clock clock) {
        this.schedule = schedule;
        this.clock = clock;
        this.listCommand = new ListCommand(this.schedule);
        this.TRIGGER_WORDS.add(TRIGGER_WORD);
    }

    /**
     * Executes the command based on {@code userInput}. This method operates under the assumption that
     * {@code respondTo(userInput)} is {@code true}.
     * @param userInput A {@code String} representing the user input.
     * @return A {@code CommandResult} representing the result of the command.
     */
    @Override
    public CommandResult execute(String userInput) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h.mma");
        LocalDateTime now = LocalDateTime.now(this.clock);
        LocalDateTime startOfTomorrow = now.withHour(0).withMinute(0).withSecond(0).plusDays(1);
        LocalDateTime endOfTomorrow = now.withHour(23).withMinute(59).withSecond(59).plusDays(1);

        return this.listCommand.execute("list st/" + startOfTomorrow.format(formatter) + " et/" + endOfTomorrow.format(formatter));
    }

    /**
     * @return A {@code String} representing the default command word.
     */
    @Override
    public String getTriggerWord() {
        return TRIGGER_WORD;
    }

    /**
     * @return A {@code String} describing what this {@code Command} does.
     */
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    /**
     * @return A {@code String} describing the format that this {@code Command} expects.
     */
    @Override
    public String getCommandFormat() {
        return COMMAND_FORMAT;
    }
}
```
###### /java/linenux/control/TimeParserManager.java
``` java
/**
 * Assigns time parsers based on user input.
 */
public class TimeParserManager {
    private ArrayList<TimeParser> parserList;

    public TimeParserManager(TimeParser... parsers) {
        parserList = new ArrayList<>();
        for (TimeParser parser: parsers){
            parserList.add(parser);
        }
    }

    /**
     * Check if the manager can parse some string
     * @param userInput The string to check
     * @return {@code true} if and only if at least one of the parsers can parse {@code userInput}
     */
    public boolean canParse(String userInput) {
        for (TimeParser parser: parserList) {
            if (parser.respondTo(userInput)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Assigns the appropriate time parser to the user input.
     */
    public LocalDateTime delegateTimeParser(String userInput) {
        for (TimeParser parser: parserList) {
            if (parser.respondTo(userInput)) {
                return parser.parse(userInput);
            }
        }
        return null;
    }
}
```
###### /java/linenux/model/Reminder.java
``` java
/**
 * Represents a reminder for a task.
 * Both note and timeOfReminder are required fields.
 */
public class Reminder {
    private String note;
    private LocalDateTime timeOfReminder;

    /**
     * Instantiates a {@code Reminder} with no note and time.
     */
    public Reminder() {
        this(null, null);
    }

    /**
     * Instantiates a {@code Reminder} with the specified note and time.
     * @param note The note of the reminder.
     * @param timeOfReminder The time of the reminder.
     */
    public Reminder(String note, LocalDateTime timeOfReminder) {
        this.note = note;
        this.timeOfReminder = timeOfReminder;
    }

    /**
     * The copy constructor of {@code Reminder}.
     * @param other The other instance of {@code Reminder} to copy from.
     */
    public Reminder(Reminder other) {
        this.note = other.note;
        this.timeOfReminder = other.timeOfReminder;
    }

    /**
     * @return The textual representation of the {@code Reminder}.
     */
    @Override
    public String toString() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd h.mma");

        if (this.note != null) {
            return this.note + " (On " + this.timeOfReminder.format(formatter) + ")";
        } else {
            return "Reminder on " + this.timeOfReminder.format(formatter);
        }
    }

    /**
     * Check equality.
     * @param other Another {@code Object} to compare with.
     * @return {@code true} if and only if they are equal.
     */
    @Override
    public boolean equals(Object other) {
        if (other == null || !(other instanceof Reminder)) {
            return false;
        }

        Reminder otherReminder = (Reminder) other;

        assert this.getNote() != null;
        assert otherReminder.getNote() != null;

        // testing for equality is not case-sensitive
        if (!this.getNote().toLowerCase().equals(otherReminder.getNote().toLowerCase())) {
            return false;
        }

        assert this.getTimeOfReminder() != null;
        assert otherReminder.getTimeOfReminder() != null;

        if (!this.getTimeOfReminder().equals(otherReminder.getTimeOfReminder())) {
            return false;
        }

        return true;
    }

    /**
     * @return The correct hash code for {@code Reminder}.
     */
    @Override
    public int hashCode() {
        return note.toLowerCase().hashCode() ^ timeOfReminder.hashCode();
    }

    /* Getters */

    /**
     * @return The note of the reminder.
     */
    public String getNote() {
        return this.note;
    }

    /**
     * @return The time of the reminder.
     */
    public LocalDateTime getTimeOfReminder() {
        return this.timeOfReminder;
    }

    /* Setters */

    /**
     * Update the note of the reminder.
     * @param newNote The new note.
     * @return A new {@code Reminder} with the note updated.
     */
    public Reminder setNote(String newNote) {
        Reminder output = new Reminder(this);
        output.note = newNote;
        return output;
    }

    /**
     * Update the time of the reminder.
     * @param newTimeOfReminder The new time
     * @return A new {@code Reminder} with the time updated.
     */
    public Reminder setTimeOfReminder(LocalDateTime newTimeOfReminder) {
        Reminder output = new Reminder(this);
        output.timeOfReminder = newTimeOfReminder;
        return output;
    }
}
```
###### /java/linenux/time/parser/TomorrowWithTimeParser.java
``` java
/**
 * Parse date and time in the form of "tomorrow 5.00pm"
 */
public class TomorrowWithTimeParser implements TimeParser {
    private static final String TOMORROW_TIME_PATTERN = "(?i)^tomorrow (1[012]|[1-9]).[0-5][0-9](\\s)?(am|pm)";

    private DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-M-d h.mma");
    private Clock clock = Clock.systemDefaultZone();

    /**
     * Checks if the user input corresponds to the format of the respective
     * time parser.
     *
     * @param input
     * @return true if format matches and false otherwise.
     */
    @Override
    public boolean respondTo(String input) {
        return input.matches(TOMORROW_TIME_PATTERN);
    }

    /**
     * Parses the userInput string to a time instance. This method assumes that {@code respondTo} returns {@code true}.
     * @param input The input to parse.
     * @return The {@code LocalDateTime}, which is the result of parsing {@code input}.
     */
    @Override
    public LocalDateTime parse(String input) {
        assert input.matches(TOMORROW_TIME_PATTERN);

        String tomorrowDate = LocalDate.now(this.clock).plusDays(1).toString();
        String time = input.split("\\s+")[1];
        String tomorrowDateTime = tomorrowDate + " " + time;

        return LocalDateTime.parse(tomorrowDateTime.toUpperCase(), formatter);
    }

    public void setClock(Clock clock) {
        this.clock = clock;
    }
}
```
###### /java/linenux/util/TimeInterval.java
``` java
/**
 * Represents a time interval represented by a pair of {@code LocalDateTime}.
 */
public class TimeInterval {
    private LocalDateTime from, to;

    /**
     * Instantiate an indeterminate {@code TimeInterval}.
     */
    public TimeInterval() {
        this(null, null);
    }

    /**
     * Instantiate a {@code TimeInterval} from the given start and end time.
     * @param from The beginning of the interval.
     * @param to The end of the interval.
     */
    public TimeInterval(LocalDateTime from, LocalDateTime to) {
        this.from = from;
        this.to = to;
    }

    /**
     * @return The beginning of the interval.
     */
    public LocalDateTime getFrom() {
        return this.from;
    }

    /**
     * @return The end of the interval.
     */
    public LocalDateTime getTo() {
        return this.to;
    }

    /**
     * @param from The new beginning of the interval.
     * @return A new {@code TimeInterval} with the updated beginning.
     */
    public TimeInterval setFrom(LocalDateTime from) {
        return new TimeInterval(from, this.to);
    }

    /**
     * @param to The new end of the interval.
     * @return A new {@code TimeInterval} with the updated ending.
     */
    public TimeInterval setTo(LocalDateTime to) {
        return new TimeInterval(this.from, to);
    }

    /**
     * Check if {@code query} is in this time interval.
     * @param query The {@code LocalDateTime} to check.
     * @return {@code true} if and only if {@code query} is in the current interval.
     */
    public boolean inInterval(LocalDateTime query) {
        return this.from.compareTo(query) <= 0 && query.compareTo(this.to) <= 0;
    }

    /**
     * Check if the current interval is trivial.
     * @return {@code true} if and only if the interval is trivial.
     */
    public boolean isTrivial() {
        return this.from.compareTo(this.to) == 0;
    }
}
```
###### /java/linenux/view/CommandBoxController.java
``` java
/**
 * Controller for the command box, which is where the user enters the command.
 */
public class CommandBoxController {
    @FXML
    private TextField textField;

    private ControlUnit controlUnit;
    private AutoCompleter autoCompleter;
    private ArrayList<String> history;
    private int historyIndex;

    /**
     * Initializes subviews.
     */
    @FXML
    private void initialize() {
        Platform.runLater(() -> textField.requestFocus());

        this.textField.setOnKeyPressed(event -> {
            if (event.getCode().equals(KeyCode.TAB)) {
                event.consume();
            }
        });

        this.textField.setOnKeyReleased(event -> {
            if (!event.getCode().equals(KeyCode.TAB)) {
                autoCompleter.clear();
            }

            if (event.getCode().equals(KeyCode.UP) && historyIndex > 0) {
                historyIndex--;
                this.textField.setText(this.history.get(historyIndex));
            } else if (event.getCode().equals(KeyCode.DOWN)) {
                if (historyIndex < this.history.size() - 1) {
                    historyIndex++;
                    this.textField.setText(this.history.get(historyIndex));
                } else if (historyIndex == this.history.size() - 1) {
                    historyIndex++;
                    this.textField.setText("");
                }
            } else if (event.getCode().equals(KeyCode.TAB)) {
                if (autoCompleter.hasNoSearchResult()) {
                    autoCompleter.findPrefix(this.textField.getText());
                }
                this.textField.setText(autoCompleter.next());
            } else {
                return;
            }


            this.textField.positionCaret(this.textField.getLength());
        });
    }

    /**
     * Callback when the user presses enter.
     */
    @FXML
    private void onCommand() {
        String command = textField.getText();
        this.history.add(command);
        this.historyIndex = this.history.size();
        this.autoCompleter.addStringsToTree(command);
        this.controlUnit.execute(command);
        textField.setText("");
    }

    /**
     * Update the {@code ControlUnit} of the application.
     * @param controlUnit The new {@code ControlUnit}.
     */
    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        this.autoCompleter = new AutoCompleter(this.controlUnit.getCommandList());
        this.history = new ArrayList<>();
        this.historyIndex = -1;
    }
}
```
###### /java/linenux/view/components/DeadlineCell.java
``` java
/**
 * View component used to display a single deadline.
 */
public class DeadlineCell extends ListCell<Task> {
    @FXML
    private Label title;

    @FXML
    private Label time;

    @FXML
    private Label tags;

    @FXML
    private AnchorPane container;

    private ListView<Task> parent;

    /**
     * Instantiate a {@code DeadlineCell}.
     * @param parent The {@code ListView} that uses this cell.
     */
    public DeadlineCell(ListView<Task> parent) {
        super();

        this.parent = parent;

        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(TodoCell.class.getResource("/view/DeadlineCell.fxml"));
            loader.setController(this);
            AnchorPane result = loader.load();
            this.setGraphic(result);
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }

    /**
     * Callback when the {@code Task} is updated.
     * @param task The new {@code Task}.
     * @param empty Whether the cell is empty.
     */
    @Override
    public void updateItem(Task task, boolean empty) {
        super.updateItem(task, empty);

        this.container.getStyleClass().removeAll("no-tags", "empty", "overdue", "done");

        if (empty || task == null) {
            this.container.getStyleClass().add("empty");
            this.title.setText("");
            this.time.setText("");
            this.tags.setText("");
        } else {
            ArrayList<String> tagsWithHash = new ArrayListUtil.ChainableArrayListUtil<>(task.getTags())
                    .map(tag -> "#" + tag)
                    .value();

            if (tagsWithHash.isEmpty()) {
                this.container.getStyleClass().add("no-tags");
            }

            if (task.isDone()) {
                this.container.getStyleClass().add("done");
            } else if (isOverdue(task)) {
                this.container.getStyleClass().add("overdue");
            }

            this.title.setText(task.getTaskName());
            this.time.setText(LocalDateTimeUtil.toString(task.getEndTime()));
            this.tags.setText(String.join(", ", tagsWithHash));
        }
    }

    /**
     * Check if a {@code Task} is overdue.
     * @param task The {@code Task} to check.
     * @return {@code true} if and only if {@code task} is overdue.
     */
    private boolean isOverdue(Task task) {
        if (task.isDeadline() || task.isEvent()) {
            LocalDateTime now = LocalDateTime.now();
            return now.isAfter(task.getEndTime());
        }
        return false;
    }

    /**
     * Callback to initialize the component when various children are ready.
     * Here we make sure that the container does not grow wider than the list.
     */
    @FXML
    private void initialize() {
        this.container.setMaxWidth(this.parent.getWidth());
        this.parent.widthProperty().addListener(change -> {
            this.container.setMaxWidth(this.parent.getWidth());
        });
    }
}
```
###### /java/linenux/view/EventBoxController.java
``` java
/**
 * Controller for the event box, which displays all the events
 */
public class EventBoxController {
    @FXML
    private ListView<Task> eventsList;

    private ControlUnit controlUnit;
    private ObservableList<Task> events = FXCollections.observableArrayList();

    /**
     * Initializes subviews.
     */
    @FXML
    private void initialize() {
        eventsList.itemsProperty().setValue(events);
        eventsList.setCellFactory(EventCell::new);
    }

    /**
     * Update the application {@code ControlUnit}.
     * @param controlUnit The new {@code ControlUnit}.
     */
    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        updateEvents();
        this.controlUnit.getSchedule().getStates().addListener((ListChangeListener<? super State>) c -> {
            updateEvents();
        });
        this.controlUnit.getSchedule().getFilteredTaskList().addListener((ListChangeListener<? super ArrayList<Task>>) c -> {
            updateFilteredEvents();
        });
    }

    /**
     * Render new events.
     */
    private void updateEvents() {
        ArrayList<Task> tasks = this.controlUnit.getSchedule().getTaskList();
        ArrayList<Task> undoneTasks = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isNotDone)
                .value();
        ArrayList<Task> events = filterEvents(undoneTasks);
        this.events.setAll(events);
    }

    /**
     * Render filtered events.
     */
    private void updateFilteredEvents() {
        ArrayList<Task> filteredTasks = this.controlUnit.getSchedule().getFilteredTasks();
        ArrayList<Task> events = filterEvents(filteredTasks);
        this.events.setAll(events);
    }

    /**
     * Sieve out only events.
     * @param tasks The original {@code ArrayList} of {@code Task}.
     * @return An {@code ArrayList} of {@code Task} which are events.
     */
    private ArrayList<Task> filterEvents(ArrayList<Task> tasks) {
        ArrayList<Task> events = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isEvent)
                .sortBy(Task::getTaskName)
                .sortBy(Task::getStartTime)
                .value();

        return events;
    }
}
```
###### /java/linenux/view/TodoBoxController.java
``` java
/**
 * Controller for the todo box, which displays all the todos
 */
public class TodoBoxController {
    @FXML
    private ListView<Task> todosList;

    private ControlUnit controlUnit;
    private ObservableList<Task> todos = FXCollections.observableArrayList();

    /**
     * Initializes subviews.
     */
    @FXML
    private void initialize() {
        todosList.itemsProperty().setValue(todos);
        todosList.setCellFactory(TodoCell::new);
    }

    /**
     * Update the application {@code ControlUnit}.
     * @param controlUnit The new {@code ControlUnit}.
     */
    public void setControlUnit(ControlUnit controlUnit) {
        this.controlUnit = controlUnit;
        updateTodos();
        this.controlUnit.getSchedule().getStates().addListener((ListChangeListener<? super State>) c -> {
            updateTodos();
        });
        this.controlUnit.getSchedule().getFilteredTaskList().addListener((ListChangeListener<? super ArrayList<Task>>) c -> {
            updateFilteredTodos();
        });
    }

    /**
     * Render new todos.
     */
    private void updateTodos() {
        ArrayList<Task> tasks = this.controlUnit.getSchedule().getTaskList();
        ArrayList<Task> undoneTasks = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(((Predicate<Task>) Task::isDone).negate())
                .value();
        ArrayList<Task> todos = filterToDos(undoneTasks);
        this.todos.setAll(todos);
    }

    /**
     * Render filtered todos.
     */
    private void updateFilteredTodos() {
        ArrayList<Task> filteredTasks = this.controlUnit.getSchedule().getFilteredTasks();
        ArrayList<Task> todos = filterToDos(filteredTasks);
        this.todos.setAll(todos);
    }

    /**
     * Sieve out only todos.
     * @param tasks The original {@code ArrayList} of {@code Task}.
     * @return An {@code ArrayList} of {@code Task} which are todos.
     */
    private ArrayList<Task> filterToDos(ArrayList<Task> tasks) {
        ArrayList<Task> todos = new ArrayListUtil.ChainableArrayListUtil<>(tasks)
                .filter(Task::isTodo)
                .sortBy(Task::getTaskName)
                .value();

        return todos;
    }
}
```
###### /resources/view/DeadlineCell.css
``` css
.deadlineCell {
    -fx-background-color: #83bdb8;
}

.deadlineCell .container {
    -fx-background-radius: 5px;
    -fx-background-color: rgba(196, 255, 255, .5);
    -fx-padding: 10px;
}

.deadlineCell.overdue .container {
    -fx-border-radius: 5px;
    -fx-border-width: 3px;
    -fx-background-color: rgba(255, 212, 212, .8);
    -fx-border-color: transparent transparent transparent red;
}

.deadlineCell.no-tags .container {
    -fx-padding: 10px 10px -5px 10px;
}

.deadlineCell.empty .container {
    -fx-background-color: #83bdb8;
}

.deadlineCell .name {
    -fx-font-size: 18.72px;
    -fx-font-weight: bold;
}

.deadlineCell.done .name .text {
    -fx-strikethrough: true;
}

.deadlineCell.overdue .name {
    -fx-text-fill: #b71c1c;
}

.deadlineCell .time {
    -fx-font-size: 16px;
    -fx-opacity: .7;
}

.deadlineCell.overdue .time {
    -fx-text-fill: red;
}

.deadlineCell .tags {
    -fx-alignment: center-right;
    -fx-opacity: .5;
    -fx-font-size: 12px;
}
```
###### /resources/view/LinenuxTheme.css
``` css

.vBox {
	-fx-background-color: #83bdb8;
}

.header {
	-fx-font: 24px sans-serif;
    -fx-text-fill: #006064;
}

.mainWindowAnchor {
	-fx-background-color: black;
	-fx-border-color: black transparent transparent transparent;
	-fx-border-width: 2px;
}

.commandBox {
    -fx-font-size: 12pt;
    -fx-font-family: "Consolas";
    -fx-font-weight: bold;
    -fx-text-fill: white;
    -fx-background-color: black;
    -fx-focus-color:transparent;
}

.todolist, .deadlineList, .eventList {
    -fx-background-color: #83bdb8;
    -fx-padding: 0;
}

.todolist .list-cell:even, .todolist .list-cell:odd,
.deadlineList .list-cell:even, .deadlineList .list-cell:odd,
.eventList .list-cell:even, .eventList .list-cell:odd {
    -fx-background-color: #83bdb8;
    -fx-padding: 5px 0;
}

.list-view .list-cell:empty {
	-fx-background-color: #83bdb8;
}

.list-view .scroll-bar:vertical .increment-arrow,
.list-view .scroll-bar:vertical .decrement-arrow,
.list-view .scroll-bar:vertical .increment-button,
.list-view .scroll-bar:vertical .decrement-button {
    -fx-padding:0;
}
```
